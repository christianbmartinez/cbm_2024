"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-util-events-to-acorn@2.0.2";
exports.ids = ["vendor-chunks/micromark-util-events-to-acorn@2.0.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/micromark-util-events-to-acorn@2.0.2/node_modules/micromark-util-events-to-acorn/dev/index.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/micromark-util-events-to-acorn@2.0.2/node_modules/micromark-util-events-to-acorn/dev/index.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eventsToAcorn: () => (/* binding */ eventsToAcorn)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_visit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! estree-util-visit */ \"(ssr)/./node_modules/.pnpm/estree-util-visit@2.0.0/node_modules/estree-util-visit/lib/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/.pnpm/micromark-util-symbol@2.0.0/node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/.pnpm/micromark-util-symbol@2.0.0/node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/.pnpm/micromark-util-symbol@2.0.0/node_modules/micromark-util-symbol/lib/values.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vfile-message */ \"(ssr)/./node_modules/.pnpm/vfile-message@4.0.2/node_modules/vfile-message/lib/index.js\");\n/**\n * @typedef {import('acorn').Comment} Comment\n * @typedef {import('acorn').Node} AcornNode\n * @typedef {import('acorn').Options} AcornOptions\n * @typedef {import('acorn').Token} Token\n * @typedef {import('estree').Node} EstreeNode\n * @typedef {import('estree').Program} Program\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Point} MicromarkPoint\n * @typedef {import('micromark-util-types').TokenType} TokenType\n * @typedef {import('unist').Point} UnistPoint\n */\n\n/**\n * @typedef Acorn\n *   Acorn-like interface.\n * @property {import('acorn').parse} parse\n *   Parse a program.\n * @property {import('acorn').parseExpressionAt} parseExpressionAt\n *   Parse an expression.\n *\n * @typedef AcornLoc\n * @property {number} line\n * @property {number} column\n *\n * @typedef AcornErrorFields\n * @property {number} raisedAt\n * @property {number} pos\n * @property {AcornLoc} loc\n *\n * @typedef {Error & AcornErrorFields} AcornError\n *\n * @typedef Options\n *   Configuration.\n * @property {Acorn} acorn\n *   Typically `acorn`, object with `parse` and `parseExpressionAt` fields (required).\n * @property {Array<TokenType>} tokenTypes\n *   Names of (void) tokens to consider as data; `'lineEnding'` is always\n *   included (required).\n * @property {AcornOptions | null | undefined} [acornOptions]\n *   Configuration for `acorn` (optional).\n * @property {MicromarkPoint | null | undefined} [start]\n *   Place where events start (optional, required if `allowEmpty`).\n * @property {string | null | undefined} [prefix='']\n *   Text to place before events (default: `''`).\n * @property {string | null | undefined} [suffix='']\n *   Text to place after events (default: `''`).\n * @property {boolean | null | undefined} [expression=false]\n *   Whether this is a program or expression (default: `false`).\n * @property {boolean | null | undefined} [allowEmpty=false]\n *   Whether an empty expression is allowed (programs are always allowed to\n *   be empty) (default: `false`).\n *\n * @typedef Result\n *   Result.\n * @property {Program | undefined} estree\n *   Program.\n * @property {AcornError | undefined} error\n *   Error if unparseable\n * @property {boolean} swallow\n *   Whether the error, if there is one, can be swallowed and more JavaScript\n *   could be valid.\n *\n * @typedef {[number, MicromarkPoint]} Stop\n *\n * @typedef Collection\n * @property {string} value\n * @property {Array<Stop>} stops\n */\n\n\n\n\n\n\n/**\n * Parse a list of micromark events with acorn.\n *\n * @param {Array<Event>} events\n *   Events.\n * @param {Options} options\n *   Configuration (required).\n * @returns {Result}\n *   Result.\n */\n// eslint-disable-next-line complexity\nfunction eventsToAcorn(events, options) {\n  const prefix = options.prefix || ''\n  const suffix = options.suffix || ''\n  const acornOptions = Object.assign({}, options.acornOptions)\n  /** @type {Array<Comment>} */\n  const comments = []\n  /** @type {Array<Token>} */\n  const tokens = []\n  const onComment = acornOptions.onComment\n  const onToken = acornOptions.onToken\n  let swallow = false\n  /** @type {AcornNode | undefined} */\n  let estree\n  /** @type {AcornError | undefined} */\n  let exception\n  /** @type {AcornOptions} */\n  const acornConfig = Object.assign({}, acornOptions, {\n    onComment: comments,\n    preserveParens: true\n  })\n\n  if (onToken) {\n    acornConfig.onToken = tokens\n  }\n\n  const collection = collect(events, options.tokenTypes)\n\n  const source = collection.value\n\n  const value = prefix + source + suffix\n  const isEmptyExpression = options.expression && empty(source)\n\n  if (isEmptyExpression && !options.allowEmpty) {\n    throw new vfile_message__WEBPACK_IMPORTED_MODULE_0__.VFileMessage('Unexpected empty expression', {\n      place: parseOffsetToUnistPoint(0),\n      ruleId: 'unexpected-empty-expression',\n      source: 'micromark-extension-mdx-expression'\n    })\n  }\n\n  try {\n    estree =\n      options.expression && !isEmptyExpression\n        ? options.acorn.parseExpressionAt(value, 0, acornConfig)\n        : options.acorn.parse(value, acornConfig)\n  } catch (error_) {\n    const error = /** @type {AcornError} */ (error_)\n    const point = parseOffsetToUnistPoint(error.pos)\n    error.message = String(error.message).replace(/ \\(\\d+:\\d+\\)$/, '')\n    // Always defined in our unist points that come from micromark.\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(point.offset !== undefined, 'expected `offset`')\n    error.pos = point.offset\n    error.loc = {line: point.line, column: point.column - 1}\n    exception = error\n    swallow =\n      error.raisedAt >= prefix.length + source.length ||\n      // Broken comments are raised at their start, not their end.\n      error.message === 'Unterminated comment'\n  }\n\n  if (estree && options.expression && !isEmptyExpression) {\n    if (empty(value.slice(estree.end, value.length - suffix.length))) {\n      estree = {\n        type: 'Program',\n        start: 0,\n        end: prefix.length + source.length,\n        // @ts-expect-error: It’s good.\n        body: [\n          {\n            type: 'ExpressionStatement',\n            expression: estree,\n            start: 0,\n            end: prefix.length + source.length\n          }\n        ],\n        sourceType: 'module',\n        comments: []\n      }\n    } else {\n      const point = parseOffsetToUnistPoint(estree.end)\n      const error = /** @type {AcornError} */ (\n        new Error('Unexpected content after expression')\n      )\n      // Always defined in our unist points that come from micromark.\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(point.offset !== undefined, 'expected `offset`')\n      error.pos = point.offset\n      error.loc = {line: point.line, column: point.column - 1}\n      exception = error\n      estree = undefined\n    }\n  }\n\n  if (estree) {\n    // @ts-expect-error: acorn *does* allow comments\n    estree.comments = comments\n\n    // @ts-expect-error: acorn looks enough like estree.\n    ;(0,estree_util_visit__WEBPACK_IMPORTED_MODULE_2__.visit)(estree, function (esnode, field, index, parents) {\n      let context = /** @type {AcornNode | Array<AcornNode>} */ (\n        parents[parents.length - 1]\n      )\n      /** @type {number | string | undefined} */\n      let prop = field\n\n      // Remove non-standard `ParenthesizedExpression`.\n      // @ts-expect-error: included in acorn.\n      if (esnode.type === 'ParenthesizedExpression' && context && prop) {\n        /* c8 ignore next 5 */\n        if (typeof index === 'number') {\n          // @ts-expect-error: indexable.\n          context = context[prop]\n          prop = index\n        }\n\n        // @ts-expect-error: indexable.\n        context[prop] = esnode.expression\n      }\n\n      fixPosition(esnode)\n    })\n\n    // Comment positions are fixed by `visit` because they’re in the tree.\n    if (Array.isArray(onComment)) {\n      onComment.push(...comments)\n    } else if (typeof onComment === 'function') {\n      for (const comment of comments) {\n        (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(comment.loc, 'expected `loc` on comment')\n        onComment(\n          comment.type === 'Block',\n          comment.value,\n          comment.start,\n          comment.end,\n          comment.loc.start,\n          comment.loc.end\n        )\n      }\n    }\n\n    for (const token of tokens) {\n      // Ignore tokens that ends in prefix or start in suffix:\n      if (\n        token.end <= prefix.length ||\n        token.start - prefix.length >= source.length\n      ) {\n        continue\n      }\n\n      fixPosition(token)\n\n      if (Array.isArray(onToken)) {\n        onToken.push(token)\n      } else {\n        // `tokens` are not added if `onToken` is not defined, so it must be a\n        // function.\n        (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(typeof onToken === 'function', 'expected function')\n        onToken(token)\n      }\n    }\n  }\n\n  // @ts-expect-error: It’s a program now.\n  return {estree, error: exception, swallow}\n\n  /**\n   * Update the position of a node.\n   *\n   * @param {AcornNode | EstreeNode | Token} nodeOrToken\n   * @returns {undefined}\n   */\n  function fixPosition(nodeOrToken) {\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n      'start' in nodeOrToken,\n      'expected `start` in node or token from acorn'\n    )\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)('end' in nodeOrToken, 'expected `end` in node or token from acorn')\n    const pointStart = parseOffsetToUnistPoint(nodeOrToken.start)\n    const pointEnd = parseOffsetToUnistPoint(nodeOrToken.end)\n    // Always defined in our unist points that come from micromark.\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(pointStart.offset !== undefined, 'expected `offset`')\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(pointEnd.offset !== undefined, 'expected `offset`')\n    nodeOrToken.start = pointStart.offset\n    nodeOrToken.end = pointEnd.offset\n    nodeOrToken.loc = {\n      start: {\n        line: pointStart.line,\n        column: pointStart.column - 1,\n        offset: pointStart.offset\n      },\n      end: {\n        line: pointEnd.line,\n        column: pointEnd.column - 1,\n        offset: pointEnd.offset\n      }\n    }\n    nodeOrToken.range = [nodeOrToken.start, nodeOrToken.end]\n  }\n\n  /**\n   * Turn an arbitrary offset into the parsed value, into a point in the source\n   * value.\n   *\n   * @param {number} acornOffset\n   * @returns {UnistPoint}\n   */\n  function parseOffsetToUnistPoint(acornOffset) {\n    let sourceOffset = acornOffset - prefix.length\n\n    if (sourceOffset < 0) {\n      sourceOffset = 0\n    } else if (sourceOffset > source.length) {\n      sourceOffset = source.length\n    }\n\n    let point = relativeToPoint(collection.stops, sourceOffset)\n\n    if (!point) {\n      (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n        options.start,\n        'empty expressions are need `options.start` being passed'\n      )\n      point = {\n        line: options.start.line,\n        column: options.start.column,\n        offset: options.start.offset\n      }\n    }\n\n    return point\n  }\n}\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nfunction empty(value) {\n  return /^\\s*$/.test(\n    value\n      // Multiline comments.\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n      // Line comments.\n      // EOF instead of EOL is specifically not allowed, because that would\n      // mean the closing brace is on the commented-out line\n      .replace(/\\/\\/[^\\r\\n]*(\\r\\n|\\n|\\r)/g, '')\n  )\n}\n\n// Port from <https://github.com/wooorm/markdown-rs/blob/e692ab0/src/util/mdx_collect.rs#L15>.\n/**\n * @param {Array<Event>} events\n * @param {Array<TokenType>} tokenTypes\n * @returns {Collection}\n */\nfunction collect(events, tokenTypes) {\n  /** @type {Collection} */\n  const result = {value: '', stops: []}\n  let index = -1\n\n  while (++index < events.length) {\n    const event = events[index]\n\n    // Assume void.\n    if (event[0] === 'enter') {\n      const type = event[1].type\n\n      if (type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding || tokenTypes.includes(type)) {\n        const chunks = event[2].sliceStream(event[1])\n\n        // Drop virtual spaces.\n        while (chunks.length > 0 && chunks[0] === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.virtualSpace) {\n          chunks.shift()\n        }\n\n        const value = serializeChunks(chunks)\n        result.stops.push([result.value.length, event[1].start])\n        result.value += value\n        result.stops.push([result.value.length, event[1].end])\n      }\n    }\n  }\n\n  return result\n}\n\n// Port from <https://github.com/wooorm/markdown-rs/blob/e692ab0/src/util/location.rs#L91>.\n/**\n * Turn a relative offset into an absolute offset.\n *\n * @param {Array<Stop>} stops\n * @param {number} relative\n * @returns {UnistPoint | undefined}\n */\nfunction relativeToPoint(stops, relative) {\n  let index = 0\n\n  while (index < stops.length && stops[index][0] <= relative) {\n    index += 1\n  }\n\n  // There are no points: that only occurs if there was an empty string.\n  if (index === 0) {\n    return undefined\n  }\n\n  const [stopRelative, stopAbsolute] = stops[index - 1]\n  const rest = relative - stopRelative\n  return {\n    line: stopAbsolute.line,\n    column: stopAbsolute.column + rest,\n    offset: stopAbsolute.offset + rest\n  }\n}\n\n// Copy from <https://github.com/micromark/micromark/blob/ce3593a/packages/micromark/dev/lib/create-tokenizer.js#L595>\n// To do: expose that?\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {Array<Chunk>} chunks\n * @returns {string}\n */\nfunction serializeChunks(chunks) {\n  let index = -1\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {boolean | undefined} */\n  let atTab\n\n  while (++index < chunks.length) {\n    const chunk = chunks[index]\n    /** @type {string} */\n    let value\n\n    if (typeof chunk === 'string') {\n      value = chunk\n    } else\n      switch (chunk) {\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.carriageReturn: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.cr\n\n          break\n        }\n\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.lineFeed: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.lf\n\n          break\n        }\n\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.carriageReturnLineFeed: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.cr + micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.lf\n\n          break\n        }\n\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.horizontalTab: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.ht\n\n          break\n        }\n\n        /* c8 ignore next 6 */\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.virtualSpace: {\n          if (atTab) continue\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.space\n\n          break\n        }\n\n        default: {\n          (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(typeof chunk === 'number', 'expected number')\n          // Currently only replacement character.\n          // eslint-disable-next-line unicorn/prefer-code-point\n          value = String.fromCharCode(chunk)\n        }\n      }\n\n    atTab = chunk === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.horizontalTab\n    result.push(value)\n  }\n\n  return result.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbWljcm9tYXJrLXV0aWwtZXZlbnRzLXRvLWFjb3JuQDIuMC4yL25vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1ldmVudHMtdG8tYWNvcm4vZGV2L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWEsdUJBQXVCO0FBQ3BDLGFBQWEsdUJBQXVCO0FBQ3BDLGFBQWEsMEJBQTBCO0FBQ3ZDLGFBQWEsc0NBQXNDO0FBQ25ELGFBQWEsc0NBQXNDO0FBQ25ELGFBQWEsc0NBQXNDO0FBQ25ELGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsdUJBQXVCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFVBQVU7QUFDeEI7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQyxpREFBaUQ7QUFDakQ7QUFDQSxjQUFjLGlDQUFpQztBQUMvQztBQUNBLGNBQWMsbUNBQW1DO0FBQ2pEO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBLGNB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QUFDQSxrREFBa0Qsd0RBQUs7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGFBQWEsd0RBQUs7QUFDbEIsa0JBQWtCLHlEQUFNOztBQUV4QjtBQUNBOztBQUVBLGFBQWEsd0RBQUs7QUFDbEIsa0JBQWtCLHlEQUFNOztBQUV4QjtBQUNBOztBQUVBLGFBQWEsd0RBQUs7QUFDbEIsa0JBQWtCLHlEQUFNLE1BQU0seURBQU07O0FBRXBDO0FBQ0E7O0FBRUEsYUFBYSx3REFBSztBQUNsQixrQkFBa0IseURBQU07O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHdEQUFLO0FBQ2xCO0FBQ0Esa0JBQWtCLHlEQUFNOztBQUV4QjtBQUNBOztBQUVBO0FBQ0EsVUFBVSwwQ0FBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix3REFBSztBQUMzQjtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYm1fMjAyNC8uL25vZGVfbW9kdWxlcy8ucG5wbS9taWNyb21hcmstdXRpbC1ldmVudHMtdG8tYWNvcm5AMi4wLjIvbm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLWV2ZW50cy10by1hY29ybi9kZXYvaW5kZXguanM/OTBlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2Fjb3JuJykuQ29tbWVudH0gQ29tbWVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnYWNvcm4nKS5Ob2RlfSBBY29ybk5vZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2Fjb3JuJykuT3B0aW9uc30gQWNvcm5PcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdhY29ybicpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuTm9kZX0gRXN0cmVlTm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuUHJvZ3JhbX0gUHJvZ3JhbVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5DaHVua30gQ2h1bmtcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlBvaW50fSBNaWNyb21hcmtQb2ludFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlblR5cGV9IFRva2VuVHlwZVxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5Qb2ludH0gVW5pc3RQb2ludFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgQWNvcm5cbiAqICAgQWNvcm4tbGlrZSBpbnRlcmZhY2UuXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnYWNvcm4nKS5wYXJzZX0gcGFyc2VcbiAqICAgUGFyc2UgYSBwcm9ncmFtLlxuICogQHByb3BlcnR5IHtpbXBvcnQoJ2Fjb3JuJykucGFyc2VFeHByZXNzaW9uQXR9IHBhcnNlRXhwcmVzc2lvbkF0XG4gKiAgIFBhcnNlIGFuIGV4cHJlc3Npb24uXG4gKlxuICogQHR5cGVkZWYgQWNvcm5Mb2NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29sdW1uXG4gKlxuICogQHR5cGVkZWYgQWNvcm5FcnJvckZpZWxkc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJhaXNlZEF0XG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9zXG4gKiBAcHJvcGVydHkge0Fjb3JuTG9jfSBsb2NcbiAqXG4gKiBAdHlwZWRlZiB7RXJyb3IgJiBBY29ybkVycm9yRmllbGRzfSBBY29ybkVycm9yXG4gKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICogQHByb3BlcnR5IHtBY29ybn0gYWNvcm5cbiAqICAgVHlwaWNhbGx5IGBhY29ybmAsIG9iamVjdCB3aXRoIGBwYXJzZWAgYW5kIGBwYXJzZUV4cHJlc3Npb25BdGAgZmllbGRzIChyZXF1aXJlZCkuXG4gKiBAcHJvcGVydHkge0FycmF5PFRva2VuVHlwZT59IHRva2VuVHlwZXNcbiAqICAgTmFtZXMgb2YgKHZvaWQpIHRva2VucyB0byBjb25zaWRlciBhcyBkYXRhOyBgJ2xpbmVFbmRpbmcnYCBpcyBhbHdheXNcbiAqICAgaW5jbHVkZWQgKHJlcXVpcmVkKS5cbiAqIEBwcm9wZXJ0eSB7QWNvcm5PcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2Fjb3JuT3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbiBmb3IgYGFjb3JuYCAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtNaWNyb21hcmtQb2ludCB8IG51bGwgfCB1bmRlZmluZWR9IFtzdGFydF1cbiAqICAgUGxhY2Ugd2hlcmUgZXZlbnRzIHN0YXJ0IChvcHRpb25hbCwgcmVxdWlyZWQgaWYgYGFsbG93RW1wdHlgKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3ByZWZpeD0nJ11cbiAqICAgVGV4dCB0byBwbGFjZSBiZWZvcmUgZXZlbnRzIChkZWZhdWx0OiBgJydgKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3N1ZmZpeD0nJ11cbiAqICAgVGV4dCB0byBwbGFjZSBhZnRlciBldmVudHMgKGRlZmF1bHQ6IGAnJ2ApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2V4cHJlc3Npb249ZmFsc2VdXG4gKiAgIFdoZXRoZXIgdGhpcyBpcyBhIHByb2dyYW0gb3IgZXhwcmVzc2lvbiAoZGVmYXVsdDogYGZhbHNlYCkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbYWxsb3dFbXB0eT1mYWxzZV1cbiAqICAgV2hldGhlciBhbiBlbXB0eSBleHByZXNzaW9uIGlzIGFsbG93ZWQgKHByb2dyYW1zIGFyZSBhbHdheXMgYWxsb3dlZCB0b1xuICogICBiZSBlbXB0eSkgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICpcbiAqIEB0eXBlZGVmIFJlc3VsdFxuICogICBSZXN1bHQuXG4gKiBAcHJvcGVydHkge1Byb2dyYW0gfCB1bmRlZmluZWR9IGVzdHJlZVxuICogICBQcm9ncmFtLlxuICogQHByb3BlcnR5IHtBY29ybkVycm9yIHwgdW5kZWZpbmVkfSBlcnJvclxuICogICBFcnJvciBpZiB1bnBhcnNlYWJsZVxuICogQHByb3BlcnR5IHtib29sZWFufSBzd2FsbG93XG4gKiAgIFdoZXRoZXIgdGhlIGVycm9yLCBpZiB0aGVyZSBpcyBvbmUsIGNhbiBiZSBzd2FsbG93ZWQgYW5kIG1vcmUgSmF2YVNjcmlwdFxuICogICBjb3VsZCBiZSB2YWxpZC5cbiAqXG4gKiBAdHlwZWRlZiB7W251bWJlciwgTWljcm9tYXJrUG9pbnRdfSBTdG9wXG4gKlxuICogQHR5cGVkZWYgQ29sbGVjdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZhbHVlXG4gKiBAcHJvcGVydHkge0FycmF5PFN0b3A+fSBzdG9wc1xuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge3Zpc2l0fSBmcm9tICdlc3RyZWUtdXRpbC12aXNpdCdcbmltcG9ydCB7Y29kZXMsIHR5cGVzLCB2YWx1ZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbCdcbmltcG9ydCB7VkZpbGVNZXNzYWdlfSBmcm9tICd2ZmlsZS1tZXNzYWdlJ1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBtaWNyb21hcmsgZXZlbnRzIHdpdGggYWNvcm4uXG4gKlxuICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICogICBFdmVudHMuXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiAocmVxdWlyZWQpLlxuICogQHJldHVybnMge1Jlc3VsdH1cbiAqICAgUmVzdWx0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50c1RvQWNvcm4oZXZlbnRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHByZWZpeCA9IG9wdGlvbnMucHJlZml4IHx8ICcnXG4gIGNvbnN0IHN1ZmZpeCA9IG9wdGlvbnMuc3VmZml4IHx8ICcnXG4gIGNvbnN0IGFjb3JuT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuYWNvcm5PcHRpb25zKVxuICAvKiogQHR5cGUge0FycmF5PENvbW1lbnQ+fSAqL1xuICBjb25zdCBjb21tZW50cyA9IFtdXG4gIC8qKiBAdHlwZSB7QXJyYXk8VG9rZW4+fSAqL1xuICBjb25zdCB0b2tlbnMgPSBbXVxuICBjb25zdCBvbkNvbW1lbnQgPSBhY29ybk9wdGlvbnMub25Db21tZW50XG4gIGNvbnN0IG9uVG9rZW4gPSBhY29ybk9wdGlvbnMub25Ub2tlblxuICBsZXQgc3dhbGxvdyA9IGZhbHNlXG4gIC8qKiBAdHlwZSB7QWNvcm5Ob2RlIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgZXN0cmVlXG4gIC8qKiBAdHlwZSB7QWNvcm5FcnJvciB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGV4Y2VwdGlvblxuICAvKiogQHR5cGUge0Fjb3JuT3B0aW9uc30gKi9cbiAgY29uc3QgYWNvcm5Db25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBhY29ybk9wdGlvbnMsIHtcbiAgICBvbkNvbW1lbnQ6IGNvbW1lbnRzLFxuICAgIHByZXNlcnZlUGFyZW5zOiB0cnVlXG4gIH0pXG5cbiAgaWYgKG9uVG9rZW4pIHtcbiAgICBhY29ybkNvbmZpZy5vblRva2VuID0gdG9rZW5zXG4gIH1cblxuICBjb25zdCBjb2xsZWN0aW9uID0gY29sbGVjdChldmVudHMsIG9wdGlvbnMudG9rZW5UeXBlcylcblxuICBjb25zdCBzb3VyY2UgPSBjb2xsZWN0aW9uLnZhbHVlXG5cbiAgY29uc3QgdmFsdWUgPSBwcmVmaXggKyBzb3VyY2UgKyBzdWZmaXhcbiAgY29uc3QgaXNFbXB0eUV4cHJlc3Npb24gPSBvcHRpb25zLmV4cHJlc3Npb24gJiYgZW1wdHkoc291cmNlKVxuXG4gIGlmIChpc0VtcHR5RXhwcmVzc2lvbiAmJiAhb3B0aW9ucy5hbGxvd0VtcHR5KSB7XG4gICAgdGhyb3cgbmV3IFZGaWxlTWVzc2FnZSgnVW5leHBlY3RlZCBlbXB0eSBleHByZXNzaW9uJywge1xuICAgICAgcGxhY2U6IHBhcnNlT2Zmc2V0VG9VbmlzdFBvaW50KDApLFxuICAgICAgcnVsZUlkOiAndW5leHBlY3RlZC1lbXB0eS1leHByZXNzaW9uJyxcbiAgICAgIHNvdXJjZTogJ21pY3JvbWFyay1leHRlbnNpb24tbWR4LWV4cHJlc3Npb24nXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgZXN0cmVlID1cbiAgICAgIG9wdGlvbnMuZXhwcmVzc2lvbiAmJiAhaXNFbXB0eUV4cHJlc3Npb25cbiAgICAgICAgPyBvcHRpb25zLmFjb3JuLnBhcnNlRXhwcmVzc2lvbkF0KHZhbHVlLCAwLCBhY29ybkNvbmZpZylcbiAgICAgICAgOiBvcHRpb25zLmFjb3JuLnBhcnNlKHZhbHVlLCBhY29ybkNvbmZpZylcbiAgfSBjYXRjaCAoZXJyb3JfKSB7XG4gICAgY29uc3QgZXJyb3IgPSAvKiogQHR5cGUge0Fjb3JuRXJyb3J9ICovIChlcnJvcl8pXG4gICAgY29uc3QgcG9pbnQgPSBwYXJzZU9mZnNldFRvVW5pc3RQb2ludChlcnJvci5wb3MpXG4gICAgZXJyb3IubWVzc2FnZSA9IFN0cmluZyhlcnJvci5tZXNzYWdlKS5yZXBsYWNlKC8gXFwoXFxkKzpcXGQrXFwpJC8sICcnKVxuICAgIC8vIEFsd2F5cyBkZWZpbmVkIGluIG91ciB1bmlzdCBwb2ludHMgdGhhdCBjb21lIGZyb20gbWljcm9tYXJrLlxuICAgIGFzc2VydChwb2ludC5vZmZzZXQgIT09IHVuZGVmaW5lZCwgJ2V4cGVjdGVkIGBvZmZzZXRgJylcbiAgICBlcnJvci5wb3MgPSBwb2ludC5vZmZzZXRcbiAgICBlcnJvci5sb2MgPSB7bGluZTogcG9pbnQubGluZSwgY29sdW1uOiBwb2ludC5jb2x1bW4gLSAxfVxuICAgIGV4Y2VwdGlvbiA9IGVycm9yXG4gICAgc3dhbGxvdyA9XG4gICAgICBlcnJvci5yYWlzZWRBdCA+PSBwcmVmaXgubGVuZ3RoICsgc291cmNlLmxlbmd0aCB8fFxuICAgICAgLy8gQnJva2VuIGNvbW1lbnRzIGFyZSByYWlzZWQgYXQgdGhlaXIgc3RhcnQsIG5vdCB0aGVpciBlbmQuXG4gICAgICBlcnJvci5tZXNzYWdlID09PSAnVW50ZXJtaW5hdGVkIGNvbW1lbnQnXG4gIH1cblxuICBpZiAoZXN0cmVlICYmIG9wdGlvbnMuZXhwcmVzc2lvbiAmJiAhaXNFbXB0eUV4cHJlc3Npb24pIHtcbiAgICBpZiAoZW1wdHkodmFsdWUuc2xpY2UoZXN0cmVlLmVuZCwgdmFsdWUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkpKSB7XG4gICAgICBlc3RyZWUgPSB7XG4gICAgICAgIHR5cGU6ICdQcm9ncmFtJyxcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGVuZDogcHJlZml4Lmxlbmd0aCArIHNvdXJjZS5sZW5ndGgsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEl04oCZcyBnb29kLlxuICAgICAgICBib2R5OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXN0cmVlLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IHByZWZpeC5sZW5ndGggKyBzb3VyY2UubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzb3VyY2VUeXBlOiAnbW9kdWxlJyxcbiAgICAgICAgY29tbWVudHM6IFtdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcGFyc2VPZmZzZXRUb1VuaXN0UG9pbnQoZXN0cmVlLmVuZClcbiAgICAgIGNvbnN0IGVycm9yID0gLyoqIEB0eXBlIHtBY29ybkVycm9yfSAqLyAoXG4gICAgICAgIG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZW50IGFmdGVyIGV4cHJlc3Npb24nKVxuICAgICAgKVxuICAgICAgLy8gQWx3YXlzIGRlZmluZWQgaW4gb3VyIHVuaXN0IHBvaW50cyB0aGF0IGNvbWUgZnJvbSBtaWNyb21hcmsuXG4gICAgICBhc3NlcnQocG9pbnQub2Zmc2V0ICE9PSB1bmRlZmluZWQsICdleHBlY3RlZCBgb2Zmc2V0YCcpXG4gICAgICBlcnJvci5wb3MgPSBwb2ludC5vZmZzZXRcbiAgICAgIGVycm9yLmxvYyA9IHtsaW5lOiBwb2ludC5saW5lLCBjb2x1bW46IHBvaW50LmNvbHVtbiAtIDF9XG4gICAgICBleGNlcHRpb24gPSBlcnJvclxuICAgICAgZXN0cmVlID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgaWYgKGVzdHJlZSkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGFjb3JuICpkb2VzKiBhbGxvdyBjb21tZW50c1xuICAgIGVzdHJlZS5jb21tZW50cyA9IGNvbW1lbnRzXG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhY29ybiBsb29rcyBlbm91Z2ggbGlrZSBlc3RyZWUuXG4gICAgdmlzaXQoZXN0cmVlLCBmdW5jdGlvbiAoZXNub2RlLCBmaWVsZCwgaW5kZXgsIHBhcmVudHMpIHtcbiAgICAgIGxldCBjb250ZXh0ID0gLyoqIEB0eXBlIHtBY29ybk5vZGUgfCBBcnJheTxBY29ybk5vZGU+fSAqLyAoXG4gICAgICAgIHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXVxuICAgICAgKVxuICAgICAgLyoqIEB0eXBlIHtudW1iZXIgfCBzdHJpbmcgfCB1bmRlZmluZWR9ICovXG4gICAgICBsZXQgcHJvcCA9IGZpZWxkXG5cbiAgICAgIC8vIFJlbW92ZSBub24tc3RhbmRhcmQgYFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uYC5cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGluY2x1ZGVkIGluIGFjb3JuLlxuICAgICAgaWYgKGVzbm9kZS50eXBlID09PSAnUGFyZW50aGVzaXplZEV4cHJlc3Npb24nICYmIGNvbnRleHQgJiYgcHJvcCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCA1ICovXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW5kZXhhYmxlLlxuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0W3Byb3BdXG4gICAgICAgICAgcHJvcCA9IGluZGV4XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbmRleGFibGUuXG4gICAgICAgIGNvbnRleHRbcHJvcF0gPSBlc25vZGUuZXhwcmVzc2lvblxuICAgICAgfVxuXG4gICAgICBmaXhQb3NpdGlvbihlc25vZGUpXG4gICAgfSlcblxuICAgIC8vIENvbW1lbnQgcG9zaXRpb25zIGFyZSBmaXhlZCBieSBgdmlzaXRgIGJlY2F1c2UgdGhleeKAmXJlIGluIHRoZSB0cmVlLlxuICAgIGlmIChBcnJheS5pc0FycmF5KG9uQ29tbWVudCkpIHtcbiAgICAgIG9uQ29tbWVudC5wdXNoKC4uLmNvbW1lbnRzKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9uQ29tbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm9yIChjb25zdCBjb21tZW50IG9mIGNvbW1lbnRzKSB7XG4gICAgICAgIGFzc2VydChjb21tZW50LmxvYywgJ2V4cGVjdGVkIGBsb2NgIG9uIGNvbW1lbnQnKVxuICAgICAgICBvbkNvbW1lbnQoXG4gICAgICAgICAgY29tbWVudC50eXBlID09PSAnQmxvY2snLFxuICAgICAgICAgIGNvbW1lbnQudmFsdWUsXG4gICAgICAgICAgY29tbWVudC5zdGFydCxcbiAgICAgICAgICBjb21tZW50LmVuZCxcbiAgICAgICAgICBjb21tZW50LmxvYy5zdGFydCxcbiAgICAgICAgICBjb21tZW50LmxvYy5lbmRcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAvLyBJZ25vcmUgdG9rZW5zIHRoYXQgZW5kcyBpbiBwcmVmaXggb3Igc3RhcnQgaW4gc3VmZml4OlxuICAgICAgaWYgKFxuICAgICAgICB0b2tlbi5lbmQgPD0gcHJlZml4Lmxlbmd0aCB8fFxuICAgICAgICB0b2tlbi5zdGFydCAtIHByZWZpeC5sZW5ndGggPj0gc291cmNlLmxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGZpeFBvc2l0aW9uKHRva2VuKVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvblRva2VuKSkge1xuICAgICAgICBvblRva2VuLnB1c2godG9rZW4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBgdG9rZW5zYCBhcmUgbm90IGFkZGVkIGlmIGBvblRva2VuYCBpcyBub3QgZGVmaW5lZCwgc28gaXQgbXVzdCBiZSBhXG4gICAgICAgIC8vIGZ1bmN0aW9uLlxuICAgICAgICBhc3NlcnQodHlwZW9mIG9uVG9rZW4gPT09ICdmdW5jdGlvbicsICdleHBlY3RlZCBmdW5jdGlvbicpXG4gICAgICAgIG9uVG9rZW4odG9rZW4pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogSXTigJlzIGEgcHJvZ3JhbSBub3cuXG4gIHJldHVybiB7ZXN0cmVlLCBlcnJvcjogZXhjZXB0aW9uLCBzd2FsbG93fVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtBY29ybk5vZGUgfCBFc3RyZWVOb2RlIHwgVG9rZW59IG5vZGVPclRva2VuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBmdW5jdGlvbiBmaXhQb3NpdGlvbihub2RlT3JUb2tlbikge1xuICAgIGFzc2VydChcbiAgICAgICdzdGFydCcgaW4gbm9kZU9yVG9rZW4sXG4gICAgICAnZXhwZWN0ZWQgYHN0YXJ0YCBpbiBub2RlIG9yIHRva2VuIGZyb20gYWNvcm4nXG4gICAgKVxuICAgIGFzc2VydCgnZW5kJyBpbiBub2RlT3JUb2tlbiwgJ2V4cGVjdGVkIGBlbmRgIGluIG5vZGUgb3IgdG9rZW4gZnJvbSBhY29ybicpXG4gICAgY29uc3QgcG9pbnRTdGFydCA9IHBhcnNlT2Zmc2V0VG9VbmlzdFBvaW50KG5vZGVPclRva2VuLnN0YXJ0KVxuICAgIGNvbnN0IHBvaW50RW5kID0gcGFyc2VPZmZzZXRUb1VuaXN0UG9pbnQobm9kZU9yVG9rZW4uZW5kKVxuICAgIC8vIEFsd2F5cyBkZWZpbmVkIGluIG91ciB1bmlzdCBwb2ludHMgdGhhdCBjb21lIGZyb20gbWljcm9tYXJrLlxuICAgIGFzc2VydChwb2ludFN0YXJ0Lm9mZnNldCAhPT0gdW5kZWZpbmVkLCAnZXhwZWN0ZWQgYG9mZnNldGAnKVxuICAgIGFzc2VydChwb2ludEVuZC5vZmZzZXQgIT09IHVuZGVmaW5lZCwgJ2V4cGVjdGVkIGBvZmZzZXRgJylcbiAgICBub2RlT3JUb2tlbi5zdGFydCA9IHBvaW50U3RhcnQub2Zmc2V0XG4gICAgbm9kZU9yVG9rZW4uZW5kID0gcG9pbnRFbmQub2Zmc2V0XG4gICAgbm9kZU9yVG9rZW4ubG9jID0ge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgbGluZTogcG9pbnRTdGFydC5saW5lLFxuICAgICAgICBjb2x1bW46IHBvaW50U3RhcnQuY29sdW1uIC0gMSxcbiAgICAgICAgb2Zmc2V0OiBwb2ludFN0YXJ0Lm9mZnNldFxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBsaW5lOiBwb2ludEVuZC5saW5lLFxuICAgICAgICBjb2x1bW46IHBvaW50RW5kLmNvbHVtbiAtIDEsXG4gICAgICAgIG9mZnNldDogcG9pbnRFbmQub2Zmc2V0XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGVPclRva2VuLnJhbmdlID0gW25vZGVPclRva2VuLnN0YXJ0LCBub2RlT3JUb2tlbi5lbmRdXG4gIH1cblxuICAvKipcbiAgICogVHVybiBhbiBhcmJpdHJhcnkgb2Zmc2V0IGludG8gdGhlIHBhcnNlZCB2YWx1ZSwgaW50byBhIHBvaW50IGluIHRoZSBzb3VyY2VcbiAgICogdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhY29ybk9mZnNldFxuICAgKiBAcmV0dXJucyB7VW5pc3RQb2ludH1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlT2Zmc2V0VG9VbmlzdFBvaW50KGFjb3JuT2Zmc2V0KSB7XG4gICAgbGV0IHNvdXJjZU9mZnNldCA9IGFjb3JuT2Zmc2V0IC0gcHJlZml4Lmxlbmd0aFxuXG4gICAgaWYgKHNvdXJjZU9mZnNldCA8IDApIHtcbiAgICAgIHNvdXJjZU9mZnNldCA9IDBcbiAgICB9IGVsc2UgaWYgKHNvdXJjZU9mZnNldCA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHNvdXJjZU9mZnNldCA9IHNvdXJjZS5sZW5ndGhcbiAgICB9XG5cbiAgICBsZXQgcG9pbnQgPSByZWxhdGl2ZVRvUG9pbnQoY29sbGVjdGlvbi5zdG9wcywgc291cmNlT2Zmc2V0KVxuXG4gICAgaWYgKCFwb2ludCkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBvcHRpb25zLnN0YXJ0LFxuICAgICAgICAnZW1wdHkgZXhwcmVzc2lvbnMgYXJlIG5lZWQgYG9wdGlvbnMuc3RhcnRgIGJlaW5nIHBhc3NlZCdcbiAgICAgIClcbiAgICAgIHBvaW50ID0ge1xuICAgICAgICBsaW5lOiBvcHRpb25zLnN0YXJ0LmxpbmUsXG4gICAgICAgIGNvbHVtbjogb3B0aW9ucy5zdGFydC5jb2x1bW4sXG4gICAgICAgIG9mZnNldDogb3B0aW9ucy5zdGFydC5vZmZzZXRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGVtcHR5KHZhbHVlKSB7XG4gIHJldHVybiAvXlxccyokLy50ZXN0KFxuICAgIHZhbHVlXG4gICAgICAvLyBNdWx0aWxpbmUgY29tbWVudHMuXG4gICAgICAucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy9nLCAnJylcbiAgICAgIC8vIExpbmUgY29tbWVudHMuXG4gICAgICAvLyBFT0YgaW5zdGVhZCBvZiBFT0wgaXMgc3BlY2lmaWNhbGx5IG5vdCBhbGxvd2VkLCBiZWNhdXNlIHRoYXQgd291bGRcbiAgICAgIC8vIG1lYW4gdGhlIGNsb3NpbmcgYnJhY2UgaXMgb24gdGhlIGNvbW1lbnRlZC1vdXQgbGluZVxuICAgICAgLnJlcGxhY2UoL1xcL1xcL1teXFxyXFxuXSooXFxyXFxufFxcbnxcXHIpL2csICcnKVxuICApXG59XG5cbi8vIFBvcnQgZnJvbSA8aHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9tYXJrZG93bi1ycy9ibG9iL2U2OTJhYjAvc3JjL3V0aWwvbWR4X2NvbGxlY3QucnMjTDE1Pi5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICogQHBhcmFtIHtBcnJheTxUb2tlblR5cGU+fSB0b2tlblR5cGVzXG4gKiBAcmV0dXJucyB7Q29sbGVjdGlvbn1cbiAqL1xuZnVuY3Rpb24gY29sbGVjdChldmVudHMsIHRva2VuVHlwZXMpIHtcbiAgLyoqIEB0eXBlIHtDb2xsZWN0aW9ufSAqL1xuICBjb25zdCByZXN1bHQgPSB7dmFsdWU6ICcnLCBzdG9wczogW119XG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgY29uc3QgZXZlbnQgPSBldmVudHNbaW5kZXhdXG5cbiAgICAvLyBBc3N1bWUgdm9pZC5cbiAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBldmVudFsxXS50eXBlXG5cbiAgICAgIGlmICh0eXBlID09PSB0eXBlcy5saW5lRW5kaW5nIHx8IHRva2VuVHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gZXZlbnRbMl0uc2xpY2VTdHJlYW0oZXZlbnRbMV0pXG5cbiAgICAgICAgLy8gRHJvcCB2aXJ0dWFsIHNwYWNlcy5cbiAgICAgICAgd2hpbGUgKGNodW5rcy5sZW5ndGggPiAwICYmIGNodW5rc1swXSA9PT0gY29kZXMudmlydHVhbFNwYWNlKSB7XG4gICAgICAgICAgY2h1bmtzLnNoaWZ0KClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2VyaWFsaXplQ2h1bmtzKGNodW5rcylcbiAgICAgICAgcmVzdWx0LnN0b3BzLnB1c2goW3Jlc3VsdC52YWx1ZS5sZW5ndGgsIGV2ZW50WzFdLnN0YXJ0XSlcbiAgICAgICAgcmVzdWx0LnZhbHVlICs9IHZhbHVlXG4gICAgICAgIHJlc3VsdC5zdG9wcy5wdXNoKFtyZXN1bHQudmFsdWUubGVuZ3RoLCBldmVudFsxXS5lbmRdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gUG9ydCBmcm9tIDxodHRwczovL2dpdGh1Yi5jb20vd29vb3JtL21hcmtkb3duLXJzL2Jsb2IvZTY5MmFiMC9zcmMvdXRpbC9sb2NhdGlvbi5ycyNMOTE+LlxuLyoqXG4gKiBUdXJuIGEgcmVsYXRpdmUgb2Zmc2V0IGludG8gYW4gYWJzb2x1dGUgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8U3RvcD59IHN0b3BzXG4gKiBAcGFyYW0ge251bWJlcn0gcmVsYXRpdmVcbiAqIEByZXR1cm5zIHtVbmlzdFBvaW50IHwgdW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiByZWxhdGl2ZVRvUG9pbnQoc3RvcHMsIHJlbGF0aXZlKSB7XG4gIGxldCBpbmRleCA9IDBcblxuICB3aGlsZSAoaW5kZXggPCBzdG9wcy5sZW5ndGggJiYgc3RvcHNbaW5kZXhdWzBdIDw9IHJlbGF0aXZlKSB7XG4gICAgaW5kZXggKz0gMVxuICB9XG5cbiAgLy8gVGhlcmUgYXJlIG5vIHBvaW50czogdGhhdCBvbmx5IG9jY3VycyBpZiB0aGVyZSB3YXMgYW4gZW1wdHkgc3RyaW5nLlxuICBpZiAoaW5kZXggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBbc3RvcFJlbGF0aXZlLCBzdG9wQWJzb2x1dGVdID0gc3RvcHNbaW5kZXggLSAxXVxuICBjb25zdCByZXN0ID0gcmVsYXRpdmUgLSBzdG9wUmVsYXRpdmVcbiAgcmV0dXJuIHtcbiAgICBsaW5lOiBzdG9wQWJzb2x1dGUubGluZSxcbiAgICBjb2x1bW46IHN0b3BBYnNvbHV0ZS5jb2x1bW4gKyByZXN0LFxuICAgIG9mZnNldDogc3RvcEFic29sdXRlLm9mZnNldCArIHJlc3RcbiAgfVxufVxuXG4vLyBDb3B5IGZyb20gPGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb21hcmsvbWljcm9tYXJrL2Jsb2IvY2UzNTkzYS9wYWNrYWdlcy9taWNyb21hcmsvZGV2L2xpYi9jcmVhdGUtdG9rZW5pemVyLmpzI0w1OTU+XG4vLyBUbyBkbzogZXhwb3NlIHRoYXQ/XG4vKipcbiAqIEdldCB0aGUgc3RyaW5nIHZhbHVlIG9mIGEgc2xpY2Ugb2YgY2h1bmtzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Q2h1bms+fSBjaHVua3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUNodW5rcyhjaHVua3MpIHtcbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuICAvKiogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBhdFRhYlxuXG4gIHdoaWxlICgrK2luZGV4IDwgY2h1bmtzLmxlbmd0aCkge1xuICAgIGNvbnN0IGNodW5rID0gY2h1bmtzW2luZGV4XVxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIGxldCB2YWx1ZVxuXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gY2h1bmtcbiAgICB9IGVsc2VcbiAgICAgIHN3aXRjaCAoY2h1bmspIHtcbiAgICAgICAgY2FzZSBjb2Rlcy5jYXJyaWFnZVJldHVybjoge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmNyXG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBjb2Rlcy5saW5lRmVlZDoge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmxmXG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBjb2Rlcy5jYXJyaWFnZVJldHVybkxpbmVGZWVkOiB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuY3IgKyB2YWx1ZXMubGZcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIGNvZGVzLmhvcml6b250YWxUYWI6IHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5odFxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDYgKi9cbiAgICAgICAgY2FzZSBjb2Rlcy52aXJ0dWFsU3BhY2U6IHtcbiAgICAgICAgICBpZiAoYXRUYWIpIGNvbnRpbnVlXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuc3BhY2VcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgYXNzZXJ0KHR5cGVvZiBjaHVuayA9PT0gJ251bWJlcicsICdleHBlY3RlZCBudW1iZXInKVxuICAgICAgICAgIC8vIEN1cnJlbnRseSBvbmx5IHJlcGxhY2VtZW50IGNoYXJhY3Rlci5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItY29kZS1wb2ludFxuICAgICAgICAgIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHVuaylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgYXRUYWIgPSBjaHVuayA9PT0gY29kZXMuaG9yaXpvbnRhbFRhYlxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/micromark-util-events-to-acorn@2.0.2/node_modules/micromark-util-events-to-acorn/dev/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/micromark-util-events-to-acorn@2.0.2/node_modules/micromark-util-events-to-acorn/dev/index.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/micromark-util-events-to-acorn@2.0.2/node_modules/micromark-util-events-to-acorn/dev/index.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eventsToAcorn: () => (/* binding */ eventsToAcorn)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(rsc)/./node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_visit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! estree-util-visit */ \"(rsc)/./node_modules/.pnpm/estree-util-visit@2.0.0/node_modules/estree-util-visit/lib/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/./node_modules/.pnpm/micromark-util-symbol@2.0.0/node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/./node_modules/.pnpm/micromark-util-symbol@2.0.0/node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/./node_modules/.pnpm/micromark-util-symbol@2.0.0/node_modules/micromark-util-symbol/lib/values.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vfile-message */ \"(rsc)/./node_modules/.pnpm/vfile-message@4.0.2/node_modules/vfile-message/lib/index.js\");\n/**\n * @typedef {import('acorn').Comment} Comment\n * @typedef {import('acorn').Node} AcornNode\n * @typedef {import('acorn').Options} AcornOptions\n * @typedef {import('acorn').Token} Token\n * @typedef {import('estree').Node} EstreeNode\n * @typedef {import('estree').Program} Program\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Point} MicromarkPoint\n * @typedef {import('micromark-util-types').TokenType} TokenType\n * @typedef {import('unist').Point} UnistPoint\n */\n\n/**\n * @typedef Acorn\n *   Acorn-like interface.\n * @property {import('acorn').parse} parse\n *   Parse a program.\n * @property {import('acorn').parseExpressionAt} parseExpressionAt\n *   Parse an expression.\n *\n * @typedef AcornLoc\n * @property {number} line\n * @property {number} column\n *\n * @typedef AcornErrorFields\n * @property {number} raisedAt\n * @property {number} pos\n * @property {AcornLoc} loc\n *\n * @typedef {Error & AcornErrorFields} AcornError\n *\n * @typedef Options\n *   Configuration.\n * @property {Acorn} acorn\n *   Typically `acorn`, object with `parse` and `parseExpressionAt` fields (required).\n * @property {Array<TokenType>} tokenTypes\n *   Names of (void) tokens to consider as data; `'lineEnding'` is always\n *   included (required).\n * @property {AcornOptions | null | undefined} [acornOptions]\n *   Configuration for `acorn` (optional).\n * @property {MicromarkPoint | null | undefined} [start]\n *   Place where events start (optional, required if `allowEmpty`).\n * @property {string | null | undefined} [prefix='']\n *   Text to place before events (default: `''`).\n * @property {string | null | undefined} [suffix='']\n *   Text to place after events (default: `''`).\n * @property {boolean | null | undefined} [expression=false]\n *   Whether this is a program or expression (default: `false`).\n * @property {boolean | null | undefined} [allowEmpty=false]\n *   Whether an empty expression is allowed (programs are always allowed to\n *   be empty) (default: `false`).\n *\n * @typedef Result\n *   Result.\n * @property {Program | undefined} estree\n *   Program.\n * @property {AcornError | undefined} error\n *   Error if unparseable\n * @property {boolean} swallow\n *   Whether the error, if there is one, can be swallowed and more JavaScript\n *   could be valid.\n *\n * @typedef {[number, MicromarkPoint]} Stop\n *\n * @typedef Collection\n * @property {string} value\n * @property {Array<Stop>} stops\n */\n\n\n\n\n\n\n/**\n * Parse a list of micromark events with acorn.\n *\n * @param {Array<Event>} events\n *   Events.\n * @param {Options} options\n *   Configuration (required).\n * @returns {Result}\n *   Result.\n */\n// eslint-disable-next-line complexity\nfunction eventsToAcorn(events, options) {\n  const prefix = options.prefix || ''\n  const suffix = options.suffix || ''\n  const acornOptions = Object.assign({}, options.acornOptions)\n  /** @type {Array<Comment>} */\n  const comments = []\n  /** @type {Array<Token>} */\n  const tokens = []\n  const onComment = acornOptions.onComment\n  const onToken = acornOptions.onToken\n  let swallow = false\n  /** @type {AcornNode | undefined} */\n  let estree\n  /** @type {AcornError | undefined} */\n  let exception\n  /** @type {AcornOptions} */\n  const acornConfig = Object.assign({}, acornOptions, {\n    onComment: comments,\n    preserveParens: true\n  })\n\n  if (onToken) {\n    acornConfig.onToken = tokens\n  }\n\n  const collection = collect(events, options.tokenTypes)\n\n  const source = collection.value\n\n  const value = prefix + source + suffix\n  const isEmptyExpression = options.expression && empty(source)\n\n  if (isEmptyExpression && !options.allowEmpty) {\n    throw new vfile_message__WEBPACK_IMPORTED_MODULE_0__.VFileMessage('Unexpected empty expression', {\n      place: parseOffsetToUnistPoint(0),\n      ruleId: 'unexpected-empty-expression',\n      source: 'micromark-extension-mdx-expression'\n    })\n  }\n\n  try {\n    estree =\n      options.expression && !isEmptyExpression\n        ? options.acorn.parseExpressionAt(value, 0, acornConfig)\n        : options.acorn.parse(value, acornConfig)\n  } catch (error_) {\n    const error = /** @type {AcornError} */ (error_)\n    const point = parseOffsetToUnistPoint(error.pos)\n    error.message = String(error.message).replace(/ \\(\\d+:\\d+\\)$/, '')\n    // Always defined in our unist points that come from micromark.\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(point.offset !== undefined, 'expected `offset`')\n    error.pos = point.offset\n    error.loc = {line: point.line, column: point.column - 1}\n    exception = error\n    swallow =\n      error.raisedAt >= prefix.length + source.length ||\n      // Broken comments are raised at their start, not their end.\n      error.message === 'Unterminated comment'\n  }\n\n  if (estree && options.expression && !isEmptyExpression) {\n    if (empty(value.slice(estree.end, value.length - suffix.length))) {\n      estree = {\n        type: 'Program',\n        start: 0,\n        end: prefix.length + source.length,\n        // @ts-expect-error: It’s good.\n        body: [\n          {\n            type: 'ExpressionStatement',\n            expression: estree,\n            start: 0,\n            end: prefix.length + source.length\n          }\n        ],\n        sourceType: 'module',\n        comments: []\n      }\n    } else {\n      const point = parseOffsetToUnistPoint(estree.end)\n      const error = /** @type {AcornError} */ (\n        new Error('Unexpected content after expression')\n      )\n      // Always defined in our unist points that come from micromark.\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(point.offset !== undefined, 'expected `offset`')\n      error.pos = point.offset\n      error.loc = {line: point.line, column: point.column - 1}\n      exception = error\n      estree = undefined\n    }\n  }\n\n  if (estree) {\n    // @ts-expect-error: acorn *does* allow comments\n    estree.comments = comments\n\n    // @ts-expect-error: acorn looks enough like estree.\n    ;(0,estree_util_visit__WEBPACK_IMPORTED_MODULE_2__.visit)(estree, function (esnode, field, index, parents) {\n      let context = /** @type {AcornNode | Array<AcornNode>} */ (\n        parents[parents.length - 1]\n      )\n      /** @type {number | string | undefined} */\n      let prop = field\n\n      // Remove non-standard `ParenthesizedExpression`.\n      // @ts-expect-error: included in acorn.\n      if (esnode.type === 'ParenthesizedExpression' && context && prop) {\n        /* c8 ignore next 5 */\n        if (typeof index === 'number') {\n          // @ts-expect-error: indexable.\n          context = context[prop]\n          prop = index\n        }\n\n        // @ts-expect-error: indexable.\n        context[prop] = esnode.expression\n      }\n\n      fixPosition(esnode)\n    })\n\n    // Comment positions are fixed by `visit` because they’re in the tree.\n    if (Array.isArray(onComment)) {\n      onComment.push(...comments)\n    } else if (typeof onComment === 'function') {\n      for (const comment of comments) {\n        (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(comment.loc, 'expected `loc` on comment')\n        onComment(\n          comment.type === 'Block',\n          comment.value,\n          comment.start,\n          comment.end,\n          comment.loc.start,\n          comment.loc.end\n        )\n      }\n    }\n\n    for (const token of tokens) {\n      // Ignore tokens that ends in prefix or start in suffix:\n      if (\n        token.end <= prefix.length ||\n        token.start - prefix.length >= source.length\n      ) {\n        continue\n      }\n\n      fixPosition(token)\n\n      if (Array.isArray(onToken)) {\n        onToken.push(token)\n      } else {\n        // `tokens` are not added if `onToken` is not defined, so it must be a\n        // function.\n        (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(typeof onToken === 'function', 'expected function')\n        onToken(token)\n      }\n    }\n  }\n\n  // @ts-expect-error: It’s a program now.\n  return {estree, error: exception, swallow}\n\n  /**\n   * Update the position of a node.\n   *\n   * @param {AcornNode | EstreeNode | Token} nodeOrToken\n   * @returns {undefined}\n   */\n  function fixPosition(nodeOrToken) {\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n      'start' in nodeOrToken,\n      'expected `start` in node or token from acorn'\n    )\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)('end' in nodeOrToken, 'expected `end` in node or token from acorn')\n    const pointStart = parseOffsetToUnistPoint(nodeOrToken.start)\n    const pointEnd = parseOffsetToUnistPoint(nodeOrToken.end)\n    // Always defined in our unist points that come from micromark.\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(pointStart.offset !== undefined, 'expected `offset`')\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(pointEnd.offset !== undefined, 'expected `offset`')\n    nodeOrToken.start = pointStart.offset\n    nodeOrToken.end = pointEnd.offset\n    nodeOrToken.loc = {\n      start: {\n        line: pointStart.line,\n        column: pointStart.column - 1,\n        offset: pointStart.offset\n      },\n      end: {\n        line: pointEnd.line,\n        column: pointEnd.column - 1,\n        offset: pointEnd.offset\n      }\n    }\n    nodeOrToken.range = [nodeOrToken.start, nodeOrToken.end]\n  }\n\n  /**\n   * Turn an arbitrary offset into the parsed value, into a point in the source\n   * value.\n   *\n   * @param {number} acornOffset\n   * @returns {UnistPoint}\n   */\n  function parseOffsetToUnistPoint(acornOffset) {\n    let sourceOffset = acornOffset - prefix.length\n\n    if (sourceOffset < 0) {\n      sourceOffset = 0\n    } else if (sourceOffset > source.length) {\n      sourceOffset = source.length\n    }\n\n    let point = relativeToPoint(collection.stops, sourceOffset)\n\n    if (!point) {\n      (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n        options.start,\n        'empty expressions are need `options.start` being passed'\n      )\n      point = {\n        line: options.start.line,\n        column: options.start.column,\n        offset: options.start.offset\n      }\n    }\n\n    return point\n  }\n}\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nfunction empty(value) {\n  return /^\\s*$/.test(\n    value\n      // Multiline comments.\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n      // Line comments.\n      // EOF instead of EOL is specifically not allowed, because that would\n      // mean the closing brace is on the commented-out line\n      .replace(/\\/\\/[^\\r\\n]*(\\r\\n|\\n|\\r)/g, '')\n  )\n}\n\n// Port from <https://github.com/wooorm/markdown-rs/blob/e692ab0/src/util/mdx_collect.rs#L15>.\n/**\n * @param {Array<Event>} events\n * @param {Array<TokenType>} tokenTypes\n * @returns {Collection}\n */\nfunction collect(events, tokenTypes) {\n  /** @type {Collection} */\n  const result = {value: '', stops: []}\n  let index = -1\n\n  while (++index < events.length) {\n    const event = events[index]\n\n    // Assume void.\n    if (event[0] === 'enter') {\n      const type = event[1].type\n\n      if (type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding || tokenTypes.includes(type)) {\n        const chunks = event[2].sliceStream(event[1])\n\n        // Drop virtual spaces.\n        while (chunks.length > 0 && chunks[0] === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.virtualSpace) {\n          chunks.shift()\n        }\n\n        const value = serializeChunks(chunks)\n        result.stops.push([result.value.length, event[1].start])\n        result.value += value\n        result.stops.push([result.value.length, event[1].end])\n      }\n    }\n  }\n\n  return result\n}\n\n// Port from <https://github.com/wooorm/markdown-rs/blob/e692ab0/src/util/location.rs#L91>.\n/**\n * Turn a relative offset into an absolute offset.\n *\n * @param {Array<Stop>} stops\n * @param {number} relative\n * @returns {UnistPoint | undefined}\n */\nfunction relativeToPoint(stops, relative) {\n  let index = 0\n\n  while (index < stops.length && stops[index][0] <= relative) {\n    index += 1\n  }\n\n  // There are no points: that only occurs if there was an empty string.\n  if (index === 0) {\n    return undefined\n  }\n\n  const [stopRelative, stopAbsolute] = stops[index - 1]\n  const rest = relative - stopRelative\n  return {\n    line: stopAbsolute.line,\n    column: stopAbsolute.column + rest,\n    offset: stopAbsolute.offset + rest\n  }\n}\n\n// Copy from <https://github.com/micromark/micromark/blob/ce3593a/packages/micromark/dev/lib/create-tokenizer.js#L595>\n// To do: expose that?\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {Array<Chunk>} chunks\n * @returns {string}\n */\nfunction serializeChunks(chunks) {\n  let index = -1\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {boolean | undefined} */\n  let atTab\n\n  while (++index < chunks.length) {\n    const chunk = chunks[index]\n    /** @type {string} */\n    let value\n\n    if (typeof chunk === 'string') {\n      value = chunk\n    } else\n      switch (chunk) {\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.carriageReturn: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.cr\n\n          break\n        }\n\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.lineFeed: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.lf\n\n          break\n        }\n\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.carriageReturnLineFeed: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.cr + micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.lf\n\n          break\n        }\n\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.horizontalTab: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.ht\n\n          break\n        }\n\n        /* c8 ignore next 6 */\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.virtualSpace: {\n          if (atTab) continue\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.space\n\n          break\n        }\n\n        default: {\n          (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(typeof chunk === 'number', 'expected number')\n          // Currently only replacement character.\n          // eslint-disable-next-line unicorn/prefer-code-point\n          value = String.fromCharCode(chunk)\n        }\n      }\n\n    atTab = chunk === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.horizontalTab\n    result.push(value)\n  }\n\n  return result.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vbWljcm9tYXJrLXV0aWwtZXZlbnRzLXRvLWFjb3JuQDIuMC4yL25vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1ldmVudHMtdG8tYWNvcm4vZGV2L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWEsdUJBQXVCO0FBQ3BDLGFBQWEsdUJBQXVCO0FBQ3BDLGFBQWEsMEJBQTBCO0FBQ3ZDLGFBQWEsc0NBQXNDO0FBQ25ELGFBQWEsc0NBQXNDO0FBQ25ELGFBQWEsc0NBQXNDO0FBQ25ELGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsdUJBQXVCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFVBQVU7QUFDeEI7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQyxpREFBaUQ7QUFDakQ7QUFDQSxjQUFjLGlDQUFpQztBQUMvQztBQUNBLGNBQWMsbUNBQW1DO0FBQ2pEO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBLGNB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QUFDQSxrREFBa0Qsd0RBQUs7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGFBQWEsd0RBQUs7QUFDbEIsa0JBQWtCLHlEQUFNOztBQUV4QjtBQUNBOztBQUVBLGFBQWEsd0RBQUs7QUFDbEIsa0JBQWtCLHlEQUFNOztBQUV4QjtBQUNBOztBQUVBLGFBQWEsd0RBQUs7QUFDbEIsa0JBQWtCLHlEQUFNLE1BQU0seURBQU07O0FBRXBDO0FBQ0E7O0FBRUEsYUFBYSx3REFBSztBQUNsQixrQkFBa0IseURBQU07O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHdEQUFLO0FBQ2xCO0FBQ0Esa0JBQWtCLHlEQUFNOztBQUV4QjtBQUNBOztBQUVBO0FBQ0EsVUFBVSwwQ0FBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix3REFBSztBQUMzQjtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYm1fMjAyNC8uL25vZGVfbW9kdWxlcy8ucG5wbS9taWNyb21hcmstdXRpbC1ldmVudHMtdG8tYWNvcm5AMi4wLjIvbm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLWV2ZW50cy10by1hY29ybi9kZXYvaW5kZXguanM/ZTI4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2Fjb3JuJykuQ29tbWVudH0gQ29tbWVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnYWNvcm4nKS5Ob2RlfSBBY29ybk5vZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2Fjb3JuJykuT3B0aW9uc30gQWNvcm5PcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdhY29ybicpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuTm9kZX0gRXN0cmVlTm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuUHJvZ3JhbX0gUHJvZ3JhbVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5DaHVua30gQ2h1bmtcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlBvaW50fSBNaWNyb21hcmtQb2ludFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlblR5cGV9IFRva2VuVHlwZVxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5Qb2ludH0gVW5pc3RQb2ludFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgQWNvcm5cbiAqICAgQWNvcm4tbGlrZSBpbnRlcmZhY2UuXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnYWNvcm4nKS5wYXJzZX0gcGFyc2VcbiAqICAgUGFyc2UgYSBwcm9ncmFtLlxuICogQHByb3BlcnR5IHtpbXBvcnQoJ2Fjb3JuJykucGFyc2VFeHByZXNzaW9uQXR9IHBhcnNlRXhwcmVzc2lvbkF0XG4gKiAgIFBhcnNlIGFuIGV4cHJlc3Npb24uXG4gKlxuICogQHR5cGVkZWYgQWNvcm5Mb2NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29sdW1uXG4gKlxuICogQHR5cGVkZWYgQWNvcm5FcnJvckZpZWxkc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJhaXNlZEF0XG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9zXG4gKiBAcHJvcGVydHkge0Fjb3JuTG9jfSBsb2NcbiAqXG4gKiBAdHlwZWRlZiB7RXJyb3IgJiBBY29ybkVycm9yRmllbGRzfSBBY29ybkVycm9yXG4gKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICogQHByb3BlcnR5IHtBY29ybn0gYWNvcm5cbiAqICAgVHlwaWNhbGx5IGBhY29ybmAsIG9iamVjdCB3aXRoIGBwYXJzZWAgYW5kIGBwYXJzZUV4cHJlc3Npb25BdGAgZmllbGRzIChyZXF1aXJlZCkuXG4gKiBAcHJvcGVydHkge0FycmF5PFRva2VuVHlwZT59IHRva2VuVHlwZXNcbiAqICAgTmFtZXMgb2YgKHZvaWQpIHRva2VucyB0byBjb25zaWRlciBhcyBkYXRhOyBgJ2xpbmVFbmRpbmcnYCBpcyBhbHdheXNcbiAqICAgaW5jbHVkZWQgKHJlcXVpcmVkKS5cbiAqIEBwcm9wZXJ0eSB7QWNvcm5PcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2Fjb3JuT3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbiBmb3IgYGFjb3JuYCAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtNaWNyb21hcmtQb2ludCB8IG51bGwgfCB1bmRlZmluZWR9IFtzdGFydF1cbiAqICAgUGxhY2Ugd2hlcmUgZXZlbnRzIHN0YXJ0IChvcHRpb25hbCwgcmVxdWlyZWQgaWYgYGFsbG93RW1wdHlgKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3ByZWZpeD0nJ11cbiAqICAgVGV4dCB0byBwbGFjZSBiZWZvcmUgZXZlbnRzIChkZWZhdWx0OiBgJydgKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3N1ZmZpeD0nJ11cbiAqICAgVGV4dCB0byBwbGFjZSBhZnRlciBldmVudHMgKGRlZmF1bHQ6IGAnJ2ApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2V4cHJlc3Npb249ZmFsc2VdXG4gKiAgIFdoZXRoZXIgdGhpcyBpcyBhIHByb2dyYW0gb3IgZXhwcmVzc2lvbiAoZGVmYXVsdDogYGZhbHNlYCkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbYWxsb3dFbXB0eT1mYWxzZV1cbiAqICAgV2hldGhlciBhbiBlbXB0eSBleHByZXNzaW9uIGlzIGFsbG93ZWQgKHByb2dyYW1zIGFyZSBhbHdheXMgYWxsb3dlZCB0b1xuICogICBiZSBlbXB0eSkgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICpcbiAqIEB0eXBlZGVmIFJlc3VsdFxuICogICBSZXN1bHQuXG4gKiBAcHJvcGVydHkge1Byb2dyYW0gfCB1bmRlZmluZWR9IGVzdHJlZVxuICogICBQcm9ncmFtLlxuICogQHByb3BlcnR5IHtBY29ybkVycm9yIHwgdW5kZWZpbmVkfSBlcnJvclxuICogICBFcnJvciBpZiB1bnBhcnNlYWJsZVxuICogQHByb3BlcnR5IHtib29sZWFufSBzd2FsbG93XG4gKiAgIFdoZXRoZXIgdGhlIGVycm9yLCBpZiB0aGVyZSBpcyBvbmUsIGNhbiBiZSBzd2FsbG93ZWQgYW5kIG1vcmUgSmF2YVNjcmlwdFxuICogICBjb3VsZCBiZSB2YWxpZC5cbiAqXG4gKiBAdHlwZWRlZiB7W251bWJlciwgTWljcm9tYXJrUG9pbnRdfSBTdG9wXG4gKlxuICogQHR5cGVkZWYgQ29sbGVjdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZhbHVlXG4gKiBAcHJvcGVydHkge0FycmF5PFN0b3A+fSBzdG9wc1xuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge3Zpc2l0fSBmcm9tICdlc3RyZWUtdXRpbC12aXNpdCdcbmltcG9ydCB7Y29kZXMsIHR5cGVzLCB2YWx1ZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbCdcbmltcG9ydCB7VkZpbGVNZXNzYWdlfSBmcm9tICd2ZmlsZS1tZXNzYWdlJ1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBtaWNyb21hcmsgZXZlbnRzIHdpdGggYWNvcm4uXG4gKlxuICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICogICBFdmVudHMuXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiAocmVxdWlyZWQpLlxuICogQHJldHVybnMge1Jlc3VsdH1cbiAqICAgUmVzdWx0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50c1RvQWNvcm4oZXZlbnRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHByZWZpeCA9IG9wdGlvbnMucHJlZml4IHx8ICcnXG4gIGNvbnN0IHN1ZmZpeCA9IG9wdGlvbnMuc3VmZml4IHx8ICcnXG4gIGNvbnN0IGFjb3JuT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuYWNvcm5PcHRpb25zKVxuICAvKiogQHR5cGUge0FycmF5PENvbW1lbnQ+fSAqL1xuICBjb25zdCBjb21tZW50cyA9IFtdXG4gIC8qKiBAdHlwZSB7QXJyYXk8VG9rZW4+fSAqL1xuICBjb25zdCB0b2tlbnMgPSBbXVxuICBjb25zdCBvbkNvbW1lbnQgPSBhY29ybk9wdGlvbnMub25Db21tZW50XG4gIGNvbnN0IG9uVG9rZW4gPSBhY29ybk9wdGlvbnMub25Ub2tlblxuICBsZXQgc3dhbGxvdyA9IGZhbHNlXG4gIC8qKiBAdHlwZSB7QWNvcm5Ob2RlIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgZXN0cmVlXG4gIC8qKiBAdHlwZSB7QWNvcm5FcnJvciB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGV4Y2VwdGlvblxuICAvKiogQHR5cGUge0Fjb3JuT3B0aW9uc30gKi9cbiAgY29uc3QgYWNvcm5Db25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBhY29ybk9wdGlvbnMsIHtcbiAgICBvbkNvbW1lbnQ6IGNvbW1lbnRzLFxuICAgIHByZXNlcnZlUGFyZW5zOiB0cnVlXG4gIH0pXG5cbiAgaWYgKG9uVG9rZW4pIHtcbiAgICBhY29ybkNvbmZpZy5vblRva2VuID0gdG9rZW5zXG4gIH1cblxuICBjb25zdCBjb2xsZWN0aW9uID0gY29sbGVjdChldmVudHMsIG9wdGlvbnMudG9rZW5UeXBlcylcblxuICBjb25zdCBzb3VyY2UgPSBjb2xsZWN0aW9uLnZhbHVlXG5cbiAgY29uc3QgdmFsdWUgPSBwcmVmaXggKyBzb3VyY2UgKyBzdWZmaXhcbiAgY29uc3QgaXNFbXB0eUV4cHJlc3Npb24gPSBvcHRpb25zLmV4cHJlc3Npb24gJiYgZW1wdHkoc291cmNlKVxuXG4gIGlmIChpc0VtcHR5RXhwcmVzc2lvbiAmJiAhb3B0aW9ucy5hbGxvd0VtcHR5KSB7XG4gICAgdGhyb3cgbmV3IFZGaWxlTWVzc2FnZSgnVW5leHBlY3RlZCBlbXB0eSBleHByZXNzaW9uJywge1xuICAgICAgcGxhY2U6IHBhcnNlT2Zmc2V0VG9VbmlzdFBvaW50KDApLFxuICAgICAgcnVsZUlkOiAndW5leHBlY3RlZC1lbXB0eS1leHByZXNzaW9uJyxcbiAgICAgIHNvdXJjZTogJ21pY3JvbWFyay1leHRlbnNpb24tbWR4LWV4cHJlc3Npb24nXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgZXN0cmVlID1cbiAgICAgIG9wdGlvbnMuZXhwcmVzc2lvbiAmJiAhaXNFbXB0eUV4cHJlc3Npb25cbiAgICAgICAgPyBvcHRpb25zLmFjb3JuLnBhcnNlRXhwcmVzc2lvbkF0KHZhbHVlLCAwLCBhY29ybkNvbmZpZylcbiAgICAgICAgOiBvcHRpb25zLmFjb3JuLnBhcnNlKHZhbHVlLCBhY29ybkNvbmZpZylcbiAgfSBjYXRjaCAoZXJyb3JfKSB7XG4gICAgY29uc3QgZXJyb3IgPSAvKiogQHR5cGUge0Fjb3JuRXJyb3J9ICovIChlcnJvcl8pXG4gICAgY29uc3QgcG9pbnQgPSBwYXJzZU9mZnNldFRvVW5pc3RQb2ludChlcnJvci5wb3MpXG4gICAgZXJyb3IubWVzc2FnZSA9IFN0cmluZyhlcnJvci5tZXNzYWdlKS5yZXBsYWNlKC8gXFwoXFxkKzpcXGQrXFwpJC8sICcnKVxuICAgIC8vIEFsd2F5cyBkZWZpbmVkIGluIG91ciB1bmlzdCBwb2ludHMgdGhhdCBjb21lIGZyb20gbWljcm9tYXJrLlxuICAgIGFzc2VydChwb2ludC5vZmZzZXQgIT09IHVuZGVmaW5lZCwgJ2V4cGVjdGVkIGBvZmZzZXRgJylcbiAgICBlcnJvci5wb3MgPSBwb2ludC5vZmZzZXRcbiAgICBlcnJvci5sb2MgPSB7bGluZTogcG9pbnQubGluZSwgY29sdW1uOiBwb2ludC5jb2x1bW4gLSAxfVxuICAgIGV4Y2VwdGlvbiA9IGVycm9yXG4gICAgc3dhbGxvdyA9XG4gICAgICBlcnJvci5yYWlzZWRBdCA+PSBwcmVmaXgubGVuZ3RoICsgc291cmNlLmxlbmd0aCB8fFxuICAgICAgLy8gQnJva2VuIGNvbW1lbnRzIGFyZSByYWlzZWQgYXQgdGhlaXIgc3RhcnQsIG5vdCB0aGVpciBlbmQuXG4gICAgICBlcnJvci5tZXNzYWdlID09PSAnVW50ZXJtaW5hdGVkIGNvbW1lbnQnXG4gIH1cblxuICBpZiAoZXN0cmVlICYmIG9wdGlvbnMuZXhwcmVzc2lvbiAmJiAhaXNFbXB0eUV4cHJlc3Npb24pIHtcbiAgICBpZiAoZW1wdHkodmFsdWUuc2xpY2UoZXN0cmVlLmVuZCwgdmFsdWUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkpKSB7XG4gICAgICBlc3RyZWUgPSB7XG4gICAgICAgIHR5cGU6ICdQcm9ncmFtJyxcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGVuZDogcHJlZml4Lmxlbmd0aCArIHNvdXJjZS5sZW5ndGgsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEl04oCZcyBnb29kLlxuICAgICAgICBib2R5OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXN0cmVlLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IHByZWZpeC5sZW5ndGggKyBzb3VyY2UubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzb3VyY2VUeXBlOiAnbW9kdWxlJyxcbiAgICAgICAgY29tbWVudHM6IFtdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcGFyc2VPZmZzZXRUb1VuaXN0UG9pbnQoZXN0cmVlLmVuZClcbiAgICAgIGNvbnN0IGVycm9yID0gLyoqIEB0eXBlIHtBY29ybkVycm9yfSAqLyAoXG4gICAgICAgIG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZW50IGFmdGVyIGV4cHJlc3Npb24nKVxuICAgICAgKVxuICAgICAgLy8gQWx3YXlzIGRlZmluZWQgaW4gb3VyIHVuaXN0IHBvaW50cyB0aGF0IGNvbWUgZnJvbSBtaWNyb21hcmsuXG4gICAgICBhc3NlcnQocG9pbnQub2Zmc2V0ICE9PSB1bmRlZmluZWQsICdleHBlY3RlZCBgb2Zmc2V0YCcpXG4gICAgICBlcnJvci5wb3MgPSBwb2ludC5vZmZzZXRcbiAgICAgIGVycm9yLmxvYyA9IHtsaW5lOiBwb2ludC5saW5lLCBjb2x1bW46IHBvaW50LmNvbHVtbiAtIDF9XG4gICAgICBleGNlcHRpb24gPSBlcnJvclxuICAgICAgZXN0cmVlID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgaWYgKGVzdHJlZSkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGFjb3JuICpkb2VzKiBhbGxvdyBjb21tZW50c1xuICAgIGVzdHJlZS5jb21tZW50cyA9IGNvbW1lbnRzXG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhY29ybiBsb29rcyBlbm91Z2ggbGlrZSBlc3RyZWUuXG4gICAgdmlzaXQoZXN0cmVlLCBmdW5jdGlvbiAoZXNub2RlLCBmaWVsZCwgaW5kZXgsIHBhcmVudHMpIHtcbiAgICAgIGxldCBjb250ZXh0ID0gLyoqIEB0eXBlIHtBY29ybk5vZGUgfCBBcnJheTxBY29ybk5vZGU+fSAqLyAoXG4gICAgICAgIHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXVxuICAgICAgKVxuICAgICAgLyoqIEB0eXBlIHtudW1iZXIgfCBzdHJpbmcgfCB1bmRlZmluZWR9ICovXG4gICAgICBsZXQgcHJvcCA9IGZpZWxkXG5cbiAgICAgIC8vIFJlbW92ZSBub24tc3RhbmRhcmQgYFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uYC5cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGluY2x1ZGVkIGluIGFjb3JuLlxuICAgICAgaWYgKGVzbm9kZS50eXBlID09PSAnUGFyZW50aGVzaXplZEV4cHJlc3Npb24nICYmIGNvbnRleHQgJiYgcHJvcCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCA1ICovXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW5kZXhhYmxlLlxuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0W3Byb3BdXG4gICAgICAgICAgcHJvcCA9IGluZGV4XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbmRleGFibGUuXG4gICAgICAgIGNvbnRleHRbcHJvcF0gPSBlc25vZGUuZXhwcmVzc2lvblxuICAgICAgfVxuXG4gICAgICBmaXhQb3NpdGlvbihlc25vZGUpXG4gICAgfSlcblxuICAgIC8vIENvbW1lbnQgcG9zaXRpb25zIGFyZSBmaXhlZCBieSBgdmlzaXRgIGJlY2F1c2UgdGhleeKAmXJlIGluIHRoZSB0cmVlLlxuICAgIGlmIChBcnJheS5pc0FycmF5KG9uQ29tbWVudCkpIHtcbiAgICAgIG9uQ29tbWVudC5wdXNoKC4uLmNvbW1lbnRzKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9uQ29tbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm9yIChjb25zdCBjb21tZW50IG9mIGNvbW1lbnRzKSB7XG4gICAgICAgIGFzc2VydChjb21tZW50LmxvYywgJ2V4cGVjdGVkIGBsb2NgIG9uIGNvbW1lbnQnKVxuICAgICAgICBvbkNvbW1lbnQoXG4gICAgICAgICAgY29tbWVudC50eXBlID09PSAnQmxvY2snLFxuICAgICAgICAgIGNvbW1lbnQudmFsdWUsXG4gICAgICAgICAgY29tbWVudC5zdGFydCxcbiAgICAgICAgICBjb21tZW50LmVuZCxcbiAgICAgICAgICBjb21tZW50LmxvYy5zdGFydCxcbiAgICAgICAgICBjb21tZW50LmxvYy5lbmRcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAvLyBJZ25vcmUgdG9rZW5zIHRoYXQgZW5kcyBpbiBwcmVmaXggb3Igc3RhcnQgaW4gc3VmZml4OlxuICAgICAgaWYgKFxuICAgICAgICB0b2tlbi5lbmQgPD0gcHJlZml4Lmxlbmd0aCB8fFxuICAgICAgICB0b2tlbi5zdGFydCAtIHByZWZpeC5sZW5ndGggPj0gc291cmNlLmxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGZpeFBvc2l0aW9uKHRva2VuKVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvblRva2VuKSkge1xuICAgICAgICBvblRva2VuLnB1c2godG9rZW4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBgdG9rZW5zYCBhcmUgbm90IGFkZGVkIGlmIGBvblRva2VuYCBpcyBub3QgZGVmaW5lZCwgc28gaXQgbXVzdCBiZSBhXG4gICAgICAgIC8vIGZ1bmN0aW9uLlxuICAgICAgICBhc3NlcnQodHlwZW9mIG9uVG9rZW4gPT09ICdmdW5jdGlvbicsICdleHBlY3RlZCBmdW5jdGlvbicpXG4gICAgICAgIG9uVG9rZW4odG9rZW4pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogSXTigJlzIGEgcHJvZ3JhbSBub3cuXG4gIHJldHVybiB7ZXN0cmVlLCBlcnJvcjogZXhjZXB0aW9uLCBzd2FsbG93fVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtBY29ybk5vZGUgfCBFc3RyZWVOb2RlIHwgVG9rZW59IG5vZGVPclRva2VuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBmdW5jdGlvbiBmaXhQb3NpdGlvbihub2RlT3JUb2tlbikge1xuICAgIGFzc2VydChcbiAgICAgICdzdGFydCcgaW4gbm9kZU9yVG9rZW4sXG4gICAgICAnZXhwZWN0ZWQgYHN0YXJ0YCBpbiBub2RlIG9yIHRva2VuIGZyb20gYWNvcm4nXG4gICAgKVxuICAgIGFzc2VydCgnZW5kJyBpbiBub2RlT3JUb2tlbiwgJ2V4cGVjdGVkIGBlbmRgIGluIG5vZGUgb3IgdG9rZW4gZnJvbSBhY29ybicpXG4gICAgY29uc3QgcG9pbnRTdGFydCA9IHBhcnNlT2Zmc2V0VG9VbmlzdFBvaW50KG5vZGVPclRva2VuLnN0YXJ0KVxuICAgIGNvbnN0IHBvaW50RW5kID0gcGFyc2VPZmZzZXRUb1VuaXN0UG9pbnQobm9kZU9yVG9rZW4uZW5kKVxuICAgIC8vIEFsd2F5cyBkZWZpbmVkIGluIG91ciB1bmlzdCBwb2ludHMgdGhhdCBjb21lIGZyb20gbWljcm9tYXJrLlxuICAgIGFzc2VydChwb2ludFN0YXJ0Lm9mZnNldCAhPT0gdW5kZWZpbmVkLCAnZXhwZWN0ZWQgYG9mZnNldGAnKVxuICAgIGFzc2VydChwb2ludEVuZC5vZmZzZXQgIT09IHVuZGVmaW5lZCwgJ2V4cGVjdGVkIGBvZmZzZXRgJylcbiAgICBub2RlT3JUb2tlbi5zdGFydCA9IHBvaW50U3RhcnQub2Zmc2V0XG4gICAgbm9kZU9yVG9rZW4uZW5kID0gcG9pbnRFbmQub2Zmc2V0XG4gICAgbm9kZU9yVG9rZW4ubG9jID0ge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgbGluZTogcG9pbnRTdGFydC5saW5lLFxuICAgICAgICBjb2x1bW46IHBvaW50U3RhcnQuY29sdW1uIC0gMSxcbiAgICAgICAgb2Zmc2V0OiBwb2ludFN0YXJ0Lm9mZnNldFxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBsaW5lOiBwb2ludEVuZC5saW5lLFxuICAgICAgICBjb2x1bW46IHBvaW50RW5kLmNvbHVtbiAtIDEsXG4gICAgICAgIG9mZnNldDogcG9pbnRFbmQub2Zmc2V0XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGVPclRva2VuLnJhbmdlID0gW25vZGVPclRva2VuLnN0YXJ0LCBub2RlT3JUb2tlbi5lbmRdXG4gIH1cblxuICAvKipcbiAgICogVHVybiBhbiBhcmJpdHJhcnkgb2Zmc2V0IGludG8gdGhlIHBhcnNlZCB2YWx1ZSwgaW50byBhIHBvaW50IGluIHRoZSBzb3VyY2VcbiAgICogdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhY29ybk9mZnNldFxuICAgKiBAcmV0dXJucyB7VW5pc3RQb2ludH1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlT2Zmc2V0VG9VbmlzdFBvaW50KGFjb3JuT2Zmc2V0KSB7XG4gICAgbGV0IHNvdXJjZU9mZnNldCA9IGFjb3JuT2Zmc2V0IC0gcHJlZml4Lmxlbmd0aFxuXG4gICAgaWYgKHNvdXJjZU9mZnNldCA8IDApIHtcbiAgICAgIHNvdXJjZU9mZnNldCA9IDBcbiAgICB9IGVsc2UgaWYgKHNvdXJjZU9mZnNldCA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHNvdXJjZU9mZnNldCA9IHNvdXJjZS5sZW5ndGhcbiAgICB9XG5cbiAgICBsZXQgcG9pbnQgPSByZWxhdGl2ZVRvUG9pbnQoY29sbGVjdGlvbi5zdG9wcywgc291cmNlT2Zmc2V0KVxuXG4gICAgaWYgKCFwb2ludCkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBvcHRpb25zLnN0YXJ0LFxuICAgICAgICAnZW1wdHkgZXhwcmVzc2lvbnMgYXJlIG5lZWQgYG9wdGlvbnMuc3RhcnRgIGJlaW5nIHBhc3NlZCdcbiAgICAgIClcbiAgICAgIHBvaW50ID0ge1xuICAgICAgICBsaW5lOiBvcHRpb25zLnN0YXJ0LmxpbmUsXG4gICAgICAgIGNvbHVtbjogb3B0aW9ucy5zdGFydC5jb2x1bW4sXG4gICAgICAgIG9mZnNldDogb3B0aW9ucy5zdGFydC5vZmZzZXRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGVtcHR5KHZhbHVlKSB7XG4gIHJldHVybiAvXlxccyokLy50ZXN0KFxuICAgIHZhbHVlXG4gICAgICAvLyBNdWx0aWxpbmUgY29tbWVudHMuXG4gICAgICAucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy9nLCAnJylcbiAgICAgIC8vIExpbmUgY29tbWVudHMuXG4gICAgICAvLyBFT0YgaW5zdGVhZCBvZiBFT0wgaXMgc3BlY2lmaWNhbGx5IG5vdCBhbGxvd2VkLCBiZWNhdXNlIHRoYXQgd291bGRcbiAgICAgIC8vIG1lYW4gdGhlIGNsb3NpbmcgYnJhY2UgaXMgb24gdGhlIGNvbW1lbnRlZC1vdXQgbGluZVxuICAgICAgLnJlcGxhY2UoL1xcL1xcL1teXFxyXFxuXSooXFxyXFxufFxcbnxcXHIpL2csICcnKVxuICApXG59XG5cbi8vIFBvcnQgZnJvbSA8aHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9tYXJrZG93bi1ycy9ibG9iL2U2OTJhYjAvc3JjL3V0aWwvbWR4X2NvbGxlY3QucnMjTDE1Pi5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICogQHBhcmFtIHtBcnJheTxUb2tlblR5cGU+fSB0b2tlblR5cGVzXG4gKiBAcmV0dXJucyB7Q29sbGVjdGlvbn1cbiAqL1xuZnVuY3Rpb24gY29sbGVjdChldmVudHMsIHRva2VuVHlwZXMpIHtcbiAgLyoqIEB0eXBlIHtDb2xsZWN0aW9ufSAqL1xuICBjb25zdCByZXN1bHQgPSB7dmFsdWU6ICcnLCBzdG9wczogW119XG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgY29uc3QgZXZlbnQgPSBldmVudHNbaW5kZXhdXG5cbiAgICAvLyBBc3N1bWUgdm9pZC5cbiAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBldmVudFsxXS50eXBlXG5cbiAgICAgIGlmICh0eXBlID09PSB0eXBlcy5saW5lRW5kaW5nIHx8IHRva2VuVHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gZXZlbnRbMl0uc2xpY2VTdHJlYW0oZXZlbnRbMV0pXG5cbiAgICAgICAgLy8gRHJvcCB2aXJ0dWFsIHNwYWNlcy5cbiAgICAgICAgd2hpbGUgKGNodW5rcy5sZW5ndGggPiAwICYmIGNodW5rc1swXSA9PT0gY29kZXMudmlydHVhbFNwYWNlKSB7XG4gICAgICAgICAgY2h1bmtzLnNoaWZ0KClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2VyaWFsaXplQ2h1bmtzKGNodW5rcylcbiAgICAgICAgcmVzdWx0LnN0b3BzLnB1c2goW3Jlc3VsdC52YWx1ZS5sZW5ndGgsIGV2ZW50WzFdLnN0YXJ0XSlcbiAgICAgICAgcmVzdWx0LnZhbHVlICs9IHZhbHVlXG4gICAgICAgIHJlc3VsdC5zdG9wcy5wdXNoKFtyZXN1bHQudmFsdWUubGVuZ3RoLCBldmVudFsxXS5lbmRdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gUG9ydCBmcm9tIDxodHRwczovL2dpdGh1Yi5jb20vd29vb3JtL21hcmtkb3duLXJzL2Jsb2IvZTY5MmFiMC9zcmMvdXRpbC9sb2NhdGlvbi5ycyNMOTE+LlxuLyoqXG4gKiBUdXJuIGEgcmVsYXRpdmUgb2Zmc2V0IGludG8gYW4gYWJzb2x1dGUgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8U3RvcD59IHN0b3BzXG4gKiBAcGFyYW0ge251bWJlcn0gcmVsYXRpdmVcbiAqIEByZXR1cm5zIHtVbmlzdFBvaW50IHwgdW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiByZWxhdGl2ZVRvUG9pbnQoc3RvcHMsIHJlbGF0aXZlKSB7XG4gIGxldCBpbmRleCA9IDBcblxuICB3aGlsZSAoaW5kZXggPCBzdG9wcy5sZW5ndGggJiYgc3RvcHNbaW5kZXhdWzBdIDw9IHJlbGF0aXZlKSB7XG4gICAgaW5kZXggKz0gMVxuICB9XG5cbiAgLy8gVGhlcmUgYXJlIG5vIHBvaW50czogdGhhdCBvbmx5IG9jY3VycyBpZiB0aGVyZSB3YXMgYW4gZW1wdHkgc3RyaW5nLlxuICBpZiAoaW5kZXggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBbc3RvcFJlbGF0aXZlLCBzdG9wQWJzb2x1dGVdID0gc3RvcHNbaW5kZXggLSAxXVxuICBjb25zdCByZXN0ID0gcmVsYXRpdmUgLSBzdG9wUmVsYXRpdmVcbiAgcmV0dXJuIHtcbiAgICBsaW5lOiBzdG9wQWJzb2x1dGUubGluZSxcbiAgICBjb2x1bW46IHN0b3BBYnNvbHV0ZS5jb2x1bW4gKyByZXN0LFxuICAgIG9mZnNldDogc3RvcEFic29sdXRlLm9mZnNldCArIHJlc3RcbiAgfVxufVxuXG4vLyBDb3B5IGZyb20gPGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb21hcmsvbWljcm9tYXJrL2Jsb2IvY2UzNTkzYS9wYWNrYWdlcy9taWNyb21hcmsvZGV2L2xpYi9jcmVhdGUtdG9rZW5pemVyLmpzI0w1OTU+XG4vLyBUbyBkbzogZXhwb3NlIHRoYXQ/XG4vKipcbiAqIEdldCB0aGUgc3RyaW5nIHZhbHVlIG9mIGEgc2xpY2Ugb2YgY2h1bmtzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Q2h1bms+fSBjaHVua3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUNodW5rcyhjaHVua3MpIHtcbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuICAvKiogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBhdFRhYlxuXG4gIHdoaWxlICgrK2luZGV4IDwgY2h1bmtzLmxlbmd0aCkge1xuICAgIGNvbnN0IGNodW5rID0gY2h1bmtzW2luZGV4XVxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIGxldCB2YWx1ZVxuXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gY2h1bmtcbiAgICB9IGVsc2VcbiAgICAgIHN3aXRjaCAoY2h1bmspIHtcbiAgICAgICAgY2FzZSBjb2Rlcy5jYXJyaWFnZVJldHVybjoge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmNyXG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBjb2Rlcy5saW5lRmVlZDoge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmxmXG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBjb2Rlcy5jYXJyaWFnZVJldHVybkxpbmVGZWVkOiB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuY3IgKyB2YWx1ZXMubGZcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIGNvZGVzLmhvcml6b250YWxUYWI6IHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5odFxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDYgKi9cbiAgICAgICAgY2FzZSBjb2Rlcy52aXJ0dWFsU3BhY2U6IHtcbiAgICAgICAgICBpZiAoYXRUYWIpIGNvbnRpbnVlXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuc3BhY2VcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgYXNzZXJ0KHR5cGVvZiBjaHVuayA9PT0gJ251bWJlcicsICdleHBlY3RlZCBudW1iZXInKVxuICAgICAgICAgIC8vIEN1cnJlbnRseSBvbmx5IHJlcGxhY2VtZW50IGNoYXJhY3Rlci5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItY29kZS1wb2ludFxuICAgICAgICAgIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHVuaylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgYXRUYWIgPSBjaHVuayA9PT0gY29kZXMuaG9yaXpvbnRhbFRhYlxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/micromark-util-events-to-acorn@2.0.2/node_modules/micromark-util-events-to-acorn/dev/index.js\n");

/***/ })

};
;