"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/astring@1.8.6";
exports.ids = ["vendor-chunks/astring@1.8.6"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/astring@1.8.6/node_modules/astring/dist/astring.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/astring@1.8.6/node_modules/astring/dist/astring.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXPRESSIONS_PRECEDENCE: () => (/* binding */ EXPRESSIONS_PRECEDENCE),\n/* harmony export */   GENERATOR: () => (/* binding */ GENERATOR),\n/* harmony export */   NEEDS_PARENTHESES: () => (/* binding */ NEEDS_PARENTHESES),\n/* harmony export */   baseGenerator: () => (/* binding */ baseGenerator),\n/* harmony export */   generate: () => (/* binding */ generate)\n/* harmony export */ });\n// Astring is a tiny and fast JavaScript code generator from an ESTree-compliant AST.\n//\n// Astring was written by David Bonnet and released under an MIT license.\n//\n// The Git repository for Astring is available at:\n// https://github.com/davidbonnet/astring.git\n//\n// Please use the GitHub bug tracker to report issues:\n// https://github.com/davidbonnet/astring/issues\n\nconst { stringify } = JSON\n\n/* c8 ignore if */\nif (!String.prototype.repeat) {\n  /* c8 ignore next */\n  throw new Error(\n    'String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation',\n  )\n}\n\n/* c8 ignore if */\nif (!String.prototype.endsWith) {\n  /* c8 ignore next */\n  throw new Error(\n    'String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation',\n  )\n}\n\nconst OPERATOR_PRECEDENCE = {\n  '||': 2,\n  '??': 3,\n  '&&': 4,\n  '|': 5,\n  '^': 6,\n  '&': 7,\n  '==': 8,\n  '!=': 8,\n  '===': 8,\n  '!==': 8,\n  '<': 9,\n  '>': 9,\n  '<=': 9,\n  '>=': 9,\n  in: 9,\n  instanceof: 9,\n  '<<': 10,\n  '>>': 10,\n  '>>>': 10,\n  '+': 11,\n  '-': 11,\n  '*': 12,\n  '%': 12,\n  '/': 12,\n  '**': 13,\n}\n\n// Enables parenthesis regardless of precedence\nconst NEEDS_PARENTHESES = 17\n\nconst EXPRESSIONS_PRECEDENCE = {\n  // Definitions\n  ArrayExpression: 20,\n  TaggedTemplateExpression: 20,\n  ThisExpression: 20,\n  Identifier: 20,\n  PrivateIdentifier: 20,\n  Literal: 18,\n  TemplateLiteral: 20,\n  Super: 20,\n  SequenceExpression: 20,\n  // Operations\n  MemberExpression: 19,\n  ChainExpression: 19,\n  CallExpression: 19,\n  NewExpression: 19,\n  // Other definitions\n  ArrowFunctionExpression: NEEDS_PARENTHESES,\n  ClassExpression: NEEDS_PARENTHESES,\n  FunctionExpression: NEEDS_PARENTHESES,\n  ObjectExpression: NEEDS_PARENTHESES,\n  // Other operations\n  UpdateExpression: 16,\n  UnaryExpression: 15,\n  AwaitExpression: 15,\n  BinaryExpression: 14,\n  LogicalExpression: 13,\n  ConditionalExpression: 4,\n  AssignmentExpression: 3,\n  YieldExpression: 2,\n  RestElement: 1,\n}\n\nfunction formatSequence(state, nodes) {\n  /*\n  Writes into `state` a sequence of `nodes`.\n  */\n  const { generator } = state\n  state.write('(')\n  if (nodes != null && nodes.length > 0) {\n    generator[nodes[0].type](nodes[0], state)\n    const { length } = nodes\n    for (let i = 1; i < length; i++) {\n      const param = nodes[i]\n      state.write(', ')\n      generator[param.type](param, state)\n    }\n  }\n  state.write(')')\n}\n\nfunction expressionNeedsParenthesis(state, node, parentNode, isRightHand) {\n  const nodePrecedence = state.expressionsPrecedence[node.type]\n  if (nodePrecedence === NEEDS_PARENTHESES) {\n    return true\n  }\n  const parentNodePrecedence = state.expressionsPrecedence[parentNode.type]\n  if (nodePrecedence !== parentNodePrecedence) {\n    // Different node types\n    return (\n      (!isRightHand &&\n        nodePrecedence === 15 &&\n        parentNodePrecedence === 14 &&\n        parentNode.operator === '**') ||\n      nodePrecedence < parentNodePrecedence\n    )\n  }\n  if (nodePrecedence !== 13 && nodePrecedence !== 14) {\n    // Not a `LogicalExpression` or `BinaryExpression`\n    return false\n  }\n  if (node.operator === '**' && parentNode.operator === '**') {\n    // Exponentiation operator has right-to-left associativity\n    return !isRightHand\n  }\n  if (\n    nodePrecedence === 13 &&\n    parentNodePrecedence === 13 &&\n    (node.operator === '??' || parentNode.operator === '??')\n  ) {\n    // Nullish coalescing and boolean operators cannot be combined\n    return true\n  }\n  if (isRightHand) {\n    // Parenthesis are used if both operators have the same precedence\n    return (\n      OPERATOR_PRECEDENCE[node.operator] <=\n      OPERATOR_PRECEDENCE[parentNode.operator]\n    )\n  }\n  return (\n    OPERATOR_PRECEDENCE[node.operator] <\n    OPERATOR_PRECEDENCE[parentNode.operator]\n  )\n}\n\nfunction formatExpression(state, node, parentNode, isRightHand) {\n  /*\n  Writes into `state` the provided `node`, adding parenthesis around if the provided `parentNode` needs it. If `node` is a right-hand argument, the provided `isRightHand` parameter should be `true`.\n  */\n  const { generator } = state\n  if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {\n    state.write('(')\n    generator[node.type](node, state)\n    state.write(')')\n  } else {\n    generator[node.type](node, state)\n  }\n}\n\nfunction reindent(state, text, indent, lineEnd) {\n  /*\n  Writes into `state` the `text` string reindented with the provided `indent`.\n  */\n  const lines = text.split('\\n')\n  const end = lines.length - 1\n  state.write(lines[0].trim())\n  if (end > 0) {\n    state.write(lineEnd)\n    for (let i = 1; i < end; i++) {\n      state.write(indent + lines[i].trim() + lineEnd)\n    }\n    state.write(indent + lines[end].trim())\n  }\n}\n\nfunction formatComments(state, comments, indent, lineEnd) {\n  /*\n  Writes into `state` the provided list of `comments`, with the given `indent` and `lineEnd` strings.\n  Line comments will end with `\"\\n\"` regardless of the value of `lineEnd`.\n  Expects to start on a new unindented line.\n  */\n  const { length } = comments\n  for (let i = 0; i < length; i++) {\n    const comment = comments[i]\n    state.write(indent)\n    if (comment.type[0] === 'L') {\n      // Line comment\n      state.write('// ' + comment.value.trim() + '\\n', comment)\n    } else {\n      // Block comment\n      state.write('/*')\n      reindent(state, comment.value, indent, lineEnd)\n      state.write('*/' + lineEnd)\n    }\n  }\n}\n\nfunction hasCallExpression(node) {\n  /*\n  Returns `true` if the provided `node` contains a call expression and `false` otherwise.\n  */\n  let currentNode = node\n  while (currentNode != null) {\n    const { type } = currentNode\n    if (type[0] === 'C' && type[1] === 'a') {\n      // Is CallExpression\n      return true\n    } else if (type[0] === 'M' && type[1] === 'e' && type[2] === 'm') {\n      // Is MemberExpression\n      currentNode = currentNode.object\n    } else {\n      return false\n    }\n  }\n}\n\nfunction formatVariableDeclaration(state, node) {\n  /*\n  Writes into `state` a variable declaration.\n  */\n  const { generator } = state\n  const { declarations } = node\n  state.write(node.kind + ' ')\n  const { length } = declarations\n  if (length > 0) {\n    generator.VariableDeclarator(declarations[0], state)\n    for (let i = 1; i < length; i++) {\n      state.write(', ')\n      generator.VariableDeclarator(declarations[i], state)\n    }\n  }\n}\n\nlet ForInStatement,\n  FunctionDeclaration,\n  RestElement,\n  BinaryExpression,\n  ArrayExpression,\n  BlockStatement\n\nconst GENERATOR = {\n  /*\n  Default generator.\n  */\n  Program(node, state) {\n    const indent = state.indent.repeat(state.indentLevel)\n    const { lineEnd, writeComments } = state\n    if (writeComments && node.comments != null) {\n      formatComments(state, node.comments, indent, lineEnd)\n    }\n    const statements = node.body\n    const { length } = statements\n    for (let i = 0; i < length; i++) {\n      const statement = statements[i]\n      if (writeComments && statement.comments != null) {\n        formatComments(state, statement.comments, indent, lineEnd)\n      }\n      state.write(indent)\n      this[statement.type](statement, state)\n      state.write(lineEnd)\n    }\n    if (writeComments && node.trailingComments != null) {\n      formatComments(state, node.trailingComments, indent, lineEnd)\n    }\n  },\n  BlockStatement: (BlockStatement = function (node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    const statementIndent = indent + state.indent\n    state.write('{')\n    const statements = node.body\n    if (statements != null && statements.length > 0) {\n      state.write(lineEnd)\n      if (writeComments && node.comments != null) {\n        formatComments(state, node.comments, statementIndent, lineEnd)\n      }\n      const { length } = statements\n      for (let i = 0; i < length; i++) {\n        const statement = statements[i]\n        if (writeComments && statement.comments != null) {\n          formatComments(state, statement.comments, statementIndent, lineEnd)\n        }\n        state.write(statementIndent)\n        this[statement.type](statement, state)\n        state.write(lineEnd)\n      }\n      state.write(indent)\n    } else {\n      if (writeComments && node.comments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.comments, statementIndent, lineEnd)\n        state.write(indent)\n      }\n    }\n    if (writeComments && node.trailingComments != null) {\n      formatComments(state, node.trailingComments, statementIndent, lineEnd)\n    }\n    state.write('}')\n    state.indentLevel--\n  }),\n  ClassBody: BlockStatement,\n  StaticBlock(node, state) {\n    state.write('static ')\n    this.BlockStatement(node, state)\n  },\n  EmptyStatement(node, state) {\n    state.write(';')\n  },\n  ExpressionStatement(node, state) {\n    const precedence = state.expressionsPrecedence[node.expression.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      (precedence === 3 && node.expression.left.type[0] === 'O')\n    ) {\n      // Should always have parentheses or is an AssignmentExpression to an ObjectPattern\n      state.write('(')\n      this[node.expression.type](node.expression, state)\n      state.write(')')\n    } else {\n      this[node.expression.type](node.expression, state)\n    }\n    state.write(';')\n  },\n  IfStatement(node, state) {\n    state.write('if (')\n    this[node.test.type](node.test, state)\n    state.write(') ')\n    this[node.consequent.type](node.consequent, state)\n    if (node.alternate != null) {\n      state.write(' else ')\n      this[node.alternate.type](node.alternate, state)\n    }\n  },\n  LabeledStatement(node, state) {\n    this[node.label.type](node.label, state)\n    state.write(': ')\n    this[node.body.type](node.body, state)\n  },\n  BreakStatement(node, state) {\n    state.write('break')\n    if (node.label != null) {\n      state.write(' ')\n      this[node.label.type](node.label, state)\n    }\n    state.write(';')\n  },\n  ContinueStatement(node, state) {\n    state.write('continue')\n    if (node.label != null) {\n      state.write(' ')\n      this[node.label.type](node.label, state)\n    }\n    state.write(';')\n  },\n  WithStatement(node, state) {\n    state.write('with (')\n    this[node.object.type](node.object, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  SwitchStatement(node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    state.indentLevel++\n    const caseIndent = indent + state.indent\n    const statementIndent = caseIndent + state.indent\n    state.write('switch (')\n    this[node.discriminant.type](node.discriminant, state)\n    state.write(') {' + lineEnd)\n    const { cases: occurences } = node\n    const { length: occurencesCount } = occurences\n    for (let i = 0; i < occurencesCount; i++) {\n      const occurence = occurences[i]\n      if (writeComments && occurence.comments != null) {\n        formatComments(state, occurence.comments, caseIndent, lineEnd)\n      }\n      if (occurence.test) {\n        state.write(caseIndent + 'case ')\n        this[occurence.test.type](occurence.test, state)\n        state.write(':' + lineEnd)\n      } else {\n        state.write(caseIndent + 'default:' + lineEnd)\n      }\n      const { consequent } = occurence\n      const { length: consequentCount } = consequent\n      for (let i = 0; i < consequentCount; i++) {\n        const statement = consequent[i]\n        if (writeComments && statement.comments != null) {\n          formatComments(state, statement.comments, statementIndent, lineEnd)\n        }\n        state.write(statementIndent)\n        this[statement.type](statement, state)\n        state.write(lineEnd)\n      }\n    }\n    state.indentLevel -= 2\n    state.write(indent + '}')\n  },\n  ReturnStatement(node, state) {\n    state.write('return')\n    if (node.argument) {\n      state.write(' ')\n      this[node.argument.type](node.argument, state)\n    }\n    state.write(';')\n  },\n  ThrowStatement(node, state) {\n    state.write('throw ')\n    this[node.argument.type](node.argument, state)\n    state.write(';')\n  },\n  TryStatement(node, state) {\n    state.write('try ')\n    this[node.block.type](node.block, state)\n    if (node.handler) {\n      const { handler } = node\n      if (handler.param == null) {\n        state.write(' catch ')\n      } else {\n        state.write(' catch (')\n        this[handler.param.type](handler.param, state)\n        state.write(') ')\n      }\n      this[handler.body.type](handler.body, state)\n    }\n    if (node.finalizer) {\n      state.write(' finally ')\n      this[node.finalizer.type](node.finalizer, state)\n    }\n  },\n  WhileStatement(node, state) {\n    state.write('while (')\n    this[node.test.type](node.test, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  DoWhileStatement(node, state) {\n    state.write('do ')\n    this[node.body.type](node.body, state)\n    state.write(' while (')\n    this[node.test.type](node.test, state)\n    state.write(');')\n  },\n  ForStatement(node, state) {\n    state.write('for (')\n    if (node.init != null) {\n      const { init } = node\n      if (init.type[0] === 'V') {\n        formatVariableDeclaration(state, init)\n      } else {\n        this[init.type](init, state)\n      }\n    }\n    state.write('; ')\n    if (node.test) {\n      this[node.test.type](node.test, state)\n    }\n    state.write('; ')\n    if (node.update) {\n      this[node.update.type](node.update, state)\n    }\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  ForInStatement: (ForInStatement = function (node, state) {\n    state.write(`for ${node.await ? 'await ' : ''}(`)\n    const { left } = node\n    if (left.type[0] === 'V') {\n      formatVariableDeclaration(state, left)\n    } else {\n      this[left.type](left, state)\n    }\n    // Identifying whether node.type is `ForInStatement` or `ForOfStatement`\n    state.write(node.type[3] === 'I' ? ' in ' : ' of ')\n    this[node.right.type](node.right, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  }),\n  ForOfStatement: ForInStatement,\n  DebuggerStatement(node, state) {\n    state.write('debugger;', node)\n  },\n  FunctionDeclaration: (FunctionDeclaration = function (node, state) {\n    state.write(\n      (node.async ? 'async ' : '') +\n        (node.generator ? 'function* ' : 'function ') +\n        (node.id ? node.id.name : ''),\n      node,\n    )\n    formatSequence(state, node.params)\n    state.write(' ')\n    this[node.body.type](node.body, state)\n  }),\n  FunctionExpression: FunctionDeclaration,\n  VariableDeclaration(node, state) {\n    formatVariableDeclaration(state, node)\n    state.write(';')\n  },\n  VariableDeclarator(node, state) {\n    this[node.id.type](node.id, state)\n    if (node.init != null) {\n      state.write(' = ')\n      this[node.init.type](node.init, state)\n    }\n  },\n  ClassDeclaration(node, state) {\n    state.write('class ' + (node.id ? `${node.id.name} ` : ''), node)\n    if (node.superClass) {\n      state.write('extends ')\n      const { superClass } = node\n      const { type } = superClass\n      const precedence = state.expressionsPrecedence[type]\n      if (\n        (type[0] !== 'C' || type[1] !== 'l' || type[5] !== 'E') &&\n        (precedence === NEEDS_PARENTHESES ||\n          precedence < state.expressionsPrecedence.ClassExpression)\n      ) {\n        // Not a ClassExpression that needs parentheses\n        state.write('(')\n        this[node.superClass.type](superClass, state)\n        state.write(')')\n      } else {\n        this[superClass.type](superClass, state)\n      }\n      state.write(' ')\n    }\n    this.ClassBody(node.body, state)\n  },\n  ImportDeclaration(node, state) {\n    state.write('import ')\n    const { specifiers } = node\n    const { length } = specifiers\n    // TODO: Once babili is fixed, put this after condition\n    // https://github.com/babel/babili/issues/430\n    let i = 0\n    if (length > 0) {\n      for (; i < length; ) {\n        if (i > 0) {\n          state.write(', ')\n        }\n        const specifier = specifiers[i]\n        const type = specifier.type[6]\n        if (type === 'D') {\n          // ImportDefaultSpecifier\n          state.write(specifier.local.name, specifier)\n          i++\n        } else if (type === 'N') {\n          // ImportNamespaceSpecifier\n          state.write('* as ' + specifier.local.name, specifier)\n          i++\n        } else {\n          // ImportSpecifier\n          break\n        }\n      }\n      if (i < length) {\n        state.write('{')\n        for (;;) {\n          const specifier = specifiers[i]\n          const { name } = specifier.imported\n          state.write(name, specifier)\n          if (name !== specifier.local.name) {\n            state.write(' as ' + specifier.local.name)\n          }\n          if (++i < length) {\n            state.write(', ')\n          } else {\n            break\n          }\n        }\n        state.write('}')\n      }\n      state.write(' from ')\n    }\n    this.Literal(node.source, state)\n    state.write(';')\n  },\n  ImportExpression(node, state) {\n    state.write('import(')\n    this[node.source.type](node.source, state)\n    state.write(')')\n  },\n  ExportDefaultDeclaration(node, state) {\n    state.write('export default ')\n    this[node.declaration.type](node.declaration, state)\n    if (\n      state.expressionsPrecedence[node.declaration.type] != null &&\n      node.declaration.type[0] !== 'F'\n    ) {\n      // All expression nodes except `FunctionExpression`\n      state.write(';')\n    }\n  },\n  ExportNamedDeclaration(node, state) {\n    state.write('export ')\n    if (node.declaration) {\n      this[node.declaration.type](node.declaration, state)\n    } else {\n      state.write('{')\n      const { specifiers } = node,\n        { length } = specifiers\n      if (length > 0) {\n        for (let i = 0; ; ) {\n          const specifier = specifiers[i]\n          const { name } = specifier.local\n          state.write(name, specifier)\n          if (name !== specifier.exported.name) {\n            state.write(' as ' + specifier.exported.name)\n          }\n          if (++i < length) {\n            state.write(', ')\n          } else {\n            break\n          }\n        }\n      }\n      state.write('}')\n      if (node.source) {\n        state.write(' from ')\n        this.Literal(node.source, state)\n      }\n      state.write(';')\n    }\n  },\n  ExportAllDeclaration(node, state) {\n    if (node.exported != null) {\n      state.write('export * as ' + node.exported.name + ' from ')\n    } else {\n      state.write('export * from ')\n    }\n    this.Literal(node.source, state)\n    state.write(';')\n  },\n  MethodDefinition(node, state) {\n    if (node.static) {\n      state.write('static ')\n    }\n    const kind = node.kind[0]\n    if (kind === 'g' || kind === 's') {\n      // Getter or setter\n      state.write(node.kind + ' ')\n    }\n    if (node.value.async) {\n      state.write('async ')\n    }\n    if (node.value.generator) {\n      state.write('*')\n    }\n    if (node.computed) {\n      state.write('[')\n      this[node.key.type](node.key, state)\n      state.write(']')\n    } else {\n      this[node.key.type](node.key, state)\n    }\n    formatSequence(state, node.value.params)\n    state.write(' ')\n    this[node.value.body.type](node.value.body, state)\n  },\n  ClassExpression(node, state) {\n    this.ClassDeclaration(node, state)\n  },\n  ArrowFunctionExpression(node, state) {\n    state.write(node.async ? 'async ' : '', node)\n    const { params } = node\n    if (params != null) {\n      // Omit parenthesis if only one named parameter\n      if (params.length === 1 && params[0].type[0] === 'I') {\n        // If params[0].type[0] starts with 'I', it can't be `ImportDeclaration` nor `IfStatement` and thus is `Identifier`\n        state.write(params[0].name, params[0])\n      } else {\n        formatSequence(state, node.params)\n      }\n    }\n    state.write(' => ')\n    if (node.body.type[0] === 'O') {\n      // Body is an object expression\n      state.write('(')\n      this.ObjectExpression(node.body, state)\n      state.write(')')\n    } else {\n      this[node.body.type](node.body, state)\n    }\n  },\n  ThisExpression(node, state) {\n    state.write('this', node)\n  },\n  Super(node, state) {\n    state.write('super', node)\n  },\n  RestElement: (RestElement = function (node, state) {\n    state.write('...')\n    this[node.argument.type](node.argument, state)\n  }),\n  SpreadElement: RestElement,\n  YieldExpression(node, state) {\n    state.write(node.delegate ? 'yield*' : 'yield')\n    if (node.argument) {\n      state.write(' ')\n      this[node.argument.type](node.argument, state)\n    }\n  },\n  AwaitExpression(node, state) {\n    state.write('await ', node)\n    formatExpression(state, node.argument, node)\n  },\n  TemplateLiteral(node, state) {\n    const { quasis, expressions } = node\n    state.write('`')\n    const { length } = expressions\n    for (let i = 0; i < length; i++) {\n      const expression = expressions[i]\n      const quasi = quasis[i]\n      state.write(quasi.value.raw, quasi)\n      state.write('${')\n      this[expression.type](expression, state)\n      state.write('}')\n    }\n    const quasi = quasis[quasis.length - 1]\n    state.write(quasi.value.raw, quasi)\n    state.write('`')\n  },\n  TemplateElement(node, state) {\n    state.write(node.value.raw, node)\n  },\n  TaggedTemplateExpression(node, state) {\n    formatExpression(state, node.tag, node)\n    this[node.quasi.type](node.quasi, state)\n  },\n  ArrayExpression: (ArrayExpression = function (node, state) {\n    state.write('[')\n    if (node.elements.length > 0) {\n      const { elements } = node,\n        { length } = elements\n      for (let i = 0; ; ) {\n        const element = elements[i]\n        if (element != null) {\n          this[element.type](element, state)\n        }\n        if (++i < length) {\n          state.write(', ')\n        } else {\n          if (element == null) {\n            state.write(', ')\n          }\n          break\n        }\n      }\n    }\n    state.write(']')\n  }),\n  ArrayPattern: ArrayExpression,\n  ObjectExpression(node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    const propertyIndent = indent + state.indent\n    state.write('{')\n    if (node.properties.length > 0) {\n      state.write(lineEnd)\n      if (writeComments && node.comments != null) {\n        formatComments(state, node.comments, propertyIndent, lineEnd)\n      }\n      const comma = ',' + lineEnd\n      const { properties } = node,\n        { length } = properties\n      for (let i = 0; ; ) {\n        const property = properties[i]\n        if (writeComments && property.comments != null) {\n          formatComments(state, property.comments, propertyIndent, lineEnd)\n        }\n        state.write(propertyIndent)\n        this[property.type](property, state)\n        if (++i < length) {\n          state.write(comma)\n        } else {\n          break\n        }\n      }\n      state.write(lineEnd)\n      if (writeComments && node.trailingComments != null) {\n        formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n      }\n      state.write(indent + '}')\n    } else if (writeComments) {\n      if (node.comments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.comments, propertyIndent, lineEnd)\n        if (node.trailingComments != null) {\n          formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n        }\n        state.write(indent + '}')\n      } else if (node.trailingComments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n        state.write(indent + '}')\n      } else {\n        state.write('}')\n      }\n    } else {\n      state.write('}')\n    }\n    state.indentLevel--\n  },\n  Property(node, state) {\n    if (node.method || node.kind[0] !== 'i') {\n      // Either a method or of kind `set` or `get` (not `init`)\n      this.MethodDefinition(node, state)\n    } else {\n      if (!node.shorthand) {\n        if (node.computed) {\n          state.write('[')\n          this[node.key.type](node.key, state)\n          state.write(']')\n        } else {\n          this[node.key.type](node.key, state)\n        }\n        state.write(': ')\n      }\n      this[node.value.type](node.value, state)\n    }\n  },\n  PropertyDefinition(node, state) {\n    if (node.static) {\n      state.write('static ')\n    }\n    if (node.computed) {\n      state.write('[')\n    }\n    this[node.key.type](node.key, state)\n    if (node.computed) {\n      state.write(']')\n    }\n    if (node.value == null) {\n      if (node.key.type[0] !== 'F') {\n        state.write(';')\n      }\n      return\n    }\n    state.write(' = ')\n    this[node.value.type](node.value, state)\n    state.write(';')\n  },\n  ObjectPattern(node, state) {\n    state.write('{')\n    if (node.properties.length > 0) {\n      const { properties } = node,\n        { length } = properties\n      for (let i = 0; ; ) {\n        this[properties[i].type](properties[i], state)\n        if (++i < length) {\n          state.write(', ')\n        } else {\n          break\n        }\n      }\n    }\n    state.write('}')\n  },\n  SequenceExpression(node, state) {\n    formatSequence(state, node.expressions)\n  },\n  UnaryExpression(node, state) {\n    if (node.prefix) {\n      const {\n        operator,\n        argument,\n        argument: { type },\n      } = node\n      state.write(operator)\n      const needsParentheses = expressionNeedsParenthesis(state, argument, node)\n      if (\n        !needsParentheses &&\n        (operator.length > 1 ||\n          (type[0] === 'U' &&\n            (type[1] === 'n' || type[1] === 'p') &&\n            argument.prefix &&\n            argument.operator[0] === operator &&\n            (operator === '+' || operator === '-')))\n      ) {\n        // Large operator or argument is UnaryExpression or UpdateExpression node\n        state.write(' ')\n      }\n      if (needsParentheses) {\n        state.write(operator.length > 1 ? ' (' : '(')\n        this[type](argument, state)\n        state.write(')')\n      } else {\n        this[type](argument, state)\n      }\n    } else {\n      // FIXME: This case never occurs\n      this[node.argument.type](node.argument, state)\n      state.write(node.operator)\n    }\n  },\n  UpdateExpression(node, state) {\n    // Always applied to identifiers or members, no parenthesis check needed\n    if (node.prefix) {\n      state.write(node.operator)\n      this[node.argument.type](node.argument, state)\n    } else {\n      this[node.argument.type](node.argument, state)\n      state.write(node.operator)\n    }\n  },\n  AssignmentExpression(node, state) {\n    this[node.left.type](node.left, state)\n    state.write(' ' + node.operator + ' ')\n    this[node.right.type](node.right, state)\n  },\n  AssignmentPattern(node, state) {\n    this[node.left.type](node.left, state)\n    state.write(' = ')\n    this[node.right.type](node.right, state)\n  },\n  BinaryExpression: (BinaryExpression = function (node, state) {\n    const isIn = node.operator === 'in'\n    if (isIn) {\n      // Avoids confusion in `for` loops initializers\n      state.write('(')\n    }\n    formatExpression(state, node.left, node, false)\n    state.write(' ' + node.operator + ' ')\n    formatExpression(state, node.right, node, true)\n    if (isIn) {\n      state.write(')')\n    }\n  }),\n  LogicalExpression: BinaryExpression,\n  ConditionalExpression(node, state) {\n    const { test } = node\n    const precedence = state.expressionsPrecedence[test.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence <= state.expressionsPrecedence.ConditionalExpression\n    ) {\n      state.write('(')\n      this[test.type](test, state)\n      state.write(')')\n    } else {\n      this[test.type](test, state)\n    }\n    state.write(' ? ')\n    this[node.consequent.type](node.consequent, state)\n    state.write(' : ')\n    this[node.alternate.type](node.alternate, state)\n  },\n  NewExpression(node, state) {\n    state.write('new ')\n    const precedence = state.expressionsPrecedence[node.callee.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.CallExpression ||\n      hasCallExpression(node.callee)\n    ) {\n      state.write('(')\n      this[node.callee.type](node.callee, state)\n      state.write(')')\n    } else {\n      this[node.callee.type](node.callee, state)\n    }\n    formatSequence(state, node['arguments'])\n  },\n  CallExpression(node, state) {\n    const precedence = state.expressionsPrecedence[node.callee.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.CallExpression\n    ) {\n      state.write('(')\n      this[node.callee.type](node.callee, state)\n      state.write(')')\n    } else {\n      this[node.callee.type](node.callee, state)\n    }\n    if (node.optional) {\n      state.write('?.')\n    }\n    formatSequence(state, node['arguments'])\n  },\n  ChainExpression(node, state) {\n    this[node.expression.type](node.expression, state)\n  },\n  MemberExpression(node, state) {\n    const precedence = state.expressionsPrecedence[node.object.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.MemberExpression\n    ) {\n      state.write('(')\n      this[node.object.type](node.object, state)\n      state.write(')')\n    } else {\n      this[node.object.type](node.object, state)\n    }\n    if (node.computed) {\n      if (node.optional) {\n        state.write('?.')\n      }\n      state.write('[')\n      this[node.property.type](node.property, state)\n      state.write(']')\n    } else {\n      if (node.optional) {\n        state.write('?.')\n      } else {\n        state.write('.')\n      }\n      this[node.property.type](node.property, state)\n    }\n  },\n  MetaProperty(node, state) {\n    state.write(node.meta.name + '.' + node.property.name, node)\n  },\n  Identifier(node, state) {\n    state.write(node.name, node)\n  },\n  PrivateIdentifier(node, state) {\n    state.write(`#${node.name}`, node)\n  },\n  Literal(node, state) {\n    if (node.raw != null) {\n      // Non-standard property\n      state.write(node.raw, node)\n    } else if (node.regex != null) {\n      this.RegExpLiteral(node, state)\n    } else if (node.bigint != null) {\n      state.write(node.bigint + 'n', node)\n    } else {\n      state.write(stringify(node.value), node)\n    }\n  },\n  RegExpLiteral(node, state) {\n    const { regex } = node\n    state.write(`/${regex.pattern}/${regex.flags}`, node)\n  },\n}\n\nconst EMPTY_OBJECT = {}\n\n/*\nDEPRECATED: Alternate export of `GENERATOR`.\n*/\nconst baseGenerator = GENERATOR\n\nclass State {\n  constructor(options) {\n    const setup = options == null ? EMPTY_OBJECT : options\n    this.output = ''\n    // Functional options\n    if (setup.output != null) {\n      this.output = setup.output\n      this.write = this.writeToStream\n    } else {\n      this.output = ''\n    }\n    this.generator = setup.generator != null ? setup.generator : GENERATOR\n    this.expressionsPrecedence =\n      setup.expressionsPrecedence != null\n        ? setup.expressionsPrecedence\n        : EXPRESSIONS_PRECEDENCE\n    // Formating setup\n    this.indent = setup.indent != null ? setup.indent : '  '\n    this.lineEnd = setup.lineEnd != null ? setup.lineEnd : '\\n'\n    this.indentLevel =\n      setup.startingIndentLevel != null ? setup.startingIndentLevel : 0\n    this.writeComments = setup.comments ? setup.comments : false\n    // Source map\n    if (setup.sourceMap != null) {\n      this.write =\n        setup.output == null ? this.writeAndMap : this.writeToStreamAndMap\n      this.sourceMap = setup.sourceMap\n      this.line = 1\n      this.column = 0\n      this.lineEndSize = this.lineEnd.split('\\n').length - 1\n      this.mapping = {\n        original: null,\n        // Uses the entire state to avoid generating ephemeral objects\n        generated: this,\n        name: undefined,\n        source: setup.sourceMap.file || setup.sourceMap._file,\n      }\n    }\n  }\n\n  write(code) {\n    this.output += code\n  }\n\n  writeToStream(code) {\n    this.output.write(code)\n  }\n\n  writeAndMap(code, node) {\n    this.output += code\n    this.map(code, node)\n  }\n\n  writeToStreamAndMap(code, node) {\n    this.output.write(code)\n    this.map(code, node)\n  }\n\n  map(code, node) {\n    if (node != null) {\n      const { type } = node\n      if (type[0] === 'L' && type[2] === 'n') {\n        // LineComment\n        this.column = 0\n        this.line++\n        return\n      }\n      if (node.loc != null) {\n        const { mapping } = this\n        mapping.original = node.loc.start\n        mapping.name = node.name\n        this.sourceMap.addMapping(mapping)\n      }\n      if (\n        (type[0] === 'T' && type[8] === 'E') ||\n        (type[0] === 'L' && type[1] === 'i' && typeof node.value === 'string')\n      ) {\n        // TemplateElement or Literal string node\n        const { length } = code\n        let { column, line } = this\n        for (let i = 0; i < length; i++) {\n          if (code[i] === '\\n') {\n            column = 0\n            line++\n          } else {\n            column++\n          }\n        }\n        this.column = column\n        this.line = line\n        return\n      }\n    }\n    const { length } = code\n    const { lineEnd } = this\n    if (length > 0) {\n      if (\n        this.lineEndSize > 0 &&\n        (lineEnd.length === 1\n          ? code[length - 1] === lineEnd\n          : code.endsWith(lineEnd))\n      ) {\n        this.line += this.lineEndSize\n        this.column = 0\n      } else {\n        this.column += length\n      }\n    }\n  }\n\n  toString() {\n    return this.output\n  }\n}\n\nfunction generate(node, options) {\n  /*\n  Returns a string representing the rendered code of the provided AST `node`.\n  The `options` are:\n\n  - `indent`: string to use for indentation (defaults to `␣␣`)\n  - `lineEnd`: string to use for line endings (defaults to `\\n`)\n  - `startingIndentLevel`: indent level to start from (defaults to `0`)\n  - `comments`: generate comments if `true` (defaults to `false`)\n  - `output`: output stream to write the rendered code to (defaults to `null`)\n  - `generator`: custom code generator (defaults to `GENERATOR`)\n  - `expressionsPrecedence`: custom map of node types and their precedence level (defaults to `EXPRESSIONS_PRECEDENCE`)\n  */\n  const state = new State(options)\n  // Travel through the AST node and generate the code\n  state.generator[node.type](node, state)\n  return state.output\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYXN0cmluZ0AxLjguNi9ub2RlX21vZHVsZXMvYXN0cmluZy9kaXN0L2FzdHJpbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsWUFBWTs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087O0FBRUE7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixjQUFjLGVBQWU7QUFDN0Isd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NibV8yMDI0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2FzdHJpbmdAMS44LjYvbm9kZV9tb2R1bGVzL2FzdHJpbmcvZGlzdC9hc3RyaW5nLm1qcz84YmQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFzdHJpbmcgaXMgYSB0aW55IGFuZCBmYXN0IEphdmFTY3JpcHQgY29kZSBnZW5lcmF0b3IgZnJvbSBhbiBFU1RyZWUtY29tcGxpYW50IEFTVC5cbi8vXG4vLyBBc3RyaW5nIHdhcyB3cml0dGVuIGJ5IERhdmlkIEJvbm5ldCBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2UuXG4vL1xuLy8gVGhlIEdpdCByZXBvc2l0b3J5IGZvciBBc3RyaW5nIGlzIGF2YWlsYWJsZSBhdDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJvbm5ldC9hc3RyaW5nLmdpdFxuLy9cbi8vIFBsZWFzZSB1c2UgdGhlIEdpdEh1YiBidWcgdHJhY2tlciB0byByZXBvcnQgaXNzdWVzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkYm9ubmV0L2FzdHJpbmcvaXNzdWVzXG5cbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSBKU09OXG5cbi8qIGM4IGlnbm9yZSBpZiAqL1xuaWYgKCFTdHJpbmcucHJvdG90eXBlLnJlcGVhdCkge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ1N0cmluZy5wcm90b3R5cGUucmVwZWF0IGlzIHVuZGVmaW5lZCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJvbm5ldC9hc3RyaW5nI2luc3RhbGxhdGlvbicsXG4gIClcbn1cblxuLyogYzggaWdub3JlIGlmICovXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpIHtcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoIGlzIHVuZGVmaW5lZCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJvbm5ldC9hc3RyaW5nI2luc3RhbGxhdGlvbicsXG4gIClcbn1cblxuY29uc3QgT1BFUkFUT1JfUFJFQ0VERU5DRSA9IHtcbiAgJ3x8JzogMixcbiAgJz8/JzogMyxcbiAgJyYmJzogNCxcbiAgJ3wnOiA1LFxuICAnXic6IDYsXG4gICcmJzogNyxcbiAgJz09JzogOCxcbiAgJyE9JzogOCxcbiAgJz09PSc6IDgsXG4gICchPT0nOiA4LFxuICAnPCc6IDksXG4gICc+JzogOSxcbiAgJzw9JzogOSxcbiAgJz49JzogOSxcbiAgaW46IDksXG4gIGluc3RhbmNlb2Y6IDksXG4gICc8PCc6IDEwLFxuICAnPj4nOiAxMCxcbiAgJz4+Pic6IDEwLFxuICAnKyc6IDExLFxuICAnLSc6IDExLFxuICAnKic6IDEyLFxuICAnJSc6IDEyLFxuICAnLyc6IDEyLFxuICAnKionOiAxMyxcbn1cblxuLy8gRW5hYmxlcyBwYXJlbnRoZXNpcyByZWdhcmRsZXNzIG9mIHByZWNlZGVuY2VcbmV4cG9ydCBjb25zdCBORUVEU19QQVJFTlRIRVNFUyA9IDE3XG5cbmV4cG9ydCBjb25zdCBFWFBSRVNTSU9OU19QUkVDRURFTkNFID0ge1xuICAvLyBEZWZpbml0aW9uc1xuICBBcnJheUV4cHJlc3Npb246IDIwLFxuICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246IDIwLFxuICBUaGlzRXhwcmVzc2lvbjogMjAsXG4gIElkZW50aWZpZXI6IDIwLFxuICBQcml2YXRlSWRlbnRpZmllcjogMjAsXG4gIExpdGVyYWw6IDE4LFxuICBUZW1wbGF0ZUxpdGVyYWw6IDIwLFxuICBTdXBlcjogMjAsXG4gIFNlcXVlbmNlRXhwcmVzc2lvbjogMjAsXG4gIC8vIE9wZXJhdGlvbnNcbiAgTWVtYmVyRXhwcmVzc2lvbjogMTksXG4gIENoYWluRXhwcmVzc2lvbjogMTksXG4gIENhbGxFeHByZXNzaW9uOiAxOSxcbiAgTmV3RXhwcmVzc2lvbjogMTksXG4gIC8vIE90aGVyIGRlZmluaXRpb25zXG4gIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBORUVEU19QQVJFTlRIRVNFUyxcbiAgQ2xhc3NFeHByZXNzaW9uOiBORUVEU19QQVJFTlRIRVNFUyxcbiAgRnVuY3Rpb25FeHByZXNzaW9uOiBORUVEU19QQVJFTlRIRVNFUyxcbiAgT2JqZWN0RXhwcmVzc2lvbjogTkVFRFNfUEFSRU5USEVTRVMsXG4gIC8vIE90aGVyIG9wZXJhdGlvbnNcbiAgVXBkYXRlRXhwcmVzc2lvbjogMTYsXG4gIFVuYXJ5RXhwcmVzc2lvbjogMTUsXG4gIEF3YWl0RXhwcmVzc2lvbjogMTUsXG4gIEJpbmFyeUV4cHJlc3Npb246IDE0LFxuICBMb2dpY2FsRXhwcmVzc2lvbjogMTMsXG4gIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogNCxcbiAgQXNzaWdubWVudEV4cHJlc3Npb246IDMsXG4gIFlpZWxkRXhwcmVzc2lvbjogMixcbiAgUmVzdEVsZW1lbnQ6IDEsXG59XG5cbmZ1bmN0aW9uIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2Rlcykge1xuICAvKlxuICBXcml0ZXMgaW50byBgc3RhdGVgIGEgc2VxdWVuY2Ugb2YgYG5vZGVzYC5cbiAgKi9cbiAgY29uc3QgeyBnZW5lcmF0b3IgfSA9IHN0YXRlXG4gIHN0YXRlLndyaXRlKCcoJylcbiAgaWYgKG5vZGVzICE9IG51bGwgJiYgbm9kZXMubGVuZ3RoID4gMCkge1xuICAgIGdlbmVyYXRvcltub2Rlc1swXS50eXBlXShub2Rlc1swXSwgc3RhdGUpXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFyYW0gPSBub2Rlc1tpXVxuICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgIGdlbmVyYXRvcltwYXJhbS50eXBlXShwYXJhbSwgc3RhdGUpXG4gICAgfVxuICB9XG4gIHN0YXRlLndyaXRlKCcpJylcbn1cblxuZnVuY3Rpb24gZXhwcmVzc2lvbk5lZWRzUGFyZW50aGVzaXMoc3RhdGUsIG5vZGUsIHBhcmVudE5vZGUsIGlzUmlnaHRIYW5kKSB7XG4gIGNvbnN0IG5vZGVQcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUudHlwZV1cbiAgaWYgKG5vZGVQcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgY29uc3QgcGFyZW50Tm9kZVByZWNlZGVuY2UgPSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2VbcGFyZW50Tm9kZS50eXBlXVxuICBpZiAobm9kZVByZWNlZGVuY2UgIT09IHBhcmVudE5vZGVQcmVjZWRlbmNlKSB7XG4gICAgLy8gRGlmZmVyZW50IG5vZGUgdHlwZXNcbiAgICByZXR1cm4gKFxuICAgICAgKCFpc1JpZ2h0SGFuZCAmJlxuICAgICAgICBub2RlUHJlY2VkZW5jZSA9PT0gMTUgJiZcbiAgICAgICAgcGFyZW50Tm9kZVByZWNlZGVuY2UgPT09IDE0ICYmXG4gICAgICAgIHBhcmVudE5vZGUub3BlcmF0b3IgPT09ICcqKicpIHx8XG4gICAgICBub2RlUHJlY2VkZW5jZSA8IHBhcmVudE5vZGVQcmVjZWRlbmNlXG4gICAgKVxuICB9XG4gIGlmIChub2RlUHJlY2VkZW5jZSAhPT0gMTMgJiYgbm9kZVByZWNlZGVuY2UgIT09IDE0KSB7XG4gICAgLy8gTm90IGEgYExvZ2ljYWxFeHByZXNzaW9uYCBvciBgQmluYXJ5RXhwcmVzc2lvbmBcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS5vcGVyYXRvciA9PT0gJyoqJyAmJiBwYXJlbnROb2RlLm9wZXJhdG9yID09PSAnKionKSB7XG4gICAgLy8gRXhwb25lbnRpYXRpb24gb3BlcmF0b3IgaGFzIHJpZ2h0LXRvLWxlZnQgYXNzb2NpYXRpdml0eVxuICAgIHJldHVybiAhaXNSaWdodEhhbmRcbiAgfVxuICBpZiAoXG4gICAgbm9kZVByZWNlZGVuY2UgPT09IDEzICYmXG4gICAgcGFyZW50Tm9kZVByZWNlZGVuY2UgPT09IDEzICYmXG4gICAgKG5vZGUub3BlcmF0b3IgPT09ICc/PycgfHwgcGFyZW50Tm9kZS5vcGVyYXRvciA9PT0gJz8/JylcbiAgKSB7XG4gICAgLy8gTnVsbGlzaCBjb2FsZXNjaW5nIGFuZCBib29sZWFuIG9wZXJhdG9ycyBjYW5ub3QgYmUgY29tYmluZWRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1JpZ2h0SGFuZCkge1xuICAgIC8vIFBhcmVudGhlc2lzIGFyZSB1c2VkIGlmIGJvdGggb3BlcmF0b3JzIGhhdmUgdGhlIHNhbWUgcHJlY2VkZW5jZVxuICAgIHJldHVybiAoXG4gICAgICBPUEVSQVRPUl9QUkVDRURFTkNFW25vZGUub3BlcmF0b3JdIDw9XG4gICAgICBPUEVSQVRPUl9QUkVDRURFTkNFW3BhcmVudE5vZGUub3BlcmF0b3JdXG4gICAgKVxuICB9XG4gIHJldHVybiAoXG4gICAgT1BFUkFUT1JfUFJFQ0VERU5DRVtub2RlLm9wZXJhdG9yXSA8XG4gICAgT1BFUkFUT1JfUFJFQ0VERU5DRVtwYXJlbnROb2RlLm9wZXJhdG9yXVxuICApXG59XG5cbmZ1bmN0aW9uIGZvcm1hdEV4cHJlc3Npb24oc3RhdGUsIG5vZGUsIHBhcmVudE5vZGUsIGlzUmlnaHRIYW5kKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgdGhlIHByb3ZpZGVkIGBub2RlYCwgYWRkaW5nIHBhcmVudGhlc2lzIGFyb3VuZCBpZiB0aGUgcHJvdmlkZWQgYHBhcmVudE5vZGVgIG5lZWRzIGl0LiBJZiBgbm9kZWAgaXMgYSByaWdodC1oYW5kIGFyZ3VtZW50LCB0aGUgcHJvdmlkZWQgYGlzUmlnaHRIYW5kYCBwYXJhbWV0ZXIgc2hvdWxkIGJlIGB0cnVlYC5cbiAgKi9cbiAgY29uc3QgeyBnZW5lcmF0b3IgfSA9IHN0YXRlXG4gIGlmIChleHByZXNzaW9uTmVlZHNQYXJlbnRoZXNpcyhzdGF0ZSwgbm9kZSwgcGFyZW50Tm9kZSwgaXNSaWdodEhhbmQpKSB7XG4gICAgc3RhdGUud3JpdGUoJygnKVxuICAgIGdlbmVyYXRvcltub2RlLnR5cGVdKG5vZGUsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpJylcbiAgfSBlbHNlIHtcbiAgICBnZW5lcmF0b3Jbbm9kZS50eXBlXShub2RlLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiByZWluZGVudChzdGF0ZSwgdGV4dCwgaW5kZW50LCBsaW5lRW5kKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgdGhlIGB0ZXh0YCBzdHJpbmcgcmVpbmRlbnRlZCB3aXRoIHRoZSBwcm92aWRlZCBgaW5kZW50YC5cbiAgKi9cbiAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKVxuICBjb25zdCBlbmQgPSBsaW5lcy5sZW5ndGggLSAxXG4gIHN0YXRlLndyaXRlKGxpbmVzWzBdLnRyaW0oKSlcbiAgaWYgKGVuZCA+IDApIHtcbiAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHN0YXRlLndyaXRlKGluZGVudCArIGxpbmVzW2ldLnRyaW0oKSArIGxpbmVFbmQpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKGluZGVudCArIGxpbmVzW2VuZF0udHJpbSgpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBjb21tZW50cywgaW5kZW50LCBsaW5lRW5kKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgdGhlIHByb3ZpZGVkIGxpc3Qgb2YgYGNvbW1lbnRzYCwgd2l0aCB0aGUgZ2l2ZW4gYGluZGVudGAgYW5kIGBsaW5lRW5kYCBzdHJpbmdzLlxuICBMaW5lIGNvbW1lbnRzIHdpbGwgZW5kIHdpdGggYFwiXFxuXCJgIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBsaW5lRW5kYC5cbiAgRXhwZWN0cyB0byBzdGFydCBvbiBhIG5ldyB1bmluZGVudGVkIGxpbmUuXG4gICovXG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBjb21tZW50c1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29tbWVudCA9IGNvbW1lbnRzW2ldXG4gICAgc3RhdGUud3JpdGUoaW5kZW50KVxuICAgIGlmIChjb21tZW50LnR5cGVbMF0gPT09ICdMJykge1xuICAgICAgLy8gTGluZSBjb21tZW50XG4gICAgICBzdGF0ZS53cml0ZSgnLy8gJyArIGNvbW1lbnQudmFsdWUudHJpbSgpICsgJ1xcbicsIGNvbW1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJsb2NrIGNvbW1lbnRcbiAgICAgIHN0YXRlLndyaXRlKCcvKicpXG4gICAgICByZWluZGVudChzdGF0ZSwgY29tbWVudC52YWx1ZSwgaW5kZW50LCBsaW5lRW5kKVxuICAgICAgc3RhdGUud3JpdGUoJyovJyArIGxpbmVFbmQpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0NhbGxFeHByZXNzaW9uKG5vZGUpIHtcbiAgLypcbiAgUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3ZpZGVkIGBub2RlYCBjb250YWlucyBhIGNhbGwgZXhwcmVzc2lvbiBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICovXG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGVcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IGN1cnJlbnROb2RlXG4gICAgaWYgKHR5cGVbMF0gPT09ICdDJyAmJiB0eXBlWzFdID09PSAnYScpIHtcbiAgICAgIC8vIElzIENhbGxFeHByZXNzaW9uXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAodHlwZVswXSA9PT0gJ00nICYmIHR5cGVbMV0gPT09ICdlJyAmJiB0eXBlWzJdID09PSAnbScpIHtcbiAgICAgIC8vIElzIE1lbWJlckV4cHJlc3Npb25cbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUub2JqZWN0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRWYXJpYWJsZURlY2xhcmF0aW9uKHN0YXRlLCBub2RlKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgYSB2YXJpYWJsZSBkZWNsYXJhdGlvbi5cbiAgKi9cbiAgY29uc3QgeyBnZW5lcmF0b3IgfSA9IHN0YXRlXG4gIGNvbnN0IHsgZGVjbGFyYXRpb25zIH0gPSBub2RlXG4gIHN0YXRlLndyaXRlKG5vZGUua2luZCArICcgJylcbiAgY29uc3QgeyBsZW5ndGggfSA9IGRlY2xhcmF0aW9uc1xuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIGdlbmVyYXRvci5WYXJpYWJsZURlY2xhcmF0b3IoZGVjbGFyYXRpb25zWzBdLCBzdGF0ZSlcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgZ2VuZXJhdG9yLlZhcmlhYmxlRGVjbGFyYXRvcihkZWNsYXJhdGlvbnNbaV0sIHN0YXRlKVxuICAgIH1cbiAgfVxufVxuXG5sZXQgRm9ySW5TdGF0ZW1lbnQsXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gIFJlc3RFbGVtZW50LFxuICBCaW5hcnlFeHByZXNzaW9uLFxuICBBcnJheUV4cHJlc3Npb24sXG4gIEJsb2NrU3RhdGVtZW50XG5cbmV4cG9ydCBjb25zdCBHRU5FUkFUT1IgPSB7XG4gIC8qXG4gIERlZmF1bHQgZ2VuZXJhdG9yLlxuICAqL1xuICBQcm9ncmFtKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgaW5kZW50ID0gc3RhdGUuaW5kZW50LnJlcGVhdChzdGF0ZS5pbmRlbnRMZXZlbClcbiAgICBjb25zdCB7IGxpbmVFbmQsIHdyaXRlQ29tbWVudHMgfSA9IHN0YXRlXG4gICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgbm9kZS5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgaW5kZW50LCBsaW5lRW5kKVxuICAgIH1cbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gbm9kZS5ib2R5XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHN0YXRlbWVudHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGF0ZW1lbnQgPSBzdGF0ZW1lbnRzW2ldXG4gICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBzdGF0ZW1lbnQuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgc3RhdGVtZW50LmNvbW1lbnRzLCBpbmRlbnQsIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBzdGF0ZS53cml0ZShpbmRlbnQpXG4gICAgICB0aGlzW3N0YXRlbWVudC50eXBlXShzdGF0ZW1lbnQsIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICB9XG4gICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgbm9kZS50cmFpbGluZ0NvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLnRyYWlsaW5nQ29tbWVudHMsIGluZGVudCwgbGluZUVuZClcbiAgICB9XG4gIH0sXG4gIEJsb2NrU3RhdGVtZW50OiAoQmxvY2tTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQucmVwZWF0KHN0YXRlLmluZGVudExldmVsKyspXG4gICAgY29uc3QgeyBsaW5lRW5kLCB3cml0ZUNvbW1lbnRzIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHN0YXRlbWVudEluZGVudCA9IGluZGVudCArIHN0YXRlLmluZGVudFxuICAgIHN0YXRlLndyaXRlKCd7JylcbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gbm9kZS5ib2R5XG4gICAgaWYgKHN0YXRlbWVudHMgIT0gbnVsbCAmJiBzdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUuY29tbWVudHMsIHN0YXRlbWVudEluZGVudCwgbGluZUVuZClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBzdGF0ZW1lbnRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlbWVudCA9IHN0YXRlbWVudHNbaV1cbiAgICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgc3RhdGVtZW50LmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgc3RhdGVtZW50LmNvbW1lbnRzLCBzdGF0ZW1lbnRJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUoc3RhdGVtZW50SW5kZW50KVxuICAgICAgICB0aGlzW3N0YXRlbWVudC50eXBlXShzdGF0ZW1lbnQsIHN0YXRlKVxuICAgICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoaW5kZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUuY29tbWVudHMsIHN0YXRlbWVudEluZGVudCwgbGluZUVuZClcbiAgICAgICAgc3RhdGUud3JpdGUoaW5kZW50KVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLnRyYWlsaW5nQ29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUudHJhaWxpbmdDb21tZW50cywgc3RhdGVtZW50SW5kZW50LCBsaW5lRW5kKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnfScpXG4gICAgc3RhdGUuaW5kZW50TGV2ZWwtLVxuICB9KSxcbiAgQ2xhc3NCb2R5OiBCbG9ja1N0YXRlbWVudCxcbiAgU3RhdGljQmxvY2sobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnc3RhdGljICcpXG4gICAgdGhpcy5CbG9ja1N0YXRlbWVudChub2RlLCBzdGF0ZSlcbiAgfSxcbiAgRW1wdHlTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIEV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUuZXhwcmVzc2lvbi50eXBlXVxuICAgIGlmIChcbiAgICAgIHByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTIHx8XG4gICAgICAocHJlY2VkZW5jZSA9PT0gMyAmJiBub2RlLmV4cHJlc3Npb24ubGVmdC50eXBlWzBdID09PSAnTycpXG4gICAgKSB7XG4gICAgICAvLyBTaG91bGQgYWx3YXlzIGhhdmUgcGFyZW50aGVzZXMgb3IgaXMgYW4gQXNzaWdubWVudEV4cHJlc3Npb24gdG8gYW4gT2JqZWN0UGF0dGVyblxuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpc1tub2RlLmV4cHJlc3Npb24udHlwZV0obm9kZS5leHByZXNzaW9uLCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmV4cHJlc3Npb24udHlwZV0obm9kZS5leHByZXNzaW9uLCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBJZlN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdpZiAoJylcbiAgICB0aGlzW25vZGUudGVzdC50eXBlXShub2RlLnRlc3QsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgdGhpc1tub2RlLmNvbnNlcXVlbnQudHlwZV0obm9kZS5jb25zZXF1ZW50LCBzdGF0ZSlcbiAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT0gbnVsbCkge1xuICAgICAgc3RhdGUud3JpdGUoJyBlbHNlICcpXG4gICAgICB0aGlzW25vZGUuYWx0ZXJuYXRlLnR5cGVdKG5vZGUuYWx0ZXJuYXRlLCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIExhYmVsZWRTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzW25vZGUubGFiZWwudHlwZV0obm9kZS5sYWJlbCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJzogJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9LFxuICBCcmVha1N0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdicmVhaycpXG4gICAgaWYgKG5vZGUubGFiZWwgIT0gbnVsbCkge1xuICAgICAgc3RhdGUud3JpdGUoJyAnKVxuICAgICAgdGhpc1tub2RlLmxhYmVsLnR5cGVdKG5vZGUubGFiZWwsIHN0YXRlKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIENvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2NvbnRpbnVlJylcbiAgICBpZiAobm9kZS5sYWJlbCAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnICcpXG4gICAgICB0aGlzW25vZGUubGFiZWwudHlwZV0obm9kZS5sYWJlbCwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgV2l0aFN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCd3aXRoICgnKVxuICAgIHRoaXNbbm9kZS5vYmplY3QudHlwZV0obm9kZS5vYmplY3QsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgfSxcbiAgU3dpdGNoU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgaW5kZW50ID0gc3RhdGUuaW5kZW50LnJlcGVhdChzdGF0ZS5pbmRlbnRMZXZlbCsrKVxuICAgIGNvbnN0IHsgbGluZUVuZCwgd3JpdGVDb21tZW50cyB9ID0gc3RhdGVcbiAgICBzdGF0ZS5pbmRlbnRMZXZlbCsrXG4gICAgY29uc3QgY2FzZUluZGVudCA9IGluZGVudCArIHN0YXRlLmluZGVudFxuICAgIGNvbnN0IHN0YXRlbWVudEluZGVudCA9IGNhc2VJbmRlbnQgKyBzdGF0ZS5pbmRlbnRcbiAgICBzdGF0ZS53cml0ZSgnc3dpdGNoICgnKVxuICAgIHRoaXNbbm9kZS5kaXNjcmltaW5hbnQudHlwZV0obm9kZS5kaXNjcmltaW5hbnQsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpIHsnICsgbGluZUVuZClcbiAgICBjb25zdCB7IGNhc2VzOiBvY2N1cmVuY2VzIH0gPSBub2RlXG4gICAgY29uc3QgeyBsZW5ndGg6IG9jY3VyZW5jZXNDb3VudCB9ID0gb2NjdXJlbmNlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2NjdXJlbmNlc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IG9jY3VyZW5jZSA9IG9jY3VyZW5jZXNbaV1cbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG9jY3VyZW5jZS5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBvY2N1cmVuY2UuY29tbWVudHMsIGNhc2VJbmRlbnQsIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBpZiAob2NjdXJlbmNlLnRlc3QpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoY2FzZUluZGVudCArICdjYXNlICcpXG4gICAgICAgIHRoaXNbb2NjdXJlbmNlLnRlc3QudHlwZV0ob2NjdXJlbmNlLnRlc3QsIHN0YXRlKVxuICAgICAgICBzdGF0ZS53cml0ZSgnOicgKyBsaW5lRW5kKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUud3JpdGUoY2FzZUluZGVudCArICdkZWZhdWx0OicgKyBsaW5lRW5kKVxuICAgICAgfVxuICAgICAgY29uc3QgeyBjb25zZXF1ZW50IH0gPSBvY2N1cmVuY2VcbiAgICAgIGNvbnN0IHsgbGVuZ3RoOiBjb25zZXF1ZW50Q291bnQgfSA9IGNvbnNlcXVlbnRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uc2VxdWVudENvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhdGVtZW50ID0gY29uc2VxdWVudFtpXVxuICAgICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBzdGF0ZW1lbnQuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBzdGF0ZW1lbnQuY29tbWVudHMsIHN0YXRlbWVudEluZGVudCwgbGluZUVuZClcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS53cml0ZShzdGF0ZW1lbnRJbmRlbnQpXG4gICAgICAgIHRoaXNbc3RhdGVtZW50LnR5cGVdKHN0YXRlbWVudCwgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLmluZGVudExldmVsIC09IDJcbiAgICBzdGF0ZS53cml0ZShpbmRlbnQgKyAnfScpXG4gIH0sXG4gIFJldHVyblN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdyZXR1cm4nKVxuICAgIGlmIChub2RlLmFyZ3VtZW50KSB7XG4gICAgICBzdGF0ZS53cml0ZSgnICcpXG4gICAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgVGhyb3dTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgndGhyb3cgJylcbiAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBUcnlTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgndHJ5ICcpXG4gICAgdGhpc1tub2RlLmJsb2NrLnR5cGVdKG5vZGUuYmxvY2ssIHN0YXRlKVxuICAgIGlmIChub2RlLmhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IHsgaGFuZGxlciB9ID0gbm9kZVxuICAgICAgaWYgKGhhbmRsZXIucGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS53cml0ZSgnIGNhdGNoICcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS53cml0ZSgnIGNhdGNoICgnKVxuICAgICAgICB0aGlzW2hhbmRsZXIucGFyYW0udHlwZV0oaGFuZGxlci5wYXJhbSwgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgICB9XG4gICAgICB0aGlzW2hhbmRsZXIuYm9keS50eXBlXShoYW5kbGVyLmJvZHksIHN0YXRlKVxuICAgIH1cbiAgICBpZiAobm9kZS5maW5hbGl6ZXIpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgZmluYWxseSAnKVxuICAgICAgdGhpc1tub2RlLmZpbmFsaXplci50eXBlXShub2RlLmZpbmFsaXplciwgc3RhdGUpXG4gICAgfVxuICB9LFxuICBXaGlsZVN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCd3aGlsZSAoJylcbiAgICB0aGlzW25vZGUudGVzdC50eXBlXShub2RlLnRlc3QsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgfSxcbiAgRG9XaGlsZVN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdkbyAnKVxuICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJyB3aGlsZSAoJylcbiAgICB0aGlzW25vZGUudGVzdC50eXBlXShub2RlLnRlc3QsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpOycpXG4gIH0sXG4gIEZvclN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdmb3IgKCcpXG4gICAgaWYgKG5vZGUuaW5pdCAhPSBudWxsKSB7XG4gICAgICBjb25zdCB7IGluaXQgfSA9IG5vZGVcbiAgICAgIGlmIChpbml0LnR5cGVbMF0gPT09ICdWJykge1xuICAgICAgICBmb3JtYXRWYXJpYWJsZURlY2xhcmF0aW9uKHN0YXRlLCBpbml0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tpbml0LnR5cGVdKGluaXQsIHN0YXRlKVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnOyAnKVxuICAgIGlmIChub2RlLnRlc3QpIHtcbiAgICAgIHRoaXNbbm9kZS50ZXN0LnR5cGVdKG5vZGUudGVzdCwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7ICcpXG4gICAgaWYgKG5vZGUudXBkYXRlKSB7XG4gICAgICB0aGlzW25vZGUudXBkYXRlLnR5cGVdKG5vZGUudXBkYXRlLCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJykgJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9LFxuICBGb3JJblN0YXRlbWVudDogKEZvckluU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoYGZvciAke25vZGUuYXdhaXQgPyAnYXdhaXQgJyA6ICcnfShgKVxuICAgIGNvbnN0IHsgbGVmdCB9ID0gbm9kZVxuICAgIGlmIChsZWZ0LnR5cGVbMF0gPT09ICdWJykge1xuICAgICAgZm9ybWF0VmFyaWFibGVEZWNsYXJhdGlvbihzdGF0ZSwgbGVmdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tsZWZ0LnR5cGVdKGxlZnQsIHN0YXRlKVxuICAgIH1cbiAgICAvLyBJZGVudGlmeWluZyB3aGV0aGVyIG5vZGUudHlwZSBpcyBgRm9ySW5TdGF0ZW1lbnRgIG9yIGBGb3JPZlN0YXRlbWVudGBcbiAgICBzdGF0ZS53cml0ZShub2RlLnR5cGVbM10gPT09ICdJJyA/ICcgaW4gJyA6ICcgb2YgJylcbiAgICB0aGlzW25vZGUucmlnaHQudHlwZV0obm9kZS5yaWdodCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJykgJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9KSxcbiAgRm9yT2ZTdGF0ZW1lbnQ6IEZvckluU3RhdGVtZW50LFxuICBEZWJ1Z2dlclN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdkZWJ1Z2dlcjsnLCBub2RlKVxuICB9LFxuICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAoRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKFxuICAgICAgKG5vZGUuYXN5bmMgPyAnYXN5bmMgJyA6ICcnKSArXG4gICAgICAgIChub2RlLmdlbmVyYXRvciA/ICdmdW5jdGlvbiogJyA6ICdmdW5jdGlvbiAnKSArXG4gICAgICAgIChub2RlLmlkID8gbm9kZS5pZC5uYW1lIDogJycpLFxuICAgICAgbm9kZSxcbiAgICApXG4gICAgZm9ybWF0U2VxdWVuY2Uoc3RhdGUsIG5vZGUucGFyYW1zKVxuICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9KSxcbiAgRnVuY3Rpb25FeHByZXNzaW9uOiBGdW5jdGlvbkRlY2xhcmF0aW9uLFxuICBWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgZm9ybWF0VmFyaWFibGVEZWNsYXJhdGlvbihzdGF0ZSwgbm9kZSlcbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIFZhcmlhYmxlRGVjbGFyYXRvcihub2RlLCBzdGF0ZSkge1xuICAgIHRoaXNbbm9kZS5pZC50eXBlXShub2RlLmlkLCBzdGF0ZSlcbiAgICBpZiAobm9kZS5pbml0ICE9IG51bGwpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgPSAnKVxuICAgICAgdGhpc1tub2RlLmluaXQudHlwZV0obm9kZS5pbml0LCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIENsYXNzRGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnY2xhc3MgJyArIChub2RlLmlkID8gYCR7bm9kZS5pZC5uYW1lfSBgIDogJycpLCBub2RlKVxuICAgIGlmIChub2RlLnN1cGVyQ2xhc3MpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdleHRlbmRzICcpXG4gICAgICBjb25zdCB7IHN1cGVyQ2xhc3MgfSA9IG5vZGVcbiAgICAgIGNvbnN0IHsgdHlwZSB9ID0gc3VwZXJDbGFzc1xuICAgICAgY29uc3QgcHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVt0eXBlXVxuICAgICAgaWYgKFxuICAgICAgICAodHlwZVswXSAhPT0gJ0MnIHx8IHR5cGVbMV0gIT09ICdsJyB8fCB0eXBlWzVdICE9PSAnRScpICYmXG4gICAgICAgIChwcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUyB8fFxuICAgICAgICAgIHByZWNlZGVuY2UgPCBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuQ2xhc3NFeHByZXNzaW9uKVxuICAgICAgKSB7XG4gICAgICAgIC8vIE5vdCBhIENsYXNzRXhwcmVzc2lvbiB0aGF0IG5lZWRzIHBhcmVudGhlc2VzXG4gICAgICAgIHN0YXRlLndyaXRlKCcoJylcbiAgICAgICAgdGhpc1tub2RlLnN1cGVyQ2xhc3MudHlwZV0oc3VwZXJDbGFzcywgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbc3VwZXJDbGFzcy50eXBlXShzdXBlckNsYXNzLCBzdGF0ZSlcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICB9XG4gICAgdGhpcy5DbGFzc0JvZHkobm9kZS5ib2R5LCBzdGF0ZSlcbiAgfSxcbiAgSW1wb3J0RGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnaW1wb3J0ICcpXG4gICAgY29uc3QgeyBzcGVjaWZpZXJzIH0gPSBub2RlXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHNwZWNpZmllcnNcbiAgICAvLyBUT0RPOiBPbmNlIGJhYmlsaSBpcyBmaXhlZCwgcHV0IHRoaXMgYWZ0ZXIgY29uZGl0aW9uXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmlsaS9pc3N1ZXMvNDMwXG4gICAgbGV0IGkgPSAwXG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyApIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGVjaWZpZXIgPSBzcGVjaWZpZXJzW2ldXG4gICAgICAgIGNvbnN0IHR5cGUgPSBzcGVjaWZpZXIudHlwZVs2XVxuICAgICAgICBpZiAodHlwZSA9PT0gJ0QnKSB7XG4gICAgICAgICAgLy8gSW1wb3J0RGVmYXVsdFNwZWNpZmllclxuICAgICAgICAgIHN0YXRlLndyaXRlKHNwZWNpZmllci5sb2NhbC5uYW1lLCBzcGVjaWZpZXIpXG4gICAgICAgICAgaSsrXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ04nKSB7XG4gICAgICAgICAgLy8gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXG4gICAgICAgICAgc3RhdGUud3JpdGUoJyogYXMgJyArIHNwZWNpZmllci5sb2NhbC5uYW1lLCBzcGVjaWZpZXIpXG4gICAgICAgICAgaSsrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW1wb3J0U3BlY2lmaWVyXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJ3snKVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgY29uc3Qgc3BlY2lmaWVyID0gc3BlY2lmaWVyc1tpXVxuICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gc3BlY2lmaWVyLmltcG9ydGVkXG4gICAgICAgICAgc3RhdGUud3JpdGUobmFtZSwgc3BlY2lmaWVyKVxuICAgICAgICAgIGlmIChuYW1lICE9PSBzcGVjaWZpZXIubG9jYWwubmFtZSkge1xuICAgICAgICAgICAgc3RhdGUud3JpdGUoJyBhcyAnICsgc3BlY2lmaWVyLmxvY2FsLm5hbWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyaXRlKCd9JylcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKCcgZnJvbSAnKVxuICAgIH1cbiAgICB0aGlzLkxpdGVyYWwobm9kZS5zb3VyY2UsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgSW1wb3J0RXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdpbXBvcnQoJylcbiAgICB0aGlzW25vZGUuc291cmNlLnR5cGVdKG5vZGUuc291cmNlLCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnKScpXG4gIH0sXG4gIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdleHBvcnQgZGVmYXVsdCAnKVxuICAgIHRoaXNbbm9kZS5kZWNsYXJhdGlvbi50eXBlXShub2RlLmRlY2xhcmF0aW9uLCBzdGF0ZSlcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2Vbbm9kZS5kZWNsYXJhdGlvbi50eXBlXSAhPSBudWxsICYmXG4gICAgICBub2RlLmRlY2xhcmF0aW9uLnR5cGVbMF0gIT09ICdGJ1xuICAgICkge1xuICAgICAgLy8gQWxsIGV4cHJlc3Npb24gbm9kZXMgZXhjZXB0IGBGdW5jdGlvbkV4cHJlc3Npb25gXG4gICAgICBzdGF0ZS53cml0ZSgnOycpXG4gICAgfVxuICB9LFxuICBFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2V4cG9ydCAnKVxuICAgIGlmIChub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgICB0aGlzW25vZGUuZGVjbGFyYXRpb24udHlwZV0obm9kZS5kZWNsYXJhdGlvbiwgc3RhdGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLndyaXRlKCd7JylcbiAgICAgIGNvbnN0IHsgc3BlY2lmaWVycyB9ID0gbm9kZSxcbiAgICAgICAgeyBsZW5ndGggfSA9IHNwZWNpZmllcnNcbiAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyA7ICkge1xuICAgICAgICAgIGNvbnN0IHNwZWNpZmllciA9IHNwZWNpZmllcnNbaV1cbiAgICAgICAgICBjb25zdCB7IG5hbWUgfSA9IHNwZWNpZmllci5sb2NhbFxuICAgICAgICAgIHN0YXRlLndyaXRlKG5hbWUsIHNwZWNpZmllcilcbiAgICAgICAgICBpZiAobmFtZSAhPT0gc3BlY2lmaWVyLmV4cG9ydGVkLm5hbWUpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKCcgYXMgJyArIHNwZWNpZmllci5leHBvcnRlZC5uYW1lKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgICAgaWYgKG5vZGUuc291cmNlKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCcgZnJvbSAnKVxuICAgICAgICB0aGlzLkxpdGVyYWwobm9kZS5zb3VyY2UsIHN0YXRlKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoJzsnKVxuICAgIH1cbiAgfSxcbiAgRXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5leHBvcnRlZCAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnZXhwb3J0ICogYXMgJyArIG5vZGUuZXhwb3J0ZWQubmFtZSArICcgZnJvbSAnKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS53cml0ZSgnZXhwb3J0ICogZnJvbSAnKVxuICAgIH1cbiAgICB0aGlzLkxpdGVyYWwobm9kZS5zb3VyY2UsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgTWV0aG9kRGVmaW5pdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnN0YXRpYykge1xuICAgICAgc3RhdGUud3JpdGUoJ3N0YXRpYyAnKVxuICAgIH1cbiAgICBjb25zdCBraW5kID0gbm9kZS5raW5kWzBdXG4gICAgaWYgKGtpbmQgPT09ICdnJyB8fCBraW5kID09PSAncycpIHtcbiAgICAgIC8vIEdldHRlciBvciBzZXR0ZXJcbiAgICAgIHN0YXRlLndyaXRlKG5vZGUua2luZCArICcgJylcbiAgICB9XG4gICAgaWYgKG5vZGUudmFsdWUuYXN5bmMpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdhc3luYyAnKVxuICAgIH1cbiAgICBpZiAobm9kZS52YWx1ZS5nZW5lcmF0b3IpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcqJylcbiAgICB9XG4gICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICAgIHRoaXNbbm9kZS5rZXkudHlwZV0obm9kZS5rZXksIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJ10nKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICB9XG4gICAgZm9ybWF0U2VxdWVuY2Uoc3RhdGUsIG5vZGUudmFsdWUucGFyYW1zKVxuICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICB0aGlzW25vZGUudmFsdWUuYm9keS50eXBlXShub2RlLnZhbHVlLmJvZHksIHN0YXRlKVxuICB9LFxuICBDbGFzc0V4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzLkNsYXNzRGVjbGFyYXRpb24obm9kZSwgc3RhdGUpXG4gIH0sXG4gIEFycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS5hc3luYyA/ICdhc3luYyAnIDogJycsIG5vZGUpXG4gICAgY29uc3QgeyBwYXJhbXMgfSA9IG5vZGVcbiAgICBpZiAocGFyYW1zICE9IG51bGwpIHtcbiAgICAgIC8vIE9taXQgcGFyZW50aGVzaXMgaWYgb25seSBvbmUgbmFtZWQgcGFyYW1ldGVyXG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBwYXJhbXNbMF0udHlwZVswXSA9PT0gJ0knKSB7XG4gICAgICAgIC8vIElmIHBhcmFtc1swXS50eXBlWzBdIHN0YXJ0cyB3aXRoICdJJywgaXQgY2FuJ3QgYmUgYEltcG9ydERlY2xhcmF0aW9uYCBub3IgYElmU3RhdGVtZW50YCBhbmQgdGh1cyBpcyBgSWRlbnRpZmllcmBcbiAgICAgICAgc3RhdGUud3JpdGUocGFyYW1zWzBdLm5hbWUsIHBhcmFtc1swXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2RlLnBhcmFtcylcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJyA9PiAnKVxuICAgIGlmIChub2RlLmJvZHkudHlwZVswXSA9PT0gJ08nKSB7XG4gICAgICAvLyBCb2R5IGlzIGFuIG9iamVjdCBleHByZXNzaW9uXG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzLk9iamVjdEV4cHJlc3Npb24obm9kZS5ib2R5LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIFRoaXNFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3RoaXMnLCBub2RlKVxuICB9LFxuICBTdXBlcihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdzdXBlcicsIG5vZGUpXG4gIH0sXG4gIFJlc3RFbGVtZW50OiAoUmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnLi4uJylcbiAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gIH0pLFxuICBTcHJlYWRFbGVtZW50OiBSZXN0RWxlbWVudCxcbiAgWWllbGRFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS5kZWxlZ2F0ZSA/ICd5aWVsZConIDogJ3lpZWxkJylcbiAgICBpZiAobm9kZS5hcmd1bWVudCkge1xuICAgICAgc3RhdGUud3JpdGUoJyAnKVxuICAgICAgdGhpc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5vZGUuYXJndW1lbnQsIHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgQXdhaXRFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2F3YWl0ICcsIG5vZGUpXG4gICAgZm9ybWF0RXhwcmVzc2lvbihzdGF0ZSwgbm9kZS5hcmd1bWVudCwgbm9kZSlcbiAgfSxcbiAgVGVtcGxhdGVMaXRlcmFsKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgeyBxdWFzaXMsIGV4cHJlc3Npb25zIH0gPSBub2RlXG4gICAgc3RhdGUud3JpdGUoJ2AnKVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBleHByZXNzaW9uc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBleHByZXNzaW9uc1tpXVxuICAgICAgY29uc3QgcXVhc2kgPSBxdWFzaXNbaV1cbiAgICAgIHN0YXRlLndyaXRlKHF1YXNpLnZhbHVlLnJhdywgcXVhc2kpXG4gICAgICBzdGF0ZS53cml0ZSgnJHsnKVxuICAgICAgdGhpc1tleHByZXNzaW9uLnR5cGVdKGV4cHJlc3Npb24sIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgIH1cbiAgICBjb25zdCBxdWFzaSA9IHF1YXNpc1txdWFzaXMubGVuZ3RoIC0gMV1cbiAgICBzdGF0ZS53cml0ZShxdWFzaS52YWx1ZS5yYXcsIHF1YXNpKVxuICAgIHN0YXRlLndyaXRlKCdgJylcbiAgfSxcbiAgVGVtcGxhdGVFbGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS52YWx1ZS5yYXcsIG5vZGUpXG4gIH0sXG4gIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIGZvcm1hdEV4cHJlc3Npb24oc3RhdGUsIG5vZGUudGFnLCBub2RlKVxuICAgIHRoaXNbbm9kZS5xdWFzaS50eXBlXShub2RlLnF1YXNpLCBzdGF0ZSlcbiAgfSxcbiAgQXJyYXlFeHByZXNzaW9uOiAoQXJyYXlFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ1snKVxuICAgIGlmIChub2RlLmVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHsgZWxlbWVudHMgfSA9IG5vZGUsXG4gICAgICAgIHsgbGVuZ3RoIH0gPSBlbGVtZW50c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IDsgKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXVxuICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpc1tlbGVtZW50LnR5cGVdKGVsZW1lbnQsIHN0YXRlKVxuICAgICAgICB9XG4gICAgICAgIGlmICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJ10nKVxuICB9KSxcbiAgQXJyYXlQYXR0ZXJuOiBBcnJheUV4cHJlc3Npb24sXG4gIE9iamVjdEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQucmVwZWF0KHN0YXRlLmluZGVudExldmVsKyspXG4gICAgY29uc3QgeyBsaW5lRW5kLCB3cml0ZUNvbW1lbnRzIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHByb3BlcnR5SW5kZW50ID0gaW5kZW50ICsgc3RhdGUuaW5kZW50XG4gICAgc3RhdGUud3JpdGUoJ3snKVxuICAgIGlmIChub2RlLnByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBjb25zdCBjb21tYSA9ICcsJyArIGxpbmVFbmRcbiAgICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gbm9kZSxcbiAgICAgICAgeyBsZW5ndGggfSA9IHByb3BlcnRpZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyA7ICkge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV1cbiAgICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgcHJvcGVydHkuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBwcm9wZXJ0eS5jb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUocHJvcGVydHlJbmRlbnQpXG4gICAgICAgIHRoaXNbcHJvcGVydHkudHlwZV0ocHJvcGVydHksIHN0YXRlKVxuICAgICAgICBpZiAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgc3RhdGUud3JpdGUoY29tbWEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUudHJhaWxpbmdDb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLnRyYWlsaW5nQ29tbWVudHMsIHByb3BlcnR5SW5kZW50LCBsaW5lRW5kKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoaW5kZW50ICsgJ30nKVxuICAgIH0gZWxzZSBpZiAod3JpdGVDb21tZW50cykge1xuICAgICAgaWYgKG5vZGUuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIGlmIChub2RlLnRyYWlsaW5nQ29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLnRyYWlsaW5nQ29tbWVudHMsIHByb3BlcnR5SW5kZW50LCBsaW5lRW5kKVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyaXRlKGluZGVudCArICd9JylcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50cmFpbGluZ0NvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUudHJhaWxpbmdDb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIHN0YXRlLndyaXRlKGluZGVudCArICd9JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCd9JylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgIH1cbiAgICBzdGF0ZS5pbmRlbnRMZXZlbC0tXG4gIH0sXG4gIFByb3BlcnR5KG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUubWV0aG9kIHx8IG5vZGUua2luZFswXSAhPT0gJ2knKSB7XG4gICAgICAvLyBFaXRoZXIgYSBtZXRob2Qgb3Igb2Yga2luZCBgc2V0YCBvciBgZ2V0YCAobm90IGBpbml0YClcbiAgICAgIHRoaXMuTWV0aG9kRGVmaW5pdGlvbihub2RlLCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFub2RlLnNob3J0aGFuZCkge1xuICAgICAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICAgICAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnXScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1tub2RlLmtleS50eXBlXShub2RlLmtleSwgc3RhdGUpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUoJzogJylcbiAgICAgIH1cbiAgICAgIHRoaXNbbm9kZS52YWx1ZS50eXBlXShub2RlLnZhbHVlLCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIFByb3BlcnR5RGVmaW5pdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnN0YXRpYykge1xuICAgICAgc3RhdGUud3JpdGUoJ3N0YXRpYyAnKVxuICAgIH1cbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgc3RhdGUud3JpdGUoJ1snKVxuICAgIH1cbiAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgc3RhdGUud3JpdGUoJ10nKVxuICAgIH1cbiAgICBpZiAobm9kZS52YWx1ZSA9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5rZXkudHlwZVswXSAhPT0gJ0YnKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCc7JylcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnID0gJylcbiAgICB0aGlzW25vZGUudmFsdWUudHlwZV0obm9kZS52YWx1ZSwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBPYmplY3RQYXR0ZXJuKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3snKVxuICAgIGlmIChub2RlLnByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBub2RlLFxuICAgICAgICB7IGxlbmd0aCB9ID0gcHJvcGVydGllc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IDsgKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydGllc1tpXS50eXBlXShwcm9wZXJ0aWVzW2ldLCBzdGF0ZSlcbiAgICAgICAgaWYgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnfScpXG4gIH0sXG4gIFNlcXVlbmNlRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2RlLmV4cHJlc3Npb25zKVxuICB9LFxuICBVbmFyeUV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5wcmVmaXgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgIGFyZ3VtZW50LFxuICAgICAgICBhcmd1bWVudDogeyB0eXBlIH0sXG4gICAgICB9ID0gbm9kZVxuICAgICAgc3RhdGUud3JpdGUob3BlcmF0b3IpXG4gICAgICBjb25zdCBuZWVkc1BhcmVudGhlc2VzID0gZXhwcmVzc2lvbk5lZWRzUGFyZW50aGVzaXMoc3RhdGUsIGFyZ3VtZW50LCBub2RlKVxuICAgICAgaWYgKFxuICAgICAgICAhbmVlZHNQYXJlbnRoZXNlcyAmJlxuICAgICAgICAob3BlcmF0b3IubGVuZ3RoID4gMSB8fFxuICAgICAgICAgICh0eXBlWzBdID09PSAnVScgJiZcbiAgICAgICAgICAgICh0eXBlWzFdID09PSAnbicgfHwgdHlwZVsxXSA9PT0gJ3AnKSAmJlxuICAgICAgICAgICAgYXJndW1lbnQucHJlZml4ICYmXG4gICAgICAgICAgICBhcmd1bWVudC5vcGVyYXRvclswXSA9PT0gb3BlcmF0b3IgJiZcbiAgICAgICAgICAgIChvcGVyYXRvciA9PT0gJysnIHx8IG9wZXJhdG9yID09PSAnLScpKSlcbiAgICAgICkge1xuICAgICAgICAvLyBMYXJnZSBvcGVyYXRvciBvciBhcmd1bWVudCBpcyBVbmFyeUV4cHJlc3Npb24gb3IgVXBkYXRlRXhwcmVzc2lvbiBub2RlXG4gICAgICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc1BhcmVudGhlc2VzKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKG9wZXJhdG9yLmxlbmd0aCA+IDEgPyAnICgnIDogJygnKVxuICAgICAgICB0aGlzW3R5cGVdKGFyZ3VtZW50LCBzdGF0ZSlcbiAgICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1t0eXBlXShhcmd1bWVudCwgc3RhdGUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZJWE1FOiBUaGlzIGNhc2UgbmV2ZXIgb2NjdXJzXG4gICAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZShub2RlLm9wZXJhdG9yKVxuICAgIH1cbiAgfSxcbiAgVXBkYXRlRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIC8vIEFsd2F5cyBhcHBsaWVkIHRvIGlkZW50aWZpZXJzIG9yIG1lbWJlcnMsIG5vIHBhcmVudGhlc2lzIGNoZWNrIG5lZWRlZFxuICAgIGlmIChub2RlLnByZWZpeCkge1xuICAgICAgc3RhdGUud3JpdGUobm9kZS5vcGVyYXRvcilcbiAgICAgIHRoaXNbbm9kZS5hcmd1bWVudC50eXBlXShub2RlLmFyZ3VtZW50LCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5vZGUuYXJndW1lbnQsIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUobm9kZS5vcGVyYXRvcilcbiAgICB9XG4gIH0sXG4gIEFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgdGhpc1tub2RlLmxlZnQudHlwZV0obm9kZS5sZWZ0LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnICcgKyBub2RlLm9wZXJhdG9yICsgJyAnKVxuICAgIHRoaXNbbm9kZS5yaWdodC50eXBlXShub2RlLnJpZ2h0LCBzdGF0ZSlcbiAgfSxcbiAgQXNzaWdubWVudFBhdHRlcm4obm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzW25vZGUubGVmdC50eXBlXShub2RlLmxlZnQsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcgPSAnKVxuICAgIHRoaXNbbm9kZS5yaWdodC50eXBlXShub2RlLnJpZ2h0LCBzdGF0ZSlcbiAgfSxcbiAgQmluYXJ5RXhwcmVzc2lvbjogKEJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpc0luID0gbm9kZS5vcGVyYXRvciA9PT0gJ2luJ1xuICAgIGlmIChpc0luKSB7XG4gICAgICAvLyBBdm9pZHMgY29uZnVzaW9uIGluIGBmb3JgIGxvb3BzIGluaXRpYWxpemVyc1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgIH1cbiAgICBmb3JtYXRFeHByZXNzaW9uKHN0YXRlLCBub2RlLmxlZnQsIG5vZGUsIGZhbHNlKVxuICAgIHN0YXRlLndyaXRlKCcgJyArIG5vZGUub3BlcmF0b3IgKyAnICcpXG4gICAgZm9ybWF0RXhwcmVzc2lvbihzdGF0ZSwgbm9kZS5yaWdodCwgbm9kZSwgdHJ1ZSlcbiAgICBpZiAoaXNJbikge1xuICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgIH1cbiAgfSksXG4gIExvZ2ljYWxFeHByZXNzaW9uOiBCaW5hcnlFeHByZXNzaW9uLFxuICBDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCB7IHRlc3QgfSA9IG5vZGVcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW3Rlc3QudHlwZV1cbiAgICBpZiAoXG4gICAgICBwcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUyB8fFxuICAgICAgcHJlY2VkZW5jZSA8PSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuQ29uZGl0aW9uYWxFeHByZXNzaW9uXG4gICAgKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzW3Rlc3QudHlwZV0odGVzdCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbdGVzdC50eXBlXSh0ZXN0LCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJyA/ICcpXG4gICAgdGhpc1tub2RlLmNvbnNlcXVlbnQudHlwZV0obm9kZS5jb25zZXF1ZW50LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnIDogJylcbiAgICB0aGlzW25vZGUuYWx0ZXJuYXRlLnR5cGVdKG5vZGUuYWx0ZXJuYXRlLCBzdGF0ZSlcbiAgfSxcbiAgTmV3RXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCduZXcgJylcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUuY2FsbGVlLnR5cGVdXG4gICAgaWYgKFxuICAgICAgcHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMgfHxcbiAgICAgIHByZWNlZGVuY2UgPCBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuQ2FsbEV4cHJlc3Npb24gfHxcbiAgICAgIGhhc0NhbGxFeHByZXNzaW9uKG5vZGUuY2FsbGVlKVxuICAgICkge1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpc1tub2RlLmNhbGxlZS50eXBlXShub2RlLmNhbGxlZSwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbm9kZS5jYWxsZWUudHlwZV0obm9kZS5jYWxsZWUsIHN0YXRlKVxuICAgIH1cbiAgICBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZVsnYXJndW1lbnRzJ10pXG4gIH0sXG4gIENhbGxFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVtub2RlLmNhbGxlZS50eXBlXVxuICAgIGlmIChcbiAgICAgIHByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTIHx8XG4gICAgICBwcmVjZWRlbmNlIDwgc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlLkNhbGxFeHByZXNzaW9uXG4gICAgKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzW25vZGUuY2FsbGVlLnR5cGVdKG5vZGUuY2FsbGVlLCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmNhbGxlZS50eXBlXShub2RlLmNhbGxlZSwgc3RhdGUpXG4gICAgfVxuICAgIGlmIChub2RlLm9wdGlvbmFsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnPy4nKVxuICAgIH1cbiAgICBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZVsnYXJndW1lbnRzJ10pXG4gIH0sXG4gIENoYWluRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHRoaXNbbm9kZS5leHByZXNzaW9uLnR5cGVdKG5vZGUuZXhwcmVzc2lvbiwgc3RhdGUpXG4gIH0sXG4gIE1lbWJlckV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUub2JqZWN0LnR5cGVdXG4gICAgaWYgKFxuICAgICAgcHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMgfHxcbiAgICAgIHByZWNlZGVuY2UgPCBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuTWVtYmVyRXhwcmVzc2lvblxuICAgICkge1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpc1tub2RlLm9iamVjdC50eXBlXShub2RlLm9iamVjdCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbm9kZS5vYmplY3QudHlwZV0obm9kZS5vYmplY3QsIHN0YXRlKVxuICAgIH1cbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJz8uJylcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICAgIHRoaXNbbm9kZS5wcm9wZXJ0eS50eXBlXShub2RlLnByb3BlcnR5LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCddJylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJz8uJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCcuJylcbiAgICAgIH1cbiAgICAgIHRoaXNbbm9kZS5wcm9wZXJ0eS50eXBlXShub2RlLnByb3BlcnR5LCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIE1ldGFQcm9wZXJ0eShub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKG5vZGUubWV0YS5uYW1lICsgJy4nICsgbm9kZS5wcm9wZXJ0eS5uYW1lLCBub2RlKVxuICB9LFxuICBJZGVudGlmaWVyKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS5uYW1lLCBub2RlKVxuICB9LFxuICBQcml2YXRlSWRlbnRpZmllcihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKGAjJHtub2RlLm5hbWV9YCwgbm9kZSlcbiAgfSxcbiAgTGl0ZXJhbChub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnJhdyAhPSBudWxsKSB7XG4gICAgICAvLyBOb24tc3RhbmRhcmQgcHJvcGVydHlcbiAgICAgIHN0YXRlLndyaXRlKG5vZGUucmF3LCBub2RlKVxuICAgIH0gZWxzZSBpZiAobm9kZS5yZWdleCAhPSBudWxsKSB7XG4gICAgICB0aGlzLlJlZ0V4cExpdGVyYWwobm9kZSwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChub2RlLmJpZ2ludCAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZShub2RlLmJpZ2ludCArICduJywgbm9kZSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUud3JpdGUoc3RyaW5naWZ5KG5vZGUudmFsdWUpLCBub2RlKVxuICAgIH1cbiAgfSxcbiAgUmVnRXhwTGl0ZXJhbChub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IHsgcmVnZXggfSA9IG5vZGVcbiAgICBzdGF0ZS53cml0ZShgLyR7cmVnZXgucGF0dGVybn0vJHtyZWdleC5mbGFnc31gLCBub2RlKVxuICB9LFxufVxuXG5jb25zdCBFTVBUWV9PQkpFQ1QgPSB7fVxuXG4vKlxuREVQUkVDQVRFRDogQWx0ZXJuYXRlIGV4cG9ydCBvZiBgR0VORVJBVE9SYC5cbiovXG5leHBvcnQgY29uc3QgYmFzZUdlbmVyYXRvciA9IEdFTkVSQVRPUlxuXG5jbGFzcyBTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzZXR1cCA9IG9wdGlvbnMgPT0gbnVsbCA/IEVNUFRZX09CSkVDVCA6IG9wdGlvbnNcbiAgICB0aGlzLm91dHB1dCA9ICcnXG4gICAgLy8gRnVuY3Rpb25hbCBvcHRpb25zXG4gICAgaWYgKHNldHVwLm91dHB1dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLm91dHB1dCA9IHNldHVwLm91dHB1dFxuICAgICAgdGhpcy53cml0ZSA9IHRoaXMud3JpdGVUb1N0cmVhbVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm91dHB1dCA9ICcnXG4gICAgfVxuICAgIHRoaXMuZ2VuZXJhdG9yID0gc2V0dXAuZ2VuZXJhdG9yICE9IG51bGwgPyBzZXR1cC5nZW5lcmF0b3IgOiBHRU5FUkFUT1JcbiAgICB0aGlzLmV4cHJlc3Npb25zUHJlY2VkZW5jZSA9XG4gICAgICBzZXR1cC5leHByZXNzaW9uc1ByZWNlZGVuY2UgIT0gbnVsbFxuICAgICAgICA/IHNldHVwLmV4cHJlc3Npb25zUHJlY2VkZW5jZVxuICAgICAgICA6IEVYUFJFU1NJT05TX1BSRUNFREVOQ0VcbiAgICAvLyBGb3JtYXRpbmcgc2V0dXBcbiAgICB0aGlzLmluZGVudCA9IHNldHVwLmluZGVudCAhPSBudWxsID8gc2V0dXAuaW5kZW50IDogJyAgJ1xuICAgIHRoaXMubGluZUVuZCA9IHNldHVwLmxpbmVFbmQgIT0gbnVsbCA/IHNldHVwLmxpbmVFbmQgOiAnXFxuJ1xuICAgIHRoaXMuaW5kZW50TGV2ZWwgPVxuICAgICAgc2V0dXAuc3RhcnRpbmdJbmRlbnRMZXZlbCAhPSBudWxsID8gc2V0dXAuc3RhcnRpbmdJbmRlbnRMZXZlbCA6IDBcbiAgICB0aGlzLndyaXRlQ29tbWVudHMgPSBzZXR1cC5jb21tZW50cyA/IHNldHVwLmNvbW1lbnRzIDogZmFsc2VcbiAgICAvLyBTb3VyY2UgbWFwXG4gICAgaWYgKHNldHVwLnNvdXJjZU1hcCAhPSBudWxsKSB7XG4gICAgICB0aGlzLndyaXRlID1cbiAgICAgICAgc2V0dXAub3V0cHV0ID09IG51bGwgPyB0aGlzLndyaXRlQW5kTWFwIDogdGhpcy53cml0ZVRvU3RyZWFtQW5kTWFwXG4gICAgICB0aGlzLnNvdXJjZU1hcCA9IHNldHVwLnNvdXJjZU1hcFxuICAgICAgdGhpcy5saW5lID0gMVxuICAgICAgdGhpcy5jb2x1bW4gPSAwXG4gICAgICB0aGlzLmxpbmVFbmRTaXplID0gdGhpcy5saW5lRW5kLnNwbGl0KCdcXG4nKS5sZW5ndGggLSAxXG4gICAgICB0aGlzLm1hcHBpbmcgPSB7XG4gICAgICAgIG9yaWdpbmFsOiBudWxsLFxuICAgICAgICAvLyBVc2VzIHRoZSBlbnRpcmUgc3RhdGUgdG8gYXZvaWQgZ2VuZXJhdGluZyBlcGhlbWVyYWwgb2JqZWN0c1xuICAgICAgICBnZW5lcmF0ZWQ6IHRoaXMsXG4gICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgc291cmNlOiBzZXR1cC5zb3VyY2VNYXAuZmlsZSB8fCBzZXR1cC5zb3VyY2VNYXAuX2ZpbGUsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd3JpdGUoY29kZSkge1xuICAgIHRoaXMub3V0cHV0ICs9IGNvZGVcbiAgfVxuXG4gIHdyaXRlVG9TdHJlYW0oY29kZSkge1xuICAgIHRoaXMub3V0cHV0LndyaXRlKGNvZGUpXG4gIH1cblxuICB3cml0ZUFuZE1hcChjb2RlLCBub2RlKSB7XG4gICAgdGhpcy5vdXRwdXQgKz0gY29kZVxuICAgIHRoaXMubWFwKGNvZGUsIG5vZGUpXG4gIH1cblxuICB3cml0ZVRvU3RyZWFtQW5kTWFwKGNvZGUsIG5vZGUpIHtcbiAgICB0aGlzLm91dHB1dC53cml0ZShjb2RlKVxuICAgIHRoaXMubWFwKGNvZGUsIG5vZGUpXG4gIH1cblxuICBtYXAoY29kZSwgbm9kZSkge1xuICAgIGlmIChub2RlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgdHlwZSB9ID0gbm9kZVxuICAgICAgaWYgKHR5cGVbMF0gPT09ICdMJyAmJiB0eXBlWzJdID09PSAnbicpIHtcbiAgICAgICAgLy8gTGluZUNvbW1lbnRcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwXG4gICAgICAgIHRoaXMubGluZSsrXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKG5vZGUubG9jICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBtYXBwaW5nIH0gPSB0aGlzXG4gICAgICAgIG1hcHBpbmcub3JpZ2luYWwgPSBub2RlLmxvYy5zdGFydFxuICAgICAgICBtYXBwaW5nLm5hbWUgPSBub2RlLm5hbWVcbiAgICAgICAgdGhpcy5zb3VyY2VNYXAuYWRkTWFwcGluZyhtYXBwaW5nKVxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAodHlwZVswXSA9PT0gJ1QnICYmIHR5cGVbOF0gPT09ICdFJykgfHxcbiAgICAgICAgKHR5cGVbMF0gPT09ICdMJyAmJiB0eXBlWzFdID09PSAnaScgJiYgdHlwZW9mIG5vZGUudmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgKSB7XG4gICAgICAgIC8vIFRlbXBsYXRlRWxlbWVudCBvciBMaXRlcmFsIHN0cmluZyBub2RlXG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBjb2RlXG4gICAgICAgIGxldCB7IGNvbHVtbiwgbGluZSB9ID0gdGhpc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNvZGVbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSAwXG4gICAgICAgICAgICBsaW5lKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sdW1uKytcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW5cbiAgICAgICAgdGhpcy5saW5lID0gbGluZVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGNvZGVcbiAgICBjb25zdCB7IGxpbmVFbmQgfSA9IHRoaXNcbiAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmxpbmVFbmRTaXplID4gMCAmJlxuICAgICAgICAobGluZUVuZC5sZW5ndGggPT09IDFcbiAgICAgICAgICA/IGNvZGVbbGVuZ3RoIC0gMV0gPT09IGxpbmVFbmRcbiAgICAgICAgICA6IGNvZGUuZW5kc1dpdGgobGluZUVuZCkpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5saW5lICs9IHRoaXMubGluZUVuZFNpemVcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbHVtbiArPSBsZW5ndGhcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGUobm9kZSwgb3B0aW9ucykge1xuICAvKlxuICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcmVuZGVyZWQgY29kZSBvZiB0aGUgcHJvdmlkZWQgQVNUIGBub2RlYC5cbiAgVGhlIGBvcHRpb25zYCBhcmU6XG5cbiAgLSBgaW5kZW50YDogc3RyaW5nIHRvIHVzZSBmb3IgaW5kZW50YXRpb24gKGRlZmF1bHRzIHRvIGDikKPikKNgKVxuICAtIGBsaW5lRW5kYDogc3RyaW5nIHRvIHVzZSBmb3IgbGluZSBlbmRpbmdzIChkZWZhdWx0cyB0byBgXFxuYClcbiAgLSBgc3RhcnRpbmdJbmRlbnRMZXZlbGA6IGluZGVudCBsZXZlbCB0byBzdGFydCBmcm9tIChkZWZhdWx0cyB0byBgMGApXG4gIC0gYGNvbW1lbnRzYDogZ2VuZXJhdGUgY29tbWVudHMgaWYgYHRydWVgIChkZWZhdWx0cyB0byBgZmFsc2VgKVxuICAtIGBvdXRwdXRgOiBvdXRwdXQgc3RyZWFtIHRvIHdyaXRlIHRoZSByZW5kZXJlZCBjb2RlIHRvIChkZWZhdWx0cyB0byBgbnVsbGApXG4gIC0gYGdlbmVyYXRvcmA6IGN1c3RvbSBjb2RlIGdlbmVyYXRvciAoZGVmYXVsdHMgdG8gYEdFTkVSQVRPUmApXG4gIC0gYGV4cHJlc3Npb25zUHJlY2VkZW5jZWA6IGN1c3RvbSBtYXAgb2Ygbm9kZSB0eXBlcyBhbmQgdGhlaXIgcHJlY2VkZW5jZSBsZXZlbCAoZGVmYXVsdHMgdG8gYEVYUFJFU1NJT05TX1BSRUNFREVOQ0VgKVxuICAqL1xuICBjb25zdCBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKVxuICAvLyBUcmF2ZWwgdGhyb3VnaCB0aGUgQVNUIG5vZGUgYW5kIGdlbmVyYXRlIHRoZSBjb2RlXG4gIHN0YXRlLmdlbmVyYXRvcltub2RlLnR5cGVdKG5vZGUsIHN0YXRlKVxuICByZXR1cm4gc3RhdGUub3V0cHV0XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/astring@1.8.6/node_modules/astring/dist/astring.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/astring@1.8.6/node_modules/astring/dist/astring.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/astring@1.8.6/node_modules/astring/dist/astring.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXPRESSIONS_PRECEDENCE: () => (/* binding */ EXPRESSIONS_PRECEDENCE),\n/* harmony export */   GENERATOR: () => (/* binding */ GENERATOR),\n/* harmony export */   NEEDS_PARENTHESES: () => (/* binding */ NEEDS_PARENTHESES),\n/* harmony export */   baseGenerator: () => (/* binding */ baseGenerator),\n/* harmony export */   generate: () => (/* binding */ generate)\n/* harmony export */ });\n// Astring is a tiny and fast JavaScript code generator from an ESTree-compliant AST.\n//\n// Astring was written by David Bonnet and released under an MIT license.\n//\n// The Git repository for Astring is available at:\n// https://github.com/davidbonnet/astring.git\n//\n// Please use the GitHub bug tracker to report issues:\n// https://github.com/davidbonnet/astring/issues\n\nconst { stringify } = JSON\n\n/* c8 ignore if */\nif (!String.prototype.repeat) {\n  /* c8 ignore next */\n  throw new Error(\n    'String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation',\n  )\n}\n\n/* c8 ignore if */\nif (!String.prototype.endsWith) {\n  /* c8 ignore next */\n  throw new Error(\n    'String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation',\n  )\n}\n\nconst OPERATOR_PRECEDENCE = {\n  '||': 2,\n  '??': 3,\n  '&&': 4,\n  '|': 5,\n  '^': 6,\n  '&': 7,\n  '==': 8,\n  '!=': 8,\n  '===': 8,\n  '!==': 8,\n  '<': 9,\n  '>': 9,\n  '<=': 9,\n  '>=': 9,\n  in: 9,\n  instanceof: 9,\n  '<<': 10,\n  '>>': 10,\n  '>>>': 10,\n  '+': 11,\n  '-': 11,\n  '*': 12,\n  '%': 12,\n  '/': 12,\n  '**': 13,\n}\n\n// Enables parenthesis regardless of precedence\nconst NEEDS_PARENTHESES = 17\n\nconst EXPRESSIONS_PRECEDENCE = {\n  // Definitions\n  ArrayExpression: 20,\n  TaggedTemplateExpression: 20,\n  ThisExpression: 20,\n  Identifier: 20,\n  PrivateIdentifier: 20,\n  Literal: 18,\n  TemplateLiteral: 20,\n  Super: 20,\n  SequenceExpression: 20,\n  // Operations\n  MemberExpression: 19,\n  ChainExpression: 19,\n  CallExpression: 19,\n  NewExpression: 19,\n  // Other definitions\n  ArrowFunctionExpression: NEEDS_PARENTHESES,\n  ClassExpression: NEEDS_PARENTHESES,\n  FunctionExpression: NEEDS_PARENTHESES,\n  ObjectExpression: NEEDS_PARENTHESES,\n  // Other operations\n  UpdateExpression: 16,\n  UnaryExpression: 15,\n  AwaitExpression: 15,\n  BinaryExpression: 14,\n  LogicalExpression: 13,\n  ConditionalExpression: 4,\n  AssignmentExpression: 3,\n  YieldExpression: 2,\n  RestElement: 1,\n}\n\nfunction formatSequence(state, nodes) {\n  /*\n  Writes into `state` a sequence of `nodes`.\n  */\n  const { generator } = state\n  state.write('(')\n  if (nodes != null && nodes.length > 0) {\n    generator[nodes[0].type](nodes[0], state)\n    const { length } = nodes\n    for (let i = 1; i < length; i++) {\n      const param = nodes[i]\n      state.write(', ')\n      generator[param.type](param, state)\n    }\n  }\n  state.write(')')\n}\n\nfunction expressionNeedsParenthesis(state, node, parentNode, isRightHand) {\n  const nodePrecedence = state.expressionsPrecedence[node.type]\n  if (nodePrecedence === NEEDS_PARENTHESES) {\n    return true\n  }\n  const parentNodePrecedence = state.expressionsPrecedence[parentNode.type]\n  if (nodePrecedence !== parentNodePrecedence) {\n    // Different node types\n    return (\n      (!isRightHand &&\n        nodePrecedence === 15 &&\n        parentNodePrecedence === 14 &&\n        parentNode.operator === '**') ||\n      nodePrecedence < parentNodePrecedence\n    )\n  }\n  if (nodePrecedence !== 13 && nodePrecedence !== 14) {\n    // Not a `LogicalExpression` or `BinaryExpression`\n    return false\n  }\n  if (node.operator === '**' && parentNode.operator === '**') {\n    // Exponentiation operator has right-to-left associativity\n    return !isRightHand\n  }\n  if (\n    nodePrecedence === 13 &&\n    parentNodePrecedence === 13 &&\n    (node.operator === '??' || parentNode.operator === '??')\n  ) {\n    // Nullish coalescing and boolean operators cannot be combined\n    return true\n  }\n  if (isRightHand) {\n    // Parenthesis are used if both operators have the same precedence\n    return (\n      OPERATOR_PRECEDENCE[node.operator] <=\n      OPERATOR_PRECEDENCE[parentNode.operator]\n    )\n  }\n  return (\n    OPERATOR_PRECEDENCE[node.operator] <\n    OPERATOR_PRECEDENCE[parentNode.operator]\n  )\n}\n\nfunction formatExpression(state, node, parentNode, isRightHand) {\n  /*\n  Writes into `state` the provided `node`, adding parenthesis around if the provided `parentNode` needs it. If `node` is a right-hand argument, the provided `isRightHand` parameter should be `true`.\n  */\n  const { generator } = state\n  if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {\n    state.write('(')\n    generator[node.type](node, state)\n    state.write(')')\n  } else {\n    generator[node.type](node, state)\n  }\n}\n\nfunction reindent(state, text, indent, lineEnd) {\n  /*\n  Writes into `state` the `text` string reindented with the provided `indent`.\n  */\n  const lines = text.split('\\n')\n  const end = lines.length - 1\n  state.write(lines[0].trim())\n  if (end > 0) {\n    state.write(lineEnd)\n    for (let i = 1; i < end; i++) {\n      state.write(indent + lines[i].trim() + lineEnd)\n    }\n    state.write(indent + lines[end].trim())\n  }\n}\n\nfunction formatComments(state, comments, indent, lineEnd) {\n  /*\n  Writes into `state` the provided list of `comments`, with the given `indent` and `lineEnd` strings.\n  Line comments will end with `\"\\n\"` regardless of the value of `lineEnd`.\n  Expects to start on a new unindented line.\n  */\n  const { length } = comments\n  for (let i = 0; i < length; i++) {\n    const comment = comments[i]\n    state.write(indent)\n    if (comment.type[0] === 'L') {\n      // Line comment\n      state.write('// ' + comment.value.trim() + '\\n', comment)\n    } else {\n      // Block comment\n      state.write('/*')\n      reindent(state, comment.value, indent, lineEnd)\n      state.write('*/' + lineEnd)\n    }\n  }\n}\n\nfunction hasCallExpression(node) {\n  /*\n  Returns `true` if the provided `node` contains a call expression and `false` otherwise.\n  */\n  let currentNode = node\n  while (currentNode != null) {\n    const { type } = currentNode\n    if (type[0] === 'C' && type[1] === 'a') {\n      // Is CallExpression\n      return true\n    } else if (type[0] === 'M' && type[1] === 'e' && type[2] === 'm') {\n      // Is MemberExpression\n      currentNode = currentNode.object\n    } else {\n      return false\n    }\n  }\n}\n\nfunction formatVariableDeclaration(state, node) {\n  /*\n  Writes into `state` a variable declaration.\n  */\n  const { generator } = state\n  const { declarations } = node\n  state.write(node.kind + ' ')\n  const { length } = declarations\n  if (length > 0) {\n    generator.VariableDeclarator(declarations[0], state)\n    for (let i = 1; i < length; i++) {\n      state.write(', ')\n      generator.VariableDeclarator(declarations[i], state)\n    }\n  }\n}\n\nlet ForInStatement,\n  FunctionDeclaration,\n  RestElement,\n  BinaryExpression,\n  ArrayExpression,\n  BlockStatement\n\nconst GENERATOR = {\n  /*\n  Default generator.\n  */\n  Program(node, state) {\n    const indent = state.indent.repeat(state.indentLevel)\n    const { lineEnd, writeComments } = state\n    if (writeComments && node.comments != null) {\n      formatComments(state, node.comments, indent, lineEnd)\n    }\n    const statements = node.body\n    const { length } = statements\n    for (let i = 0; i < length; i++) {\n      const statement = statements[i]\n      if (writeComments && statement.comments != null) {\n        formatComments(state, statement.comments, indent, lineEnd)\n      }\n      state.write(indent)\n      this[statement.type](statement, state)\n      state.write(lineEnd)\n    }\n    if (writeComments && node.trailingComments != null) {\n      formatComments(state, node.trailingComments, indent, lineEnd)\n    }\n  },\n  BlockStatement: (BlockStatement = function (node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    const statementIndent = indent + state.indent\n    state.write('{')\n    const statements = node.body\n    if (statements != null && statements.length > 0) {\n      state.write(lineEnd)\n      if (writeComments && node.comments != null) {\n        formatComments(state, node.comments, statementIndent, lineEnd)\n      }\n      const { length } = statements\n      for (let i = 0; i < length; i++) {\n        const statement = statements[i]\n        if (writeComments && statement.comments != null) {\n          formatComments(state, statement.comments, statementIndent, lineEnd)\n        }\n        state.write(statementIndent)\n        this[statement.type](statement, state)\n        state.write(lineEnd)\n      }\n      state.write(indent)\n    } else {\n      if (writeComments && node.comments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.comments, statementIndent, lineEnd)\n        state.write(indent)\n      }\n    }\n    if (writeComments && node.trailingComments != null) {\n      formatComments(state, node.trailingComments, statementIndent, lineEnd)\n    }\n    state.write('}')\n    state.indentLevel--\n  }),\n  ClassBody: BlockStatement,\n  StaticBlock(node, state) {\n    state.write('static ')\n    this.BlockStatement(node, state)\n  },\n  EmptyStatement(node, state) {\n    state.write(';')\n  },\n  ExpressionStatement(node, state) {\n    const precedence = state.expressionsPrecedence[node.expression.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      (precedence === 3 && node.expression.left.type[0] === 'O')\n    ) {\n      // Should always have parentheses or is an AssignmentExpression to an ObjectPattern\n      state.write('(')\n      this[node.expression.type](node.expression, state)\n      state.write(')')\n    } else {\n      this[node.expression.type](node.expression, state)\n    }\n    state.write(';')\n  },\n  IfStatement(node, state) {\n    state.write('if (')\n    this[node.test.type](node.test, state)\n    state.write(') ')\n    this[node.consequent.type](node.consequent, state)\n    if (node.alternate != null) {\n      state.write(' else ')\n      this[node.alternate.type](node.alternate, state)\n    }\n  },\n  LabeledStatement(node, state) {\n    this[node.label.type](node.label, state)\n    state.write(': ')\n    this[node.body.type](node.body, state)\n  },\n  BreakStatement(node, state) {\n    state.write('break')\n    if (node.label != null) {\n      state.write(' ')\n      this[node.label.type](node.label, state)\n    }\n    state.write(';')\n  },\n  ContinueStatement(node, state) {\n    state.write('continue')\n    if (node.label != null) {\n      state.write(' ')\n      this[node.label.type](node.label, state)\n    }\n    state.write(';')\n  },\n  WithStatement(node, state) {\n    state.write('with (')\n    this[node.object.type](node.object, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  SwitchStatement(node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    state.indentLevel++\n    const caseIndent = indent + state.indent\n    const statementIndent = caseIndent + state.indent\n    state.write('switch (')\n    this[node.discriminant.type](node.discriminant, state)\n    state.write(') {' + lineEnd)\n    const { cases: occurences } = node\n    const { length: occurencesCount } = occurences\n    for (let i = 0; i < occurencesCount; i++) {\n      const occurence = occurences[i]\n      if (writeComments && occurence.comments != null) {\n        formatComments(state, occurence.comments, caseIndent, lineEnd)\n      }\n      if (occurence.test) {\n        state.write(caseIndent + 'case ')\n        this[occurence.test.type](occurence.test, state)\n        state.write(':' + lineEnd)\n      } else {\n        state.write(caseIndent + 'default:' + lineEnd)\n      }\n      const { consequent } = occurence\n      const { length: consequentCount } = consequent\n      for (let i = 0; i < consequentCount; i++) {\n        const statement = consequent[i]\n        if (writeComments && statement.comments != null) {\n          formatComments(state, statement.comments, statementIndent, lineEnd)\n        }\n        state.write(statementIndent)\n        this[statement.type](statement, state)\n        state.write(lineEnd)\n      }\n    }\n    state.indentLevel -= 2\n    state.write(indent + '}')\n  },\n  ReturnStatement(node, state) {\n    state.write('return')\n    if (node.argument) {\n      state.write(' ')\n      this[node.argument.type](node.argument, state)\n    }\n    state.write(';')\n  },\n  ThrowStatement(node, state) {\n    state.write('throw ')\n    this[node.argument.type](node.argument, state)\n    state.write(';')\n  },\n  TryStatement(node, state) {\n    state.write('try ')\n    this[node.block.type](node.block, state)\n    if (node.handler) {\n      const { handler } = node\n      if (handler.param == null) {\n        state.write(' catch ')\n      } else {\n        state.write(' catch (')\n        this[handler.param.type](handler.param, state)\n        state.write(') ')\n      }\n      this[handler.body.type](handler.body, state)\n    }\n    if (node.finalizer) {\n      state.write(' finally ')\n      this[node.finalizer.type](node.finalizer, state)\n    }\n  },\n  WhileStatement(node, state) {\n    state.write('while (')\n    this[node.test.type](node.test, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  DoWhileStatement(node, state) {\n    state.write('do ')\n    this[node.body.type](node.body, state)\n    state.write(' while (')\n    this[node.test.type](node.test, state)\n    state.write(');')\n  },\n  ForStatement(node, state) {\n    state.write('for (')\n    if (node.init != null) {\n      const { init } = node\n      if (init.type[0] === 'V') {\n        formatVariableDeclaration(state, init)\n      } else {\n        this[init.type](init, state)\n      }\n    }\n    state.write('; ')\n    if (node.test) {\n      this[node.test.type](node.test, state)\n    }\n    state.write('; ')\n    if (node.update) {\n      this[node.update.type](node.update, state)\n    }\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  ForInStatement: (ForInStatement = function (node, state) {\n    state.write(`for ${node.await ? 'await ' : ''}(`)\n    const { left } = node\n    if (left.type[0] === 'V') {\n      formatVariableDeclaration(state, left)\n    } else {\n      this[left.type](left, state)\n    }\n    // Identifying whether node.type is `ForInStatement` or `ForOfStatement`\n    state.write(node.type[3] === 'I' ? ' in ' : ' of ')\n    this[node.right.type](node.right, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  }),\n  ForOfStatement: ForInStatement,\n  DebuggerStatement(node, state) {\n    state.write('debugger;', node)\n  },\n  FunctionDeclaration: (FunctionDeclaration = function (node, state) {\n    state.write(\n      (node.async ? 'async ' : '') +\n        (node.generator ? 'function* ' : 'function ') +\n        (node.id ? node.id.name : ''),\n      node,\n    )\n    formatSequence(state, node.params)\n    state.write(' ')\n    this[node.body.type](node.body, state)\n  }),\n  FunctionExpression: FunctionDeclaration,\n  VariableDeclaration(node, state) {\n    formatVariableDeclaration(state, node)\n    state.write(';')\n  },\n  VariableDeclarator(node, state) {\n    this[node.id.type](node.id, state)\n    if (node.init != null) {\n      state.write(' = ')\n      this[node.init.type](node.init, state)\n    }\n  },\n  ClassDeclaration(node, state) {\n    state.write('class ' + (node.id ? `${node.id.name} ` : ''), node)\n    if (node.superClass) {\n      state.write('extends ')\n      const { superClass } = node\n      const { type } = superClass\n      const precedence = state.expressionsPrecedence[type]\n      if (\n        (type[0] !== 'C' || type[1] !== 'l' || type[5] !== 'E') &&\n        (precedence === NEEDS_PARENTHESES ||\n          precedence < state.expressionsPrecedence.ClassExpression)\n      ) {\n        // Not a ClassExpression that needs parentheses\n        state.write('(')\n        this[node.superClass.type](superClass, state)\n        state.write(')')\n      } else {\n        this[superClass.type](superClass, state)\n      }\n      state.write(' ')\n    }\n    this.ClassBody(node.body, state)\n  },\n  ImportDeclaration(node, state) {\n    state.write('import ')\n    const { specifiers } = node\n    const { length } = specifiers\n    // TODO: Once babili is fixed, put this after condition\n    // https://github.com/babel/babili/issues/430\n    let i = 0\n    if (length > 0) {\n      for (; i < length; ) {\n        if (i > 0) {\n          state.write(', ')\n        }\n        const specifier = specifiers[i]\n        const type = specifier.type[6]\n        if (type === 'D') {\n          // ImportDefaultSpecifier\n          state.write(specifier.local.name, specifier)\n          i++\n        } else if (type === 'N') {\n          // ImportNamespaceSpecifier\n          state.write('* as ' + specifier.local.name, specifier)\n          i++\n        } else {\n          // ImportSpecifier\n          break\n        }\n      }\n      if (i < length) {\n        state.write('{')\n        for (;;) {\n          const specifier = specifiers[i]\n          const { name } = specifier.imported\n          state.write(name, specifier)\n          if (name !== specifier.local.name) {\n            state.write(' as ' + specifier.local.name)\n          }\n          if (++i < length) {\n            state.write(', ')\n          } else {\n            break\n          }\n        }\n        state.write('}')\n      }\n      state.write(' from ')\n    }\n    this.Literal(node.source, state)\n    state.write(';')\n  },\n  ImportExpression(node, state) {\n    state.write('import(')\n    this[node.source.type](node.source, state)\n    state.write(')')\n  },\n  ExportDefaultDeclaration(node, state) {\n    state.write('export default ')\n    this[node.declaration.type](node.declaration, state)\n    if (\n      state.expressionsPrecedence[node.declaration.type] != null &&\n      node.declaration.type[0] !== 'F'\n    ) {\n      // All expression nodes except `FunctionExpression`\n      state.write(';')\n    }\n  },\n  ExportNamedDeclaration(node, state) {\n    state.write('export ')\n    if (node.declaration) {\n      this[node.declaration.type](node.declaration, state)\n    } else {\n      state.write('{')\n      const { specifiers } = node,\n        { length } = specifiers\n      if (length > 0) {\n        for (let i = 0; ; ) {\n          const specifier = specifiers[i]\n          const { name } = specifier.local\n          state.write(name, specifier)\n          if (name !== specifier.exported.name) {\n            state.write(' as ' + specifier.exported.name)\n          }\n          if (++i < length) {\n            state.write(', ')\n          } else {\n            break\n          }\n        }\n      }\n      state.write('}')\n      if (node.source) {\n        state.write(' from ')\n        this.Literal(node.source, state)\n      }\n      state.write(';')\n    }\n  },\n  ExportAllDeclaration(node, state) {\n    if (node.exported != null) {\n      state.write('export * as ' + node.exported.name + ' from ')\n    } else {\n      state.write('export * from ')\n    }\n    this.Literal(node.source, state)\n    state.write(';')\n  },\n  MethodDefinition(node, state) {\n    if (node.static) {\n      state.write('static ')\n    }\n    const kind = node.kind[0]\n    if (kind === 'g' || kind === 's') {\n      // Getter or setter\n      state.write(node.kind + ' ')\n    }\n    if (node.value.async) {\n      state.write('async ')\n    }\n    if (node.value.generator) {\n      state.write('*')\n    }\n    if (node.computed) {\n      state.write('[')\n      this[node.key.type](node.key, state)\n      state.write(']')\n    } else {\n      this[node.key.type](node.key, state)\n    }\n    formatSequence(state, node.value.params)\n    state.write(' ')\n    this[node.value.body.type](node.value.body, state)\n  },\n  ClassExpression(node, state) {\n    this.ClassDeclaration(node, state)\n  },\n  ArrowFunctionExpression(node, state) {\n    state.write(node.async ? 'async ' : '', node)\n    const { params } = node\n    if (params != null) {\n      // Omit parenthesis if only one named parameter\n      if (params.length === 1 && params[0].type[0] === 'I') {\n        // If params[0].type[0] starts with 'I', it can't be `ImportDeclaration` nor `IfStatement` and thus is `Identifier`\n        state.write(params[0].name, params[0])\n      } else {\n        formatSequence(state, node.params)\n      }\n    }\n    state.write(' => ')\n    if (node.body.type[0] === 'O') {\n      // Body is an object expression\n      state.write('(')\n      this.ObjectExpression(node.body, state)\n      state.write(')')\n    } else {\n      this[node.body.type](node.body, state)\n    }\n  },\n  ThisExpression(node, state) {\n    state.write('this', node)\n  },\n  Super(node, state) {\n    state.write('super', node)\n  },\n  RestElement: (RestElement = function (node, state) {\n    state.write('...')\n    this[node.argument.type](node.argument, state)\n  }),\n  SpreadElement: RestElement,\n  YieldExpression(node, state) {\n    state.write(node.delegate ? 'yield*' : 'yield')\n    if (node.argument) {\n      state.write(' ')\n      this[node.argument.type](node.argument, state)\n    }\n  },\n  AwaitExpression(node, state) {\n    state.write('await ', node)\n    formatExpression(state, node.argument, node)\n  },\n  TemplateLiteral(node, state) {\n    const { quasis, expressions } = node\n    state.write('`')\n    const { length } = expressions\n    for (let i = 0; i < length; i++) {\n      const expression = expressions[i]\n      const quasi = quasis[i]\n      state.write(quasi.value.raw, quasi)\n      state.write('${')\n      this[expression.type](expression, state)\n      state.write('}')\n    }\n    const quasi = quasis[quasis.length - 1]\n    state.write(quasi.value.raw, quasi)\n    state.write('`')\n  },\n  TemplateElement(node, state) {\n    state.write(node.value.raw, node)\n  },\n  TaggedTemplateExpression(node, state) {\n    formatExpression(state, node.tag, node)\n    this[node.quasi.type](node.quasi, state)\n  },\n  ArrayExpression: (ArrayExpression = function (node, state) {\n    state.write('[')\n    if (node.elements.length > 0) {\n      const { elements } = node,\n        { length } = elements\n      for (let i = 0; ; ) {\n        const element = elements[i]\n        if (element != null) {\n          this[element.type](element, state)\n        }\n        if (++i < length) {\n          state.write(', ')\n        } else {\n          if (element == null) {\n            state.write(', ')\n          }\n          break\n        }\n      }\n    }\n    state.write(']')\n  }),\n  ArrayPattern: ArrayExpression,\n  ObjectExpression(node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    const propertyIndent = indent + state.indent\n    state.write('{')\n    if (node.properties.length > 0) {\n      state.write(lineEnd)\n      if (writeComments && node.comments != null) {\n        formatComments(state, node.comments, propertyIndent, lineEnd)\n      }\n      const comma = ',' + lineEnd\n      const { properties } = node,\n        { length } = properties\n      for (let i = 0; ; ) {\n        const property = properties[i]\n        if (writeComments && property.comments != null) {\n          formatComments(state, property.comments, propertyIndent, lineEnd)\n        }\n        state.write(propertyIndent)\n        this[property.type](property, state)\n        if (++i < length) {\n          state.write(comma)\n        } else {\n          break\n        }\n      }\n      state.write(lineEnd)\n      if (writeComments && node.trailingComments != null) {\n        formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n      }\n      state.write(indent + '}')\n    } else if (writeComments) {\n      if (node.comments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.comments, propertyIndent, lineEnd)\n        if (node.trailingComments != null) {\n          formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n        }\n        state.write(indent + '}')\n      } else if (node.trailingComments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n        state.write(indent + '}')\n      } else {\n        state.write('}')\n      }\n    } else {\n      state.write('}')\n    }\n    state.indentLevel--\n  },\n  Property(node, state) {\n    if (node.method || node.kind[0] !== 'i') {\n      // Either a method or of kind `set` or `get` (not `init`)\n      this.MethodDefinition(node, state)\n    } else {\n      if (!node.shorthand) {\n        if (node.computed) {\n          state.write('[')\n          this[node.key.type](node.key, state)\n          state.write(']')\n        } else {\n          this[node.key.type](node.key, state)\n        }\n        state.write(': ')\n      }\n      this[node.value.type](node.value, state)\n    }\n  },\n  PropertyDefinition(node, state) {\n    if (node.static) {\n      state.write('static ')\n    }\n    if (node.computed) {\n      state.write('[')\n    }\n    this[node.key.type](node.key, state)\n    if (node.computed) {\n      state.write(']')\n    }\n    if (node.value == null) {\n      if (node.key.type[0] !== 'F') {\n        state.write(';')\n      }\n      return\n    }\n    state.write(' = ')\n    this[node.value.type](node.value, state)\n    state.write(';')\n  },\n  ObjectPattern(node, state) {\n    state.write('{')\n    if (node.properties.length > 0) {\n      const { properties } = node,\n        { length } = properties\n      for (let i = 0; ; ) {\n        this[properties[i].type](properties[i], state)\n        if (++i < length) {\n          state.write(', ')\n        } else {\n          break\n        }\n      }\n    }\n    state.write('}')\n  },\n  SequenceExpression(node, state) {\n    formatSequence(state, node.expressions)\n  },\n  UnaryExpression(node, state) {\n    if (node.prefix) {\n      const {\n        operator,\n        argument,\n        argument: { type },\n      } = node\n      state.write(operator)\n      const needsParentheses = expressionNeedsParenthesis(state, argument, node)\n      if (\n        !needsParentheses &&\n        (operator.length > 1 ||\n          (type[0] === 'U' &&\n            (type[1] === 'n' || type[1] === 'p') &&\n            argument.prefix &&\n            argument.operator[0] === operator &&\n            (operator === '+' || operator === '-')))\n      ) {\n        // Large operator or argument is UnaryExpression or UpdateExpression node\n        state.write(' ')\n      }\n      if (needsParentheses) {\n        state.write(operator.length > 1 ? ' (' : '(')\n        this[type](argument, state)\n        state.write(')')\n      } else {\n        this[type](argument, state)\n      }\n    } else {\n      // FIXME: This case never occurs\n      this[node.argument.type](node.argument, state)\n      state.write(node.operator)\n    }\n  },\n  UpdateExpression(node, state) {\n    // Always applied to identifiers or members, no parenthesis check needed\n    if (node.prefix) {\n      state.write(node.operator)\n      this[node.argument.type](node.argument, state)\n    } else {\n      this[node.argument.type](node.argument, state)\n      state.write(node.operator)\n    }\n  },\n  AssignmentExpression(node, state) {\n    this[node.left.type](node.left, state)\n    state.write(' ' + node.operator + ' ')\n    this[node.right.type](node.right, state)\n  },\n  AssignmentPattern(node, state) {\n    this[node.left.type](node.left, state)\n    state.write(' = ')\n    this[node.right.type](node.right, state)\n  },\n  BinaryExpression: (BinaryExpression = function (node, state) {\n    const isIn = node.operator === 'in'\n    if (isIn) {\n      // Avoids confusion in `for` loops initializers\n      state.write('(')\n    }\n    formatExpression(state, node.left, node, false)\n    state.write(' ' + node.operator + ' ')\n    formatExpression(state, node.right, node, true)\n    if (isIn) {\n      state.write(')')\n    }\n  }),\n  LogicalExpression: BinaryExpression,\n  ConditionalExpression(node, state) {\n    const { test } = node\n    const precedence = state.expressionsPrecedence[test.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence <= state.expressionsPrecedence.ConditionalExpression\n    ) {\n      state.write('(')\n      this[test.type](test, state)\n      state.write(')')\n    } else {\n      this[test.type](test, state)\n    }\n    state.write(' ? ')\n    this[node.consequent.type](node.consequent, state)\n    state.write(' : ')\n    this[node.alternate.type](node.alternate, state)\n  },\n  NewExpression(node, state) {\n    state.write('new ')\n    const precedence = state.expressionsPrecedence[node.callee.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.CallExpression ||\n      hasCallExpression(node.callee)\n    ) {\n      state.write('(')\n      this[node.callee.type](node.callee, state)\n      state.write(')')\n    } else {\n      this[node.callee.type](node.callee, state)\n    }\n    formatSequence(state, node['arguments'])\n  },\n  CallExpression(node, state) {\n    const precedence = state.expressionsPrecedence[node.callee.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.CallExpression\n    ) {\n      state.write('(')\n      this[node.callee.type](node.callee, state)\n      state.write(')')\n    } else {\n      this[node.callee.type](node.callee, state)\n    }\n    if (node.optional) {\n      state.write('?.')\n    }\n    formatSequence(state, node['arguments'])\n  },\n  ChainExpression(node, state) {\n    this[node.expression.type](node.expression, state)\n  },\n  MemberExpression(node, state) {\n    const precedence = state.expressionsPrecedence[node.object.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.MemberExpression\n    ) {\n      state.write('(')\n      this[node.object.type](node.object, state)\n      state.write(')')\n    } else {\n      this[node.object.type](node.object, state)\n    }\n    if (node.computed) {\n      if (node.optional) {\n        state.write('?.')\n      }\n      state.write('[')\n      this[node.property.type](node.property, state)\n      state.write(']')\n    } else {\n      if (node.optional) {\n        state.write('?.')\n      } else {\n        state.write('.')\n      }\n      this[node.property.type](node.property, state)\n    }\n  },\n  MetaProperty(node, state) {\n    state.write(node.meta.name + '.' + node.property.name, node)\n  },\n  Identifier(node, state) {\n    state.write(node.name, node)\n  },\n  PrivateIdentifier(node, state) {\n    state.write(`#${node.name}`, node)\n  },\n  Literal(node, state) {\n    if (node.raw != null) {\n      // Non-standard property\n      state.write(node.raw, node)\n    } else if (node.regex != null) {\n      this.RegExpLiteral(node, state)\n    } else if (node.bigint != null) {\n      state.write(node.bigint + 'n', node)\n    } else {\n      state.write(stringify(node.value), node)\n    }\n  },\n  RegExpLiteral(node, state) {\n    const { regex } = node\n    state.write(`/${regex.pattern}/${regex.flags}`, node)\n  },\n}\n\nconst EMPTY_OBJECT = {}\n\n/*\nDEPRECATED: Alternate export of `GENERATOR`.\n*/\nconst baseGenerator = GENERATOR\n\nclass State {\n  constructor(options) {\n    const setup = options == null ? EMPTY_OBJECT : options\n    this.output = ''\n    // Functional options\n    if (setup.output != null) {\n      this.output = setup.output\n      this.write = this.writeToStream\n    } else {\n      this.output = ''\n    }\n    this.generator = setup.generator != null ? setup.generator : GENERATOR\n    this.expressionsPrecedence =\n      setup.expressionsPrecedence != null\n        ? setup.expressionsPrecedence\n        : EXPRESSIONS_PRECEDENCE\n    // Formating setup\n    this.indent = setup.indent != null ? setup.indent : '  '\n    this.lineEnd = setup.lineEnd != null ? setup.lineEnd : '\\n'\n    this.indentLevel =\n      setup.startingIndentLevel != null ? setup.startingIndentLevel : 0\n    this.writeComments = setup.comments ? setup.comments : false\n    // Source map\n    if (setup.sourceMap != null) {\n      this.write =\n        setup.output == null ? this.writeAndMap : this.writeToStreamAndMap\n      this.sourceMap = setup.sourceMap\n      this.line = 1\n      this.column = 0\n      this.lineEndSize = this.lineEnd.split('\\n').length - 1\n      this.mapping = {\n        original: null,\n        // Uses the entire state to avoid generating ephemeral objects\n        generated: this,\n        name: undefined,\n        source: setup.sourceMap.file || setup.sourceMap._file,\n      }\n    }\n  }\n\n  write(code) {\n    this.output += code\n  }\n\n  writeToStream(code) {\n    this.output.write(code)\n  }\n\n  writeAndMap(code, node) {\n    this.output += code\n    this.map(code, node)\n  }\n\n  writeToStreamAndMap(code, node) {\n    this.output.write(code)\n    this.map(code, node)\n  }\n\n  map(code, node) {\n    if (node != null) {\n      const { type } = node\n      if (type[0] === 'L' && type[2] === 'n') {\n        // LineComment\n        this.column = 0\n        this.line++\n        return\n      }\n      if (node.loc != null) {\n        const { mapping } = this\n        mapping.original = node.loc.start\n        mapping.name = node.name\n        this.sourceMap.addMapping(mapping)\n      }\n      if (\n        (type[0] === 'T' && type[8] === 'E') ||\n        (type[0] === 'L' && type[1] === 'i' && typeof node.value === 'string')\n      ) {\n        // TemplateElement or Literal string node\n        const { length } = code\n        let { column, line } = this\n        for (let i = 0; i < length; i++) {\n          if (code[i] === '\\n') {\n            column = 0\n            line++\n          } else {\n            column++\n          }\n        }\n        this.column = column\n        this.line = line\n        return\n      }\n    }\n    const { length } = code\n    const { lineEnd } = this\n    if (length > 0) {\n      if (\n        this.lineEndSize > 0 &&\n        (lineEnd.length === 1\n          ? code[length - 1] === lineEnd\n          : code.endsWith(lineEnd))\n      ) {\n        this.line += this.lineEndSize\n        this.column = 0\n      } else {\n        this.column += length\n      }\n    }\n  }\n\n  toString() {\n    return this.output\n  }\n}\n\nfunction generate(node, options) {\n  /*\n  Returns a string representing the rendered code of the provided AST `node`.\n  The `options` are:\n\n  - `indent`: string to use for indentation (defaults to `␣␣`)\n  - `lineEnd`: string to use for line endings (defaults to `\\n`)\n  - `startingIndentLevel`: indent level to start from (defaults to `0`)\n  - `comments`: generate comments if `true` (defaults to `false`)\n  - `output`: output stream to write the rendered code to (defaults to `null`)\n  - `generator`: custom code generator (defaults to `GENERATOR`)\n  - `expressionsPrecedence`: custom map of node types and their precedence level (defaults to `EXPRESSIONS_PRECEDENCE`)\n  */\n  const state = new State(options)\n  // Travel through the AST node and generate the code\n  state.generator[node.type](node, state)\n  return state.output\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vYXN0cmluZ0AxLjguNi9ub2RlX21vZHVsZXMvYXN0cmluZy9kaXN0L2FzdHJpbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsWUFBWTs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087O0FBRUE7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixjQUFjLGVBQWU7QUFDN0Isd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NibV8yMDI0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2FzdHJpbmdAMS44LjYvbm9kZV9tb2R1bGVzL2FzdHJpbmcvZGlzdC9hc3RyaW5nLm1qcz85YWQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFzdHJpbmcgaXMgYSB0aW55IGFuZCBmYXN0IEphdmFTY3JpcHQgY29kZSBnZW5lcmF0b3IgZnJvbSBhbiBFU1RyZWUtY29tcGxpYW50IEFTVC5cbi8vXG4vLyBBc3RyaW5nIHdhcyB3cml0dGVuIGJ5IERhdmlkIEJvbm5ldCBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2UuXG4vL1xuLy8gVGhlIEdpdCByZXBvc2l0b3J5IGZvciBBc3RyaW5nIGlzIGF2YWlsYWJsZSBhdDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJvbm5ldC9hc3RyaW5nLmdpdFxuLy9cbi8vIFBsZWFzZSB1c2UgdGhlIEdpdEh1YiBidWcgdHJhY2tlciB0byByZXBvcnQgaXNzdWVzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkYm9ubmV0L2FzdHJpbmcvaXNzdWVzXG5cbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSBKU09OXG5cbi8qIGM4IGlnbm9yZSBpZiAqL1xuaWYgKCFTdHJpbmcucHJvdG90eXBlLnJlcGVhdCkge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ1N0cmluZy5wcm90b3R5cGUucmVwZWF0IGlzIHVuZGVmaW5lZCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJvbm5ldC9hc3RyaW5nI2luc3RhbGxhdGlvbicsXG4gIClcbn1cblxuLyogYzggaWdub3JlIGlmICovXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpIHtcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoIGlzIHVuZGVmaW5lZCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJvbm5ldC9hc3RyaW5nI2luc3RhbGxhdGlvbicsXG4gIClcbn1cblxuY29uc3QgT1BFUkFUT1JfUFJFQ0VERU5DRSA9IHtcbiAgJ3x8JzogMixcbiAgJz8/JzogMyxcbiAgJyYmJzogNCxcbiAgJ3wnOiA1LFxuICAnXic6IDYsXG4gICcmJzogNyxcbiAgJz09JzogOCxcbiAgJyE9JzogOCxcbiAgJz09PSc6IDgsXG4gICchPT0nOiA4LFxuICAnPCc6IDksXG4gICc+JzogOSxcbiAgJzw9JzogOSxcbiAgJz49JzogOSxcbiAgaW46IDksXG4gIGluc3RhbmNlb2Y6IDksXG4gICc8PCc6IDEwLFxuICAnPj4nOiAxMCxcbiAgJz4+Pic6IDEwLFxuICAnKyc6IDExLFxuICAnLSc6IDExLFxuICAnKic6IDEyLFxuICAnJSc6IDEyLFxuICAnLyc6IDEyLFxuICAnKionOiAxMyxcbn1cblxuLy8gRW5hYmxlcyBwYXJlbnRoZXNpcyByZWdhcmRsZXNzIG9mIHByZWNlZGVuY2VcbmV4cG9ydCBjb25zdCBORUVEU19QQVJFTlRIRVNFUyA9IDE3XG5cbmV4cG9ydCBjb25zdCBFWFBSRVNTSU9OU19QUkVDRURFTkNFID0ge1xuICAvLyBEZWZpbml0aW9uc1xuICBBcnJheUV4cHJlc3Npb246IDIwLFxuICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246IDIwLFxuICBUaGlzRXhwcmVzc2lvbjogMjAsXG4gIElkZW50aWZpZXI6IDIwLFxuICBQcml2YXRlSWRlbnRpZmllcjogMjAsXG4gIExpdGVyYWw6IDE4LFxuICBUZW1wbGF0ZUxpdGVyYWw6IDIwLFxuICBTdXBlcjogMjAsXG4gIFNlcXVlbmNlRXhwcmVzc2lvbjogMjAsXG4gIC8vIE9wZXJhdGlvbnNcbiAgTWVtYmVyRXhwcmVzc2lvbjogMTksXG4gIENoYWluRXhwcmVzc2lvbjogMTksXG4gIENhbGxFeHByZXNzaW9uOiAxOSxcbiAgTmV3RXhwcmVzc2lvbjogMTksXG4gIC8vIE90aGVyIGRlZmluaXRpb25zXG4gIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBORUVEU19QQVJFTlRIRVNFUyxcbiAgQ2xhc3NFeHByZXNzaW9uOiBORUVEU19QQVJFTlRIRVNFUyxcbiAgRnVuY3Rpb25FeHByZXNzaW9uOiBORUVEU19QQVJFTlRIRVNFUyxcbiAgT2JqZWN0RXhwcmVzc2lvbjogTkVFRFNfUEFSRU5USEVTRVMsXG4gIC8vIE90aGVyIG9wZXJhdGlvbnNcbiAgVXBkYXRlRXhwcmVzc2lvbjogMTYsXG4gIFVuYXJ5RXhwcmVzc2lvbjogMTUsXG4gIEF3YWl0RXhwcmVzc2lvbjogMTUsXG4gIEJpbmFyeUV4cHJlc3Npb246IDE0LFxuICBMb2dpY2FsRXhwcmVzc2lvbjogMTMsXG4gIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogNCxcbiAgQXNzaWdubWVudEV4cHJlc3Npb246IDMsXG4gIFlpZWxkRXhwcmVzc2lvbjogMixcbiAgUmVzdEVsZW1lbnQ6IDEsXG59XG5cbmZ1bmN0aW9uIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2Rlcykge1xuICAvKlxuICBXcml0ZXMgaW50byBgc3RhdGVgIGEgc2VxdWVuY2Ugb2YgYG5vZGVzYC5cbiAgKi9cbiAgY29uc3QgeyBnZW5lcmF0b3IgfSA9IHN0YXRlXG4gIHN0YXRlLndyaXRlKCcoJylcbiAgaWYgKG5vZGVzICE9IG51bGwgJiYgbm9kZXMubGVuZ3RoID4gMCkge1xuICAgIGdlbmVyYXRvcltub2Rlc1swXS50eXBlXShub2Rlc1swXSwgc3RhdGUpXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFyYW0gPSBub2Rlc1tpXVxuICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgIGdlbmVyYXRvcltwYXJhbS50eXBlXShwYXJhbSwgc3RhdGUpXG4gICAgfVxuICB9XG4gIHN0YXRlLndyaXRlKCcpJylcbn1cblxuZnVuY3Rpb24gZXhwcmVzc2lvbk5lZWRzUGFyZW50aGVzaXMoc3RhdGUsIG5vZGUsIHBhcmVudE5vZGUsIGlzUmlnaHRIYW5kKSB7XG4gIGNvbnN0IG5vZGVQcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUudHlwZV1cbiAgaWYgKG5vZGVQcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgY29uc3QgcGFyZW50Tm9kZVByZWNlZGVuY2UgPSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2VbcGFyZW50Tm9kZS50eXBlXVxuICBpZiAobm9kZVByZWNlZGVuY2UgIT09IHBhcmVudE5vZGVQcmVjZWRlbmNlKSB7XG4gICAgLy8gRGlmZmVyZW50IG5vZGUgdHlwZXNcbiAgICByZXR1cm4gKFxuICAgICAgKCFpc1JpZ2h0SGFuZCAmJlxuICAgICAgICBub2RlUHJlY2VkZW5jZSA9PT0gMTUgJiZcbiAgICAgICAgcGFyZW50Tm9kZVByZWNlZGVuY2UgPT09IDE0ICYmXG4gICAgICAgIHBhcmVudE5vZGUub3BlcmF0b3IgPT09ICcqKicpIHx8XG4gICAgICBub2RlUHJlY2VkZW5jZSA8IHBhcmVudE5vZGVQcmVjZWRlbmNlXG4gICAgKVxuICB9XG4gIGlmIChub2RlUHJlY2VkZW5jZSAhPT0gMTMgJiYgbm9kZVByZWNlZGVuY2UgIT09IDE0KSB7XG4gICAgLy8gTm90IGEgYExvZ2ljYWxFeHByZXNzaW9uYCBvciBgQmluYXJ5RXhwcmVzc2lvbmBcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS5vcGVyYXRvciA9PT0gJyoqJyAmJiBwYXJlbnROb2RlLm9wZXJhdG9yID09PSAnKionKSB7XG4gICAgLy8gRXhwb25lbnRpYXRpb24gb3BlcmF0b3IgaGFzIHJpZ2h0LXRvLWxlZnQgYXNzb2NpYXRpdml0eVxuICAgIHJldHVybiAhaXNSaWdodEhhbmRcbiAgfVxuICBpZiAoXG4gICAgbm9kZVByZWNlZGVuY2UgPT09IDEzICYmXG4gICAgcGFyZW50Tm9kZVByZWNlZGVuY2UgPT09IDEzICYmXG4gICAgKG5vZGUub3BlcmF0b3IgPT09ICc/PycgfHwgcGFyZW50Tm9kZS5vcGVyYXRvciA9PT0gJz8/JylcbiAgKSB7XG4gICAgLy8gTnVsbGlzaCBjb2FsZXNjaW5nIGFuZCBib29sZWFuIG9wZXJhdG9ycyBjYW5ub3QgYmUgY29tYmluZWRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1JpZ2h0SGFuZCkge1xuICAgIC8vIFBhcmVudGhlc2lzIGFyZSB1c2VkIGlmIGJvdGggb3BlcmF0b3JzIGhhdmUgdGhlIHNhbWUgcHJlY2VkZW5jZVxuICAgIHJldHVybiAoXG4gICAgICBPUEVSQVRPUl9QUkVDRURFTkNFW25vZGUub3BlcmF0b3JdIDw9XG4gICAgICBPUEVSQVRPUl9QUkVDRURFTkNFW3BhcmVudE5vZGUub3BlcmF0b3JdXG4gICAgKVxuICB9XG4gIHJldHVybiAoXG4gICAgT1BFUkFUT1JfUFJFQ0VERU5DRVtub2RlLm9wZXJhdG9yXSA8XG4gICAgT1BFUkFUT1JfUFJFQ0VERU5DRVtwYXJlbnROb2RlLm9wZXJhdG9yXVxuICApXG59XG5cbmZ1bmN0aW9uIGZvcm1hdEV4cHJlc3Npb24oc3RhdGUsIG5vZGUsIHBhcmVudE5vZGUsIGlzUmlnaHRIYW5kKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgdGhlIHByb3ZpZGVkIGBub2RlYCwgYWRkaW5nIHBhcmVudGhlc2lzIGFyb3VuZCBpZiB0aGUgcHJvdmlkZWQgYHBhcmVudE5vZGVgIG5lZWRzIGl0LiBJZiBgbm9kZWAgaXMgYSByaWdodC1oYW5kIGFyZ3VtZW50LCB0aGUgcHJvdmlkZWQgYGlzUmlnaHRIYW5kYCBwYXJhbWV0ZXIgc2hvdWxkIGJlIGB0cnVlYC5cbiAgKi9cbiAgY29uc3QgeyBnZW5lcmF0b3IgfSA9IHN0YXRlXG4gIGlmIChleHByZXNzaW9uTmVlZHNQYXJlbnRoZXNpcyhzdGF0ZSwgbm9kZSwgcGFyZW50Tm9kZSwgaXNSaWdodEhhbmQpKSB7XG4gICAgc3RhdGUud3JpdGUoJygnKVxuICAgIGdlbmVyYXRvcltub2RlLnR5cGVdKG5vZGUsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpJylcbiAgfSBlbHNlIHtcbiAgICBnZW5lcmF0b3Jbbm9kZS50eXBlXShub2RlLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiByZWluZGVudChzdGF0ZSwgdGV4dCwgaW5kZW50LCBsaW5lRW5kKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgdGhlIGB0ZXh0YCBzdHJpbmcgcmVpbmRlbnRlZCB3aXRoIHRoZSBwcm92aWRlZCBgaW5kZW50YC5cbiAgKi9cbiAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKVxuICBjb25zdCBlbmQgPSBsaW5lcy5sZW5ndGggLSAxXG4gIHN0YXRlLndyaXRlKGxpbmVzWzBdLnRyaW0oKSlcbiAgaWYgKGVuZCA+IDApIHtcbiAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHN0YXRlLndyaXRlKGluZGVudCArIGxpbmVzW2ldLnRyaW0oKSArIGxpbmVFbmQpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKGluZGVudCArIGxpbmVzW2VuZF0udHJpbSgpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBjb21tZW50cywgaW5kZW50LCBsaW5lRW5kKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgdGhlIHByb3ZpZGVkIGxpc3Qgb2YgYGNvbW1lbnRzYCwgd2l0aCB0aGUgZ2l2ZW4gYGluZGVudGAgYW5kIGBsaW5lRW5kYCBzdHJpbmdzLlxuICBMaW5lIGNvbW1lbnRzIHdpbGwgZW5kIHdpdGggYFwiXFxuXCJgIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBsaW5lRW5kYC5cbiAgRXhwZWN0cyB0byBzdGFydCBvbiBhIG5ldyB1bmluZGVudGVkIGxpbmUuXG4gICovXG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBjb21tZW50c1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29tbWVudCA9IGNvbW1lbnRzW2ldXG4gICAgc3RhdGUud3JpdGUoaW5kZW50KVxuICAgIGlmIChjb21tZW50LnR5cGVbMF0gPT09ICdMJykge1xuICAgICAgLy8gTGluZSBjb21tZW50XG4gICAgICBzdGF0ZS53cml0ZSgnLy8gJyArIGNvbW1lbnQudmFsdWUudHJpbSgpICsgJ1xcbicsIGNvbW1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJsb2NrIGNvbW1lbnRcbiAgICAgIHN0YXRlLndyaXRlKCcvKicpXG4gICAgICByZWluZGVudChzdGF0ZSwgY29tbWVudC52YWx1ZSwgaW5kZW50LCBsaW5lRW5kKVxuICAgICAgc3RhdGUud3JpdGUoJyovJyArIGxpbmVFbmQpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0NhbGxFeHByZXNzaW9uKG5vZGUpIHtcbiAgLypcbiAgUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3ZpZGVkIGBub2RlYCBjb250YWlucyBhIGNhbGwgZXhwcmVzc2lvbiBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICovXG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGVcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IGN1cnJlbnROb2RlXG4gICAgaWYgKHR5cGVbMF0gPT09ICdDJyAmJiB0eXBlWzFdID09PSAnYScpIHtcbiAgICAgIC8vIElzIENhbGxFeHByZXNzaW9uXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAodHlwZVswXSA9PT0gJ00nICYmIHR5cGVbMV0gPT09ICdlJyAmJiB0eXBlWzJdID09PSAnbScpIHtcbiAgICAgIC8vIElzIE1lbWJlckV4cHJlc3Npb25cbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUub2JqZWN0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRWYXJpYWJsZURlY2xhcmF0aW9uKHN0YXRlLCBub2RlKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgYSB2YXJpYWJsZSBkZWNsYXJhdGlvbi5cbiAgKi9cbiAgY29uc3QgeyBnZW5lcmF0b3IgfSA9IHN0YXRlXG4gIGNvbnN0IHsgZGVjbGFyYXRpb25zIH0gPSBub2RlXG4gIHN0YXRlLndyaXRlKG5vZGUua2luZCArICcgJylcbiAgY29uc3QgeyBsZW5ndGggfSA9IGRlY2xhcmF0aW9uc1xuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIGdlbmVyYXRvci5WYXJpYWJsZURlY2xhcmF0b3IoZGVjbGFyYXRpb25zWzBdLCBzdGF0ZSlcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgZ2VuZXJhdG9yLlZhcmlhYmxlRGVjbGFyYXRvcihkZWNsYXJhdGlvbnNbaV0sIHN0YXRlKVxuICAgIH1cbiAgfVxufVxuXG5sZXQgRm9ySW5TdGF0ZW1lbnQsXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gIFJlc3RFbGVtZW50LFxuICBCaW5hcnlFeHByZXNzaW9uLFxuICBBcnJheUV4cHJlc3Npb24sXG4gIEJsb2NrU3RhdGVtZW50XG5cbmV4cG9ydCBjb25zdCBHRU5FUkFUT1IgPSB7XG4gIC8qXG4gIERlZmF1bHQgZ2VuZXJhdG9yLlxuICAqL1xuICBQcm9ncmFtKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgaW5kZW50ID0gc3RhdGUuaW5kZW50LnJlcGVhdChzdGF0ZS5pbmRlbnRMZXZlbClcbiAgICBjb25zdCB7IGxpbmVFbmQsIHdyaXRlQ29tbWVudHMgfSA9IHN0YXRlXG4gICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgbm9kZS5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgaW5kZW50LCBsaW5lRW5kKVxuICAgIH1cbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gbm9kZS5ib2R5XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHN0YXRlbWVudHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGF0ZW1lbnQgPSBzdGF0ZW1lbnRzW2ldXG4gICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBzdGF0ZW1lbnQuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgc3RhdGVtZW50LmNvbW1lbnRzLCBpbmRlbnQsIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBzdGF0ZS53cml0ZShpbmRlbnQpXG4gICAgICB0aGlzW3N0YXRlbWVudC50eXBlXShzdGF0ZW1lbnQsIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICB9XG4gICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgbm9kZS50cmFpbGluZ0NvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLnRyYWlsaW5nQ29tbWVudHMsIGluZGVudCwgbGluZUVuZClcbiAgICB9XG4gIH0sXG4gIEJsb2NrU3RhdGVtZW50OiAoQmxvY2tTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQucmVwZWF0KHN0YXRlLmluZGVudExldmVsKyspXG4gICAgY29uc3QgeyBsaW5lRW5kLCB3cml0ZUNvbW1lbnRzIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHN0YXRlbWVudEluZGVudCA9IGluZGVudCArIHN0YXRlLmluZGVudFxuICAgIHN0YXRlLndyaXRlKCd7JylcbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gbm9kZS5ib2R5XG4gICAgaWYgKHN0YXRlbWVudHMgIT0gbnVsbCAmJiBzdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUuY29tbWVudHMsIHN0YXRlbWVudEluZGVudCwgbGluZUVuZClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBzdGF0ZW1lbnRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlbWVudCA9IHN0YXRlbWVudHNbaV1cbiAgICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgc3RhdGVtZW50LmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgc3RhdGVtZW50LmNvbW1lbnRzLCBzdGF0ZW1lbnRJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUoc3RhdGVtZW50SW5kZW50KVxuICAgICAgICB0aGlzW3N0YXRlbWVudC50eXBlXShzdGF0ZW1lbnQsIHN0YXRlKVxuICAgICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoaW5kZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUuY29tbWVudHMsIHN0YXRlbWVudEluZGVudCwgbGluZUVuZClcbiAgICAgICAgc3RhdGUud3JpdGUoaW5kZW50KVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLnRyYWlsaW5nQ29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUudHJhaWxpbmdDb21tZW50cywgc3RhdGVtZW50SW5kZW50LCBsaW5lRW5kKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnfScpXG4gICAgc3RhdGUuaW5kZW50TGV2ZWwtLVxuICB9KSxcbiAgQ2xhc3NCb2R5OiBCbG9ja1N0YXRlbWVudCxcbiAgU3RhdGljQmxvY2sobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnc3RhdGljICcpXG4gICAgdGhpcy5CbG9ja1N0YXRlbWVudChub2RlLCBzdGF0ZSlcbiAgfSxcbiAgRW1wdHlTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIEV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUuZXhwcmVzc2lvbi50eXBlXVxuICAgIGlmIChcbiAgICAgIHByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTIHx8XG4gICAgICAocHJlY2VkZW5jZSA9PT0gMyAmJiBub2RlLmV4cHJlc3Npb24ubGVmdC50eXBlWzBdID09PSAnTycpXG4gICAgKSB7XG4gICAgICAvLyBTaG91bGQgYWx3YXlzIGhhdmUgcGFyZW50aGVzZXMgb3IgaXMgYW4gQXNzaWdubWVudEV4cHJlc3Npb24gdG8gYW4gT2JqZWN0UGF0dGVyblxuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpc1tub2RlLmV4cHJlc3Npb24udHlwZV0obm9kZS5leHByZXNzaW9uLCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmV4cHJlc3Npb24udHlwZV0obm9kZS5leHByZXNzaW9uLCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBJZlN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdpZiAoJylcbiAgICB0aGlzW25vZGUudGVzdC50eXBlXShub2RlLnRlc3QsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgdGhpc1tub2RlLmNvbnNlcXVlbnQudHlwZV0obm9kZS5jb25zZXF1ZW50LCBzdGF0ZSlcbiAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT0gbnVsbCkge1xuICAgICAgc3RhdGUud3JpdGUoJyBlbHNlICcpXG4gICAgICB0aGlzW25vZGUuYWx0ZXJuYXRlLnR5cGVdKG5vZGUuYWx0ZXJuYXRlLCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIExhYmVsZWRTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzW25vZGUubGFiZWwudHlwZV0obm9kZS5sYWJlbCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJzogJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9LFxuICBCcmVha1N0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdicmVhaycpXG4gICAgaWYgKG5vZGUubGFiZWwgIT0gbnVsbCkge1xuICAgICAgc3RhdGUud3JpdGUoJyAnKVxuICAgICAgdGhpc1tub2RlLmxhYmVsLnR5cGVdKG5vZGUubGFiZWwsIHN0YXRlKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIENvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2NvbnRpbnVlJylcbiAgICBpZiAobm9kZS5sYWJlbCAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnICcpXG4gICAgICB0aGlzW25vZGUubGFiZWwudHlwZV0obm9kZS5sYWJlbCwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgV2l0aFN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCd3aXRoICgnKVxuICAgIHRoaXNbbm9kZS5vYmplY3QudHlwZV0obm9kZS5vYmplY3QsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgfSxcbiAgU3dpdGNoU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgaW5kZW50ID0gc3RhdGUuaW5kZW50LnJlcGVhdChzdGF0ZS5pbmRlbnRMZXZlbCsrKVxuICAgIGNvbnN0IHsgbGluZUVuZCwgd3JpdGVDb21tZW50cyB9ID0gc3RhdGVcbiAgICBzdGF0ZS5pbmRlbnRMZXZlbCsrXG4gICAgY29uc3QgY2FzZUluZGVudCA9IGluZGVudCArIHN0YXRlLmluZGVudFxuICAgIGNvbnN0IHN0YXRlbWVudEluZGVudCA9IGNhc2VJbmRlbnQgKyBzdGF0ZS5pbmRlbnRcbiAgICBzdGF0ZS53cml0ZSgnc3dpdGNoICgnKVxuICAgIHRoaXNbbm9kZS5kaXNjcmltaW5hbnQudHlwZV0obm9kZS5kaXNjcmltaW5hbnQsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpIHsnICsgbGluZUVuZClcbiAgICBjb25zdCB7IGNhc2VzOiBvY2N1cmVuY2VzIH0gPSBub2RlXG4gICAgY29uc3QgeyBsZW5ndGg6IG9jY3VyZW5jZXNDb3VudCB9ID0gb2NjdXJlbmNlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2NjdXJlbmNlc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IG9jY3VyZW5jZSA9IG9jY3VyZW5jZXNbaV1cbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG9jY3VyZW5jZS5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBvY2N1cmVuY2UuY29tbWVudHMsIGNhc2VJbmRlbnQsIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBpZiAob2NjdXJlbmNlLnRlc3QpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoY2FzZUluZGVudCArICdjYXNlICcpXG4gICAgICAgIHRoaXNbb2NjdXJlbmNlLnRlc3QudHlwZV0ob2NjdXJlbmNlLnRlc3QsIHN0YXRlKVxuICAgICAgICBzdGF0ZS53cml0ZSgnOicgKyBsaW5lRW5kKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUud3JpdGUoY2FzZUluZGVudCArICdkZWZhdWx0OicgKyBsaW5lRW5kKVxuICAgICAgfVxuICAgICAgY29uc3QgeyBjb25zZXF1ZW50IH0gPSBvY2N1cmVuY2VcbiAgICAgIGNvbnN0IHsgbGVuZ3RoOiBjb25zZXF1ZW50Q291bnQgfSA9IGNvbnNlcXVlbnRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uc2VxdWVudENvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhdGVtZW50ID0gY29uc2VxdWVudFtpXVxuICAgICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBzdGF0ZW1lbnQuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBzdGF0ZW1lbnQuY29tbWVudHMsIHN0YXRlbWVudEluZGVudCwgbGluZUVuZClcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS53cml0ZShzdGF0ZW1lbnRJbmRlbnQpXG4gICAgICAgIHRoaXNbc3RhdGVtZW50LnR5cGVdKHN0YXRlbWVudCwgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLmluZGVudExldmVsIC09IDJcbiAgICBzdGF0ZS53cml0ZShpbmRlbnQgKyAnfScpXG4gIH0sXG4gIFJldHVyblN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdyZXR1cm4nKVxuICAgIGlmIChub2RlLmFyZ3VtZW50KSB7XG4gICAgICBzdGF0ZS53cml0ZSgnICcpXG4gICAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgVGhyb3dTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgndGhyb3cgJylcbiAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBUcnlTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgndHJ5ICcpXG4gICAgdGhpc1tub2RlLmJsb2NrLnR5cGVdKG5vZGUuYmxvY2ssIHN0YXRlKVxuICAgIGlmIChub2RlLmhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IHsgaGFuZGxlciB9ID0gbm9kZVxuICAgICAgaWYgKGhhbmRsZXIucGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS53cml0ZSgnIGNhdGNoICcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS53cml0ZSgnIGNhdGNoICgnKVxuICAgICAgICB0aGlzW2hhbmRsZXIucGFyYW0udHlwZV0oaGFuZGxlci5wYXJhbSwgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgICB9XG4gICAgICB0aGlzW2hhbmRsZXIuYm9keS50eXBlXShoYW5kbGVyLmJvZHksIHN0YXRlKVxuICAgIH1cbiAgICBpZiAobm9kZS5maW5hbGl6ZXIpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgZmluYWxseSAnKVxuICAgICAgdGhpc1tub2RlLmZpbmFsaXplci50eXBlXShub2RlLmZpbmFsaXplciwgc3RhdGUpXG4gICAgfVxuICB9LFxuICBXaGlsZVN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCd3aGlsZSAoJylcbiAgICB0aGlzW25vZGUudGVzdC50eXBlXShub2RlLnRlc3QsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgfSxcbiAgRG9XaGlsZVN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdkbyAnKVxuICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJyB3aGlsZSAoJylcbiAgICB0aGlzW25vZGUudGVzdC50eXBlXShub2RlLnRlc3QsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpOycpXG4gIH0sXG4gIEZvclN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdmb3IgKCcpXG4gICAgaWYgKG5vZGUuaW5pdCAhPSBudWxsKSB7XG4gICAgICBjb25zdCB7IGluaXQgfSA9IG5vZGVcbiAgICAgIGlmIChpbml0LnR5cGVbMF0gPT09ICdWJykge1xuICAgICAgICBmb3JtYXRWYXJpYWJsZURlY2xhcmF0aW9uKHN0YXRlLCBpbml0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tpbml0LnR5cGVdKGluaXQsIHN0YXRlKVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnOyAnKVxuICAgIGlmIChub2RlLnRlc3QpIHtcbiAgICAgIHRoaXNbbm9kZS50ZXN0LnR5cGVdKG5vZGUudGVzdCwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7ICcpXG4gICAgaWYgKG5vZGUudXBkYXRlKSB7XG4gICAgICB0aGlzW25vZGUudXBkYXRlLnR5cGVdKG5vZGUudXBkYXRlLCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJykgJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9LFxuICBGb3JJblN0YXRlbWVudDogKEZvckluU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoYGZvciAke25vZGUuYXdhaXQgPyAnYXdhaXQgJyA6ICcnfShgKVxuICAgIGNvbnN0IHsgbGVmdCB9ID0gbm9kZVxuICAgIGlmIChsZWZ0LnR5cGVbMF0gPT09ICdWJykge1xuICAgICAgZm9ybWF0VmFyaWFibGVEZWNsYXJhdGlvbihzdGF0ZSwgbGVmdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tsZWZ0LnR5cGVdKGxlZnQsIHN0YXRlKVxuICAgIH1cbiAgICAvLyBJZGVudGlmeWluZyB3aGV0aGVyIG5vZGUudHlwZSBpcyBgRm9ySW5TdGF0ZW1lbnRgIG9yIGBGb3JPZlN0YXRlbWVudGBcbiAgICBzdGF0ZS53cml0ZShub2RlLnR5cGVbM10gPT09ICdJJyA/ICcgaW4gJyA6ICcgb2YgJylcbiAgICB0aGlzW25vZGUucmlnaHQudHlwZV0obm9kZS5yaWdodCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJykgJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9KSxcbiAgRm9yT2ZTdGF0ZW1lbnQ6IEZvckluU3RhdGVtZW50LFxuICBEZWJ1Z2dlclN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdkZWJ1Z2dlcjsnLCBub2RlKVxuICB9LFxuICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAoRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKFxuICAgICAgKG5vZGUuYXN5bmMgPyAnYXN5bmMgJyA6ICcnKSArXG4gICAgICAgIChub2RlLmdlbmVyYXRvciA/ICdmdW5jdGlvbiogJyA6ICdmdW5jdGlvbiAnKSArXG4gICAgICAgIChub2RlLmlkID8gbm9kZS5pZC5uYW1lIDogJycpLFxuICAgICAgbm9kZSxcbiAgICApXG4gICAgZm9ybWF0U2VxdWVuY2Uoc3RhdGUsIG5vZGUucGFyYW1zKVxuICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9KSxcbiAgRnVuY3Rpb25FeHByZXNzaW9uOiBGdW5jdGlvbkRlY2xhcmF0aW9uLFxuICBWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgZm9ybWF0VmFyaWFibGVEZWNsYXJhdGlvbihzdGF0ZSwgbm9kZSlcbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIFZhcmlhYmxlRGVjbGFyYXRvcihub2RlLCBzdGF0ZSkge1xuICAgIHRoaXNbbm9kZS5pZC50eXBlXShub2RlLmlkLCBzdGF0ZSlcbiAgICBpZiAobm9kZS5pbml0ICE9IG51bGwpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgPSAnKVxuICAgICAgdGhpc1tub2RlLmluaXQudHlwZV0obm9kZS5pbml0LCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIENsYXNzRGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnY2xhc3MgJyArIChub2RlLmlkID8gYCR7bm9kZS5pZC5uYW1lfSBgIDogJycpLCBub2RlKVxuICAgIGlmIChub2RlLnN1cGVyQ2xhc3MpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdleHRlbmRzICcpXG4gICAgICBjb25zdCB7IHN1cGVyQ2xhc3MgfSA9IG5vZGVcbiAgICAgIGNvbnN0IHsgdHlwZSB9ID0gc3VwZXJDbGFzc1xuICAgICAgY29uc3QgcHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVt0eXBlXVxuICAgICAgaWYgKFxuICAgICAgICAodHlwZVswXSAhPT0gJ0MnIHx8IHR5cGVbMV0gIT09ICdsJyB8fCB0eXBlWzVdICE9PSAnRScpICYmXG4gICAgICAgIChwcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUyB8fFxuICAgICAgICAgIHByZWNlZGVuY2UgPCBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuQ2xhc3NFeHByZXNzaW9uKVxuICAgICAgKSB7XG4gICAgICAgIC8vIE5vdCBhIENsYXNzRXhwcmVzc2lvbiB0aGF0IG5lZWRzIHBhcmVudGhlc2VzXG4gICAgICAgIHN0YXRlLndyaXRlKCcoJylcbiAgICAgICAgdGhpc1tub2RlLnN1cGVyQ2xhc3MudHlwZV0oc3VwZXJDbGFzcywgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbc3VwZXJDbGFzcy50eXBlXShzdXBlckNsYXNzLCBzdGF0ZSlcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICB9XG4gICAgdGhpcy5DbGFzc0JvZHkobm9kZS5ib2R5LCBzdGF0ZSlcbiAgfSxcbiAgSW1wb3J0RGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnaW1wb3J0ICcpXG4gICAgY29uc3QgeyBzcGVjaWZpZXJzIH0gPSBub2RlXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHNwZWNpZmllcnNcbiAgICAvLyBUT0RPOiBPbmNlIGJhYmlsaSBpcyBmaXhlZCwgcHV0IHRoaXMgYWZ0ZXIgY29uZGl0aW9uXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmlsaS9pc3N1ZXMvNDMwXG4gICAgbGV0IGkgPSAwXG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyApIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGVjaWZpZXIgPSBzcGVjaWZpZXJzW2ldXG4gICAgICAgIGNvbnN0IHR5cGUgPSBzcGVjaWZpZXIudHlwZVs2XVxuICAgICAgICBpZiAodHlwZSA9PT0gJ0QnKSB7XG4gICAgICAgICAgLy8gSW1wb3J0RGVmYXVsdFNwZWNpZmllclxuICAgICAgICAgIHN0YXRlLndyaXRlKHNwZWNpZmllci5sb2NhbC5uYW1lLCBzcGVjaWZpZXIpXG4gICAgICAgICAgaSsrXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ04nKSB7XG4gICAgICAgICAgLy8gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXG4gICAgICAgICAgc3RhdGUud3JpdGUoJyogYXMgJyArIHNwZWNpZmllci5sb2NhbC5uYW1lLCBzcGVjaWZpZXIpXG4gICAgICAgICAgaSsrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW1wb3J0U3BlY2lmaWVyXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJ3snKVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgY29uc3Qgc3BlY2lmaWVyID0gc3BlY2lmaWVyc1tpXVxuICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gc3BlY2lmaWVyLmltcG9ydGVkXG4gICAgICAgICAgc3RhdGUud3JpdGUobmFtZSwgc3BlY2lmaWVyKVxuICAgICAgICAgIGlmIChuYW1lICE9PSBzcGVjaWZpZXIubG9jYWwubmFtZSkge1xuICAgICAgICAgICAgc3RhdGUud3JpdGUoJyBhcyAnICsgc3BlY2lmaWVyLmxvY2FsLm5hbWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyaXRlKCd9JylcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKCcgZnJvbSAnKVxuICAgIH1cbiAgICB0aGlzLkxpdGVyYWwobm9kZS5zb3VyY2UsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgSW1wb3J0RXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdpbXBvcnQoJylcbiAgICB0aGlzW25vZGUuc291cmNlLnR5cGVdKG5vZGUuc291cmNlLCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnKScpXG4gIH0sXG4gIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdleHBvcnQgZGVmYXVsdCAnKVxuICAgIHRoaXNbbm9kZS5kZWNsYXJhdGlvbi50eXBlXShub2RlLmRlY2xhcmF0aW9uLCBzdGF0ZSlcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2Vbbm9kZS5kZWNsYXJhdGlvbi50eXBlXSAhPSBudWxsICYmXG4gICAgICBub2RlLmRlY2xhcmF0aW9uLnR5cGVbMF0gIT09ICdGJ1xuICAgICkge1xuICAgICAgLy8gQWxsIGV4cHJlc3Npb24gbm9kZXMgZXhjZXB0IGBGdW5jdGlvbkV4cHJlc3Npb25gXG4gICAgICBzdGF0ZS53cml0ZSgnOycpXG4gICAgfVxuICB9LFxuICBFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2V4cG9ydCAnKVxuICAgIGlmIChub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgICB0aGlzW25vZGUuZGVjbGFyYXRpb24udHlwZV0obm9kZS5kZWNsYXJhdGlvbiwgc3RhdGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLndyaXRlKCd7JylcbiAgICAgIGNvbnN0IHsgc3BlY2lmaWVycyB9ID0gbm9kZSxcbiAgICAgICAgeyBsZW5ndGggfSA9IHNwZWNpZmllcnNcbiAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyA7ICkge1xuICAgICAgICAgIGNvbnN0IHNwZWNpZmllciA9IHNwZWNpZmllcnNbaV1cbiAgICAgICAgICBjb25zdCB7IG5hbWUgfSA9IHNwZWNpZmllci5sb2NhbFxuICAgICAgICAgIHN0YXRlLndyaXRlKG5hbWUsIHNwZWNpZmllcilcbiAgICAgICAgICBpZiAobmFtZSAhPT0gc3BlY2lmaWVyLmV4cG9ydGVkLm5hbWUpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKCcgYXMgJyArIHNwZWNpZmllci5leHBvcnRlZC5uYW1lKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgICAgaWYgKG5vZGUuc291cmNlKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCcgZnJvbSAnKVxuICAgICAgICB0aGlzLkxpdGVyYWwobm9kZS5zb3VyY2UsIHN0YXRlKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoJzsnKVxuICAgIH1cbiAgfSxcbiAgRXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5leHBvcnRlZCAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnZXhwb3J0ICogYXMgJyArIG5vZGUuZXhwb3J0ZWQubmFtZSArICcgZnJvbSAnKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS53cml0ZSgnZXhwb3J0ICogZnJvbSAnKVxuICAgIH1cbiAgICB0aGlzLkxpdGVyYWwobm9kZS5zb3VyY2UsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgTWV0aG9kRGVmaW5pdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnN0YXRpYykge1xuICAgICAgc3RhdGUud3JpdGUoJ3N0YXRpYyAnKVxuICAgIH1cbiAgICBjb25zdCBraW5kID0gbm9kZS5raW5kWzBdXG4gICAgaWYgKGtpbmQgPT09ICdnJyB8fCBraW5kID09PSAncycpIHtcbiAgICAgIC8vIEdldHRlciBvciBzZXR0ZXJcbiAgICAgIHN0YXRlLndyaXRlKG5vZGUua2luZCArICcgJylcbiAgICB9XG4gICAgaWYgKG5vZGUudmFsdWUuYXN5bmMpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdhc3luYyAnKVxuICAgIH1cbiAgICBpZiAobm9kZS52YWx1ZS5nZW5lcmF0b3IpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcqJylcbiAgICB9XG4gICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICAgIHRoaXNbbm9kZS5rZXkudHlwZV0obm9kZS5rZXksIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJ10nKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICB9XG4gICAgZm9ybWF0U2VxdWVuY2Uoc3RhdGUsIG5vZGUudmFsdWUucGFyYW1zKVxuICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICB0aGlzW25vZGUudmFsdWUuYm9keS50eXBlXShub2RlLnZhbHVlLmJvZHksIHN0YXRlKVxuICB9LFxuICBDbGFzc0V4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzLkNsYXNzRGVjbGFyYXRpb24obm9kZSwgc3RhdGUpXG4gIH0sXG4gIEFycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS5hc3luYyA/ICdhc3luYyAnIDogJycsIG5vZGUpXG4gICAgY29uc3QgeyBwYXJhbXMgfSA9IG5vZGVcbiAgICBpZiAocGFyYW1zICE9IG51bGwpIHtcbiAgICAgIC8vIE9taXQgcGFyZW50aGVzaXMgaWYgb25seSBvbmUgbmFtZWQgcGFyYW1ldGVyXG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBwYXJhbXNbMF0udHlwZVswXSA9PT0gJ0knKSB7XG4gICAgICAgIC8vIElmIHBhcmFtc1swXS50eXBlWzBdIHN0YXJ0cyB3aXRoICdJJywgaXQgY2FuJ3QgYmUgYEltcG9ydERlY2xhcmF0aW9uYCBub3IgYElmU3RhdGVtZW50YCBhbmQgdGh1cyBpcyBgSWRlbnRpZmllcmBcbiAgICAgICAgc3RhdGUud3JpdGUocGFyYW1zWzBdLm5hbWUsIHBhcmFtc1swXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2RlLnBhcmFtcylcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJyA9PiAnKVxuICAgIGlmIChub2RlLmJvZHkudHlwZVswXSA9PT0gJ08nKSB7XG4gICAgICAvLyBCb2R5IGlzIGFuIG9iamVjdCBleHByZXNzaW9uXG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzLk9iamVjdEV4cHJlc3Npb24obm9kZS5ib2R5LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIFRoaXNFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3RoaXMnLCBub2RlKVxuICB9LFxuICBTdXBlcihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdzdXBlcicsIG5vZGUpXG4gIH0sXG4gIFJlc3RFbGVtZW50OiAoUmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnLi4uJylcbiAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gIH0pLFxuICBTcHJlYWRFbGVtZW50OiBSZXN0RWxlbWVudCxcbiAgWWllbGRFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS5kZWxlZ2F0ZSA/ICd5aWVsZConIDogJ3lpZWxkJylcbiAgICBpZiAobm9kZS5hcmd1bWVudCkge1xuICAgICAgc3RhdGUud3JpdGUoJyAnKVxuICAgICAgdGhpc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5vZGUuYXJndW1lbnQsIHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgQXdhaXRFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2F3YWl0ICcsIG5vZGUpXG4gICAgZm9ybWF0RXhwcmVzc2lvbihzdGF0ZSwgbm9kZS5hcmd1bWVudCwgbm9kZSlcbiAgfSxcbiAgVGVtcGxhdGVMaXRlcmFsKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgeyBxdWFzaXMsIGV4cHJlc3Npb25zIH0gPSBub2RlXG4gICAgc3RhdGUud3JpdGUoJ2AnKVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBleHByZXNzaW9uc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBleHByZXNzaW9uc1tpXVxuICAgICAgY29uc3QgcXVhc2kgPSBxdWFzaXNbaV1cbiAgICAgIHN0YXRlLndyaXRlKHF1YXNpLnZhbHVlLnJhdywgcXVhc2kpXG4gICAgICBzdGF0ZS53cml0ZSgnJHsnKVxuICAgICAgdGhpc1tleHByZXNzaW9uLnR5cGVdKGV4cHJlc3Npb24sIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgIH1cbiAgICBjb25zdCBxdWFzaSA9IHF1YXNpc1txdWFzaXMubGVuZ3RoIC0gMV1cbiAgICBzdGF0ZS53cml0ZShxdWFzaS52YWx1ZS5yYXcsIHF1YXNpKVxuICAgIHN0YXRlLndyaXRlKCdgJylcbiAgfSxcbiAgVGVtcGxhdGVFbGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS52YWx1ZS5yYXcsIG5vZGUpXG4gIH0sXG4gIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIGZvcm1hdEV4cHJlc3Npb24oc3RhdGUsIG5vZGUudGFnLCBub2RlKVxuICAgIHRoaXNbbm9kZS5xdWFzaS50eXBlXShub2RlLnF1YXNpLCBzdGF0ZSlcbiAgfSxcbiAgQXJyYXlFeHByZXNzaW9uOiAoQXJyYXlFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ1snKVxuICAgIGlmIChub2RlLmVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHsgZWxlbWVudHMgfSA9IG5vZGUsXG4gICAgICAgIHsgbGVuZ3RoIH0gPSBlbGVtZW50c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IDsgKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXVxuICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpc1tlbGVtZW50LnR5cGVdKGVsZW1lbnQsIHN0YXRlKVxuICAgICAgICB9XG4gICAgICAgIGlmICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJ10nKVxuICB9KSxcbiAgQXJyYXlQYXR0ZXJuOiBBcnJheUV4cHJlc3Npb24sXG4gIE9iamVjdEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQucmVwZWF0KHN0YXRlLmluZGVudExldmVsKyspXG4gICAgY29uc3QgeyBsaW5lRW5kLCB3cml0ZUNvbW1lbnRzIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHByb3BlcnR5SW5kZW50ID0gaW5kZW50ICsgc3RhdGUuaW5kZW50XG4gICAgc3RhdGUud3JpdGUoJ3snKVxuICAgIGlmIChub2RlLnByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBjb25zdCBjb21tYSA9ICcsJyArIGxpbmVFbmRcbiAgICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gbm9kZSxcbiAgICAgICAgeyBsZW5ndGggfSA9IHByb3BlcnRpZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyA7ICkge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV1cbiAgICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgcHJvcGVydHkuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBwcm9wZXJ0eS5jb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUocHJvcGVydHlJbmRlbnQpXG4gICAgICAgIHRoaXNbcHJvcGVydHkudHlwZV0ocHJvcGVydHksIHN0YXRlKVxuICAgICAgICBpZiAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgc3RhdGUud3JpdGUoY29tbWEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUudHJhaWxpbmdDb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLnRyYWlsaW5nQ29tbWVudHMsIHByb3BlcnR5SW5kZW50LCBsaW5lRW5kKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoaW5kZW50ICsgJ30nKVxuICAgIH0gZWxzZSBpZiAod3JpdGVDb21tZW50cykge1xuICAgICAgaWYgKG5vZGUuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIGlmIChub2RlLnRyYWlsaW5nQ29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLnRyYWlsaW5nQ29tbWVudHMsIHByb3BlcnR5SW5kZW50LCBsaW5lRW5kKVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyaXRlKGluZGVudCArICd9JylcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50cmFpbGluZ0NvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUudHJhaWxpbmdDb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIHN0YXRlLndyaXRlKGluZGVudCArICd9JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCd9JylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgIH1cbiAgICBzdGF0ZS5pbmRlbnRMZXZlbC0tXG4gIH0sXG4gIFByb3BlcnR5KG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUubWV0aG9kIHx8IG5vZGUua2luZFswXSAhPT0gJ2knKSB7XG4gICAgICAvLyBFaXRoZXIgYSBtZXRob2Qgb3Igb2Yga2luZCBgc2V0YCBvciBgZ2V0YCAobm90IGBpbml0YClcbiAgICAgIHRoaXMuTWV0aG9kRGVmaW5pdGlvbihub2RlLCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFub2RlLnNob3J0aGFuZCkge1xuICAgICAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICAgICAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnXScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1tub2RlLmtleS50eXBlXShub2RlLmtleSwgc3RhdGUpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUoJzogJylcbiAgICAgIH1cbiAgICAgIHRoaXNbbm9kZS52YWx1ZS50eXBlXShub2RlLnZhbHVlLCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIFByb3BlcnR5RGVmaW5pdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnN0YXRpYykge1xuICAgICAgc3RhdGUud3JpdGUoJ3N0YXRpYyAnKVxuICAgIH1cbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgc3RhdGUud3JpdGUoJ1snKVxuICAgIH1cbiAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgc3RhdGUud3JpdGUoJ10nKVxuICAgIH1cbiAgICBpZiAobm9kZS52YWx1ZSA9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5rZXkudHlwZVswXSAhPT0gJ0YnKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCc7JylcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnID0gJylcbiAgICB0aGlzW25vZGUudmFsdWUudHlwZV0obm9kZS52YWx1ZSwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBPYmplY3RQYXR0ZXJuKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3snKVxuICAgIGlmIChub2RlLnByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBub2RlLFxuICAgICAgICB7IGxlbmd0aCB9ID0gcHJvcGVydGllc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IDsgKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydGllc1tpXS50eXBlXShwcm9wZXJ0aWVzW2ldLCBzdGF0ZSlcbiAgICAgICAgaWYgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnfScpXG4gIH0sXG4gIFNlcXVlbmNlRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2RlLmV4cHJlc3Npb25zKVxuICB9LFxuICBVbmFyeUV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5wcmVmaXgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgIGFyZ3VtZW50LFxuICAgICAgICBhcmd1bWVudDogeyB0eXBlIH0sXG4gICAgICB9ID0gbm9kZVxuICAgICAgc3RhdGUud3JpdGUob3BlcmF0b3IpXG4gICAgICBjb25zdCBuZWVkc1BhcmVudGhlc2VzID0gZXhwcmVzc2lvbk5lZWRzUGFyZW50aGVzaXMoc3RhdGUsIGFyZ3VtZW50LCBub2RlKVxuICAgICAgaWYgKFxuICAgICAgICAhbmVlZHNQYXJlbnRoZXNlcyAmJlxuICAgICAgICAob3BlcmF0b3IubGVuZ3RoID4gMSB8fFxuICAgICAgICAgICh0eXBlWzBdID09PSAnVScgJiZcbiAgICAgICAgICAgICh0eXBlWzFdID09PSAnbicgfHwgdHlwZVsxXSA9PT0gJ3AnKSAmJlxuICAgICAgICAgICAgYXJndW1lbnQucHJlZml4ICYmXG4gICAgICAgICAgICBhcmd1bWVudC5vcGVyYXRvclswXSA9PT0gb3BlcmF0b3IgJiZcbiAgICAgICAgICAgIChvcGVyYXRvciA9PT0gJysnIHx8IG9wZXJhdG9yID09PSAnLScpKSlcbiAgICAgICkge1xuICAgICAgICAvLyBMYXJnZSBvcGVyYXRvciBvciBhcmd1bWVudCBpcyBVbmFyeUV4cHJlc3Npb24gb3IgVXBkYXRlRXhwcmVzc2lvbiBub2RlXG4gICAgICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc1BhcmVudGhlc2VzKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKG9wZXJhdG9yLmxlbmd0aCA+IDEgPyAnICgnIDogJygnKVxuICAgICAgICB0aGlzW3R5cGVdKGFyZ3VtZW50LCBzdGF0ZSlcbiAgICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1t0eXBlXShhcmd1bWVudCwgc3RhdGUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZJWE1FOiBUaGlzIGNhc2UgbmV2ZXIgb2NjdXJzXG4gICAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZShub2RlLm9wZXJhdG9yKVxuICAgIH1cbiAgfSxcbiAgVXBkYXRlRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIC8vIEFsd2F5cyBhcHBsaWVkIHRvIGlkZW50aWZpZXJzIG9yIG1lbWJlcnMsIG5vIHBhcmVudGhlc2lzIGNoZWNrIG5lZWRlZFxuICAgIGlmIChub2RlLnByZWZpeCkge1xuICAgICAgc3RhdGUud3JpdGUobm9kZS5vcGVyYXRvcilcbiAgICAgIHRoaXNbbm9kZS5hcmd1bWVudC50eXBlXShub2RlLmFyZ3VtZW50LCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5vZGUuYXJndW1lbnQsIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUobm9kZS5vcGVyYXRvcilcbiAgICB9XG4gIH0sXG4gIEFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgdGhpc1tub2RlLmxlZnQudHlwZV0obm9kZS5sZWZ0LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnICcgKyBub2RlLm9wZXJhdG9yICsgJyAnKVxuICAgIHRoaXNbbm9kZS5yaWdodC50eXBlXShub2RlLnJpZ2h0LCBzdGF0ZSlcbiAgfSxcbiAgQXNzaWdubWVudFBhdHRlcm4obm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzW25vZGUubGVmdC50eXBlXShub2RlLmxlZnQsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcgPSAnKVxuICAgIHRoaXNbbm9kZS5yaWdodC50eXBlXShub2RlLnJpZ2h0LCBzdGF0ZSlcbiAgfSxcbiAgQmluYXJ5RXhwcmVzc2lvbjogKEJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpc0luID0gbm9kZS5vcGVyYXRvciA9PT0gJ2luJ1xuICAgIGlmIChpc0luKSB7XG4gICAgICAvLyBBdm9pZHMgY29uZnVzaW9uIGluIGBmb3JgIGxvb3BzIGluaXRpYWxpemVyc1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgIH1cbiAgICBmb3JtYXRFeHByZXNzaW9uKHN0YXRlLCBub2RlLmxlZnQsIG5vZGUsIGZhbHNlKVxuICAgIHN0YXRlLndyaXRlKCcgJyArIG5vZGUub3BlcmF0b3IgKyAnICcpXG4gICAgZm9ybWF0RXhwcmVzc2lvbihzdGF0ZSwgbm9kZS5yaWdodCwgbm9kZSwgdHJ1ZSlcbiAgICBpZiAoaXNJbikge1xuICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgIH1cbiAgfSksXG4gIExvZ2ljYWxFeHByZXNzaW9uOiBCaW5hcnlFeHByZXNzaW9uLFxuICBDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCB7IHRlc3QgfSA9IG5vZGVcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW3Rlc3QudHlwZV1cbiAgICBpZiAoXG4gICAgICBwcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUyB8fFxuICAgICAgcHJlY2VkZW5jZSA8PSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuQ29uZGl0aW9uYWxFeHByZXNzaW9uXG4gICAgKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzW3Rlc3QudHlwZV0odGVzdCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbdGVzdC50eXBlXSh0ZXN0LCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJyA/ICcpXG4gICAgdGhpc1tub2RlLmNvbnNlcXVlbnQudHlwZV0obm9kZS5jb25zZXF1ZW50LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnIDogJylcbiAgICB0aGlzW25vZGUuYWx0ZXJuYXRlLnR5cGVdKG5vZGUuYWx0ZXJuYXRlLCBzdGF0ZSlcbiAgfSxcbiAgTmV3RXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCduZXcgJylcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUuY2FsbGVlLnR5cGVdXG4gICAgaWYgKFxuICAgICAgcHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMgfHxcbiAgICAgIHByZWNlZGVuY2UgPCBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuQ2FsbEV4cHJlc3Npb24gfHxcbiAgICAgIGhhc0NhbGxFeHByZXNzaW9uKG5vZGUuY2FsbGVlKVxuICAgICkge1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpc1tub2RlLmNhbGxlZS50eXBlXShub2RlLmNhbGxlZSwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbm9kZS5jYWxsZWUudHlwZV0obm9kZS5jYWxsZWUsIHN0YXRlKVxuICAgIH1cbiAgICBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZVsnYXJndW1lbnRzJ10pXG4gIH0sXG4gIENhbGxFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVtub2RlLmNhbGxlZS50eXBlXVxuICAgIGlmIChcbiAgICAgIHByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTIHx8XG4gICAgICBwcmVjZWRlbmNlIDwgc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlLkNhbGxFeHByZXNzaW9uXG4gICAgKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzW25vZGUuY2FsbGVlLnR5cGVdKG5vZGUuY2FsbGVlLCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmNhbGxlZS50eXBlXShub2RlLmNhbGxlZSwgc3RhdGUpXG4gICAgfVxuICAgIGlmIChub2RlLm9wdGlvbmFsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnPy4nKVxuICAgIH1cbiAgICBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZVsnYXJndW1lbnRzJ10pXG4gIH0sXG4gIENoYWluRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHRoaXNbbm9kZS5leHByZXNzaW9uLnR5cGVdKG5vZGUuZXhwcmVzc2lvbiwgc3RhdGUpXG4gIH0sXG4gIE1lbWJlckV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUub2JqZWN0LnR5cGVdXG4gICAgaWYgKFxuICAgICAgcHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMgfHxcbiAgICAgIHByZWNlZGVuY2UgPCBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuTWVtYmVyRXhwcmVzc2lvblxuICAgICkge1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpc1tub2RlLm9iamVjdC50eXBlXShub2RlLm9iamVjdCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbm9kZS5vYmplY3QudHlwZV0obm9kZS5vYmplY3QsIHN0YXRlKVxuICAgIH1cbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJz8uJylcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICAgIHRoaXNbbm9kZS5wcm9wZXJ0eS50eXBlXShub2RlLnByb3BlcnR5LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCddJylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJz8uJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCcuJylcbiAgICAgIH1cbiAgICAgIHRoaXNbbm9kZS5wcm9wZXJ0eS50eXBlXShub2RlLnByb3BlcnR5LCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIE1ldGFQcm9wZXJ0eShub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKG5vZGUubWV0YS5uYW1lICsgJy4nICsgbm9kZS5wcm9wZXJ0eS5uYW1lLCBub2RlKVxuICB9LFxuICBJZGVudGlmaWVyKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS5uYW1lLCBub2RlKVxuICB9LFxuICBQcml2YXRlSWRlbnRpZmllcihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKGAjJHtub2RlLm5hbWV9YCwgbm9kZSlcbiAgfSxcbiAgTGl0ZXJhbChub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnJhdyAhPSBudWxsKSB7XG4gICAgICAvLyBOb24tc3RhbmRhcmQgcHJvcGVydHlcbiAgICAgIHN0YXRlLndyaXRlKG5vZGUucmF3LCBub2RlKVxuICAgIH0gZWxzZSBpZiAobm9kZS5yZWdleCAhPSBudWxsKSB7XG4gICAgICB0aGlzLlJlZ0V4cExpdGVyYWwobm9kZSwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChub2RlLmJpZ2ludCAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZShub2RlLmJpZ2ludCArICduJywgbm9kZSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUud3JpdGUoc3RyaW5naWZ5KG5vZGUudmFsdWUpLCBub2RlKVxuICAgIH1cbiAgfSxcbiAgUmVnRXhwTGl0ZXJhbChub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IHsgcmVnZXggfSA9IG5vZGVcbiAgICBzdGF0ZS53cml0ZShgLyR7cmVnZXgucGF0dGVybn0vJHtyZWdleC5mbGFnc31gLCBub2RlKVxuICB9LFxufVxuXG5jb25zdCBFTVBUWV9PQkpFQ1QgPSB7fVxuXG4vKlxuREVQUkVDQVRFRDogQWx0ZXJuYXRlIGV4cG9ydCBvZiBgR0VORVJBVE9SYC5cbiovXG5leHBvcnQgY29uc3QgYmFzZUdlbmVyYXRvciA9IEdFTkVSQVRPUlxuXG5jbGFzcyBTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzZXR1cCA9IG9wdGlvbnMgPT0gbnVsbCA/IEVNUFRZX09CSkVDVCA6IG9wdGlvbnNcbiAgICB0aGlzLm91dHB1dCA9ICcnXG4gICAgLy8gRnVuY3Rpb25hbCBvcHRpb25zXG4gICAgaWYgKHNldHVwLm91dHB1dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLm91dHB1dCA9IHNldHVwLm91dHB1dFxuICAgICAgdGhpcy53cml0ZSA9IHRoaXMud3JpdGVUb1N0cmVhbVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm91dHB1dCA9ICcnXG4gICAgfVxuICAgIHRoaXMuZ2VuZXJhdG9yID0gc2V0dXAuZ2VuZXJhdG9yICE9IG51bGwgPyBzZXR1cC5nZW5lcmF0b3IgOiBHRU5FUkFUT1JcbiAgICB0aGlzLmV4cHJlc3Npb25zUHJlY2VkZW5jZSA9XG4gICAgICBzZXR1cC5leHByZXNzaW9uc1ByZWNlZGVuY2UgIT0gbnVsbFxuICAgICAgICA/IHNldHVwLmV4cHJlc3Npb25zUHJlY2VkZW5jZVxuICAgICAgICA6IEVYUFJFU1NJT05TX1BSRUNFREVOQ0VcbiAgICAvLyBGb3JtYXRpbmcgc2V0dXBcbiAgICB0aGlzLmluZGVudCA9IHNldHVwLmluZGVudCAhPSBudWxsID8gc2V0dXAuaW5kZW50IDogJyAgJ1xuICAgIHRoaXMubGluZUVuZCA9IHNldHVwLmxpbmVFbmQgIT0gbnVsbCA/IHNldHVwLmxpbmVFbmQgOiAnXFxuJ1xuICAgIHRoaXMuaW5kZW50TGV2ZWwgPVxuICAgICAgc2V0dXAuc3RhcnRpbmdJbmRlbnRMZXZlbCAhPSBudWxsID8gc2V0dXAuc3RhcnRpbmdJbmRlbnRMZXZlbCA6IDBcbiAgICB0aGlzLndyaXRlQ29tbWVudHMgPSBzZXR1cC5jb21tZW50cyA/IHNldHVwLmNvbW1lbnRzIDogZmFsc2VcbiAgICAvLyBTb3VyY2UgbWFwXG4gICAgaWYgKHNldHVwLnNvdXJjZU1hcCAhPSBudWxsKSB7XG4gICAgICB0aGlzLndyaXRlID1cbiAgICAgICAgc2V0dXAub3V0cHV0ID09IG51bGwgPyB0aGlzLndyaXRlQW5kTWFwIDogdGhpcy53cml0ZVRvU3RyZWFtQW5kTWFwXG4gICAgICB0aGlzLnNvdXJjZU1hcCA9IHNldHVwLnNvdXJjZU1hcFxuICAgICAgdGhpcy5saW5lID0gMVxuICAgICAgdGhpcy5jb2x1bW4gPSAwXG4gICAgICB0aGlzLmxpbmVFbmRTaXplID0gdGhpcy5saW5lRW5kLnNwbGl0KCdcXG4nKS5sZW5ndGggLSAxXG4gICAgICB0aGlzLm1hcHBpbmcgPSB7XG4gICAgICAgIG9yaWdpbmFsOiBudWxsLFxuICAgICAgICAvLyBVc2VzIHRoZSBlbnRpcmUgc3RhdGUgdG8gYXZvaWQgZ2VuZXJhdGluZyBlcGhlbWVyYWwgb2JqZWN0c1xuICAgICAgICBnZW5lcmF0ZWQ6IHRoaXMsXG4gICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgc291cmNlOiBzZXR1cC5zb3VyY2VNYXAuZmlsZSB8fCBzZXR1cC5zb3VyY2VNYXAuX2ZpbGUsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd3JpdGUoY29kZSkge1xuICAgIHRoaXMub3V0cHV0ICs9IGNvZGVcbiAgfVxuXG4gIHdyaXRlVG9TdHJlYW0oY29kZSkge1xuICAgIHRoaXMub3V0cHV0LndyaXRlKGNvZGUpXG4gIH1cblxuICB3cml0ZUFuZE1hcChjb2RlLCBub2RlKSB7XG4gICAgdGhpcy5vdXRwdXQgKz0gY29kZVxuICAgIHRoaXMubWFwKGNvZGUsIG5vZGUpXG4gIH1cblxuICB3cml0ZVRvU3RyZWFtQW5kTWFwKGNvZGUsIG5vZGUpIHtcbiAgICB0aGlzLm91dHB1dC53cml0ZShjb2RlKVxuICAgIHRoaXMubWFwKGNvZGUsIG5vZGUpXG4gIH1cblxuICBtYXAoY29kZSwgbm9kZSkge1xuICAgIGlmIChub2RlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgdHlwZSB9ID0gbm9kZVxuICAgICAgaWYgKHR5cGVbMF0gPT09ICdMJyAmJiB0eXBlWzJdID09PSAnbicpIHtcbiAgICAgICAgLy8gTGluZUNvbW1lbnRcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwXG4gICAgICAgIHRoaXMubGluZSsrXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKG5vZGUubG9jICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBtYXBwaW5nIH0gPSB0aGlzXG4gICAgICAgIG1hcHBpbmcub3JpZ2luYWwgPSBub2RlLmxvYy5zdGFydFxuICAgICAgICBtYXBwaW5nLm5hbWUgPSBub2RlLm5hbWVcbiAgICAgICAgdGhpcy5zb3VyY2VNYXAuYWRkTWFwcGluZyhtYXBwaW5nKVxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAodHlwZVswXSA9PT0gJ1QnICYmIHR5cGVbOF0gPT09ICdFJykgfHxcbiAgICAgICAgKHR5cGVbMF0gPT09ICdMJyAmJiB0eXBlWzFdID09PSAnaScgJiYgdHlwZW9mIG5vZGUudmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgKSB7XG4gICAgICAgIC8vIFRlbXBsYXRlRWxlbWVudCBvciBMaXRlcmFsIHN0cmluZyBub2RlXG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBjb2RlXG4gICAgICAgIGxldCB7IGNvbHVtbiwgbGluZSB9ID0gdGhpc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNvZGVbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSAwXG4gICAgICAgICAgICBsaW5lKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sdW1uKytcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW5cbiAgICAgICAgdGhpcy5saW5lID0gbGluZVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGNvZGVcbiAgICBjb25zdCB7IGxpbmVFbmQgfSA9IHRoaXNcbiAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmxpbmVFbmRTaXplID4gMCAmJlxuICAgICAgICAobGluZUVuZC5sZW5ndGggPT09IDFcbiAgICAgICAgICA/IGNvZGVbbGVuZ3RoIC0gMV0gPT09IGxpbmVFbmRcbiAgICAgICAgICA6IGNvZGUuZW5kc1dpdGgobGluZUVuZCkpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5saW5lICs9IHRoaXMubGluZUVuZFNpemVcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbHVtbiArPSBsZW5ndGhcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGUobm9kZSwgb3B0aW9ucykge1xuICAvKlxuICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcmVuZGVyZWQgY29kZSBvZiB0aGUgcHJvdmlkZWQgQVNUIGBub2RlYC5cbiAgVGhlIGBvcHRpb25zYCBhcmU6XG5cbiAgLSBgaW5kZW50YDogc3RyaW5nIHRvIHVzZSBmb3IgaW5kZW50YXRpb24gKGRlZmF1bHRzIHRvIGDikKPikKNgKVxuICAtIGBsaW5lRW5kYDogc3RyaW5nIHRvIHVzZSBmb3IgbGluZSBlbmRpbmdzIChkZWZhdWx0cyB0byBgXFxuYClcbiAgLSBgc3RhcnRpbmdJbmRlbnRMZXZlbGA6IGluZGVudCBsZXZlbCB0byBzdGFydCBmcm9tIChkZWZhdWx0cyB0byBgMGApXG4gIC0gYGNvbW1lbnRzYDogZ2VuZXJhdGUgY29tbWVudHMgaWYgYHRydWVgIChkZWZhdWx0cyB0byBgZmFsc2VgKVxuICAtIGBvdXRwdXRgOiBvdXRwdXQgc3RyZWFtIHRvIHdyaXRlIHRoZSByZW5kZXJlZCBjb2RlIHRvIChkZWZhdWx0cyB0byBgbnVsbGApXG4gIC0gYGdlbmVyYXRvcmA6IGN1c3RvbSBjb2RlIGdlbmVyYXRvciAoZGVmYXVsdHMgdG8gYEdFTkVSQVRPUmApXG4gIC0gYGV4cHJlc3Npb25zUHJlY2VkZW5jZWA6IGN1c3RvbSBtYXAgb2Ygbm9kZSB0eXBlcyBhbmQgdGhlaXIgcHJlY2VkZW5jZSBsZXZlbCAoZGVmYXVsdHMgdG8gYEVYUFJFU1NJT05TX1BSRUNFREVOQ0VgKVxuICAqL1xuICBjb25zdCBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKVxuICAvLyBUcmF2ZWwgdGhyb3VnaCB0aGUgQVNUIG5vZGUgYW5kIGdlbmVyYXRlIHRoZSBjb2RlXG4gIHN0YXRlLmdlbmVyYXRvcltub2RlLnR5cGVdKG5vZGUsIHN0YXRlKVxuICByZXR1cm4gc3RhdGUub3V0cHV0XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/astring@1.8.6/node_modules/astring/dist/astring.mjs\n");

/***/ })

};
;