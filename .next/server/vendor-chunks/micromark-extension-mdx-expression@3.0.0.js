"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-extension-mdx-expression@3.0.0";
exports.ids = ["vendor-chunks/micromark-extension-mdx-expression@3.0.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/micromark-extension-mdx-expression@3.0.0/node_modules/micromark-extension-mdx-expression/dev/lib/syntax.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/micromark-extension-mdx-expression@3.0.0/node_modules/micromark-extension-mdx-expression/dev/lib/syntax.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mdxExpression: () => (/* binding */ mdxExpression)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_factory_mdx_expression__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-factory-mdx-expression */ \"(ssr)/./node_modules/.pnpm/micromark-factory-mdx-expression@2.0.1/node_modules/micromark-factory-mdx-expression/dev/index.js\");\n/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-factory-space */ \"(ssr)/./node_modules/.pnpm/micromark-factory-space@2.0.0/node_modules/micromark-factory-space/dev/index.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-character */ \"(ssr)/./node_modules/.pnpm/micromark-util-character@2.1.0/node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/.pnpm/micromark-util-symbol@2.0.0/node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/.pnpm/micromark-util-symbol@2.0.0/node_modules/micromark-util-symbol/lib/types.js\");\n/**\n * @typedef {import('micromark-util-events-to-acorn').Acorn} Acorn\n * @typedef {import('micromark-util-events-to-acorn').AcornOptions} AcornOptions\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {Acorn | null | undefined} [acorn]\n *   Acorn parser to use (optional).\n * @property {AcornOptions | null | undefined} [acornOptions]\n *   Configuration for acorn (default: `{ecmaVersion: 2024, locations: true,\n *   sourceType: 'module'}`).\n *\n *   All fields except `locations` can be set.\n * @property {boolean | null | undefined} [addResult=false]\n *   Whether to add `estree` fields to tokens with results from acorn (default:\n *   `false`).\n * @property {boolean | null | undefined} [spread=false]\n *   Undocumented option to parse only a spread (used by\n *   `micromark-extension-mdx-jsx` to parse spread attributes) (default:\n *   `false`).\n * @property {boolean | null | undefined} [allowEmpty=true]\n *   Undocumented option to disallow empty attributes (used by\n *   `micromark-extension-mdx-jsx` to prohobit empty attribute values)\n *   (default: `false`).\n */\n\n\n\n\n\n\n\n/**\n * Create an extension for `micromark` to enable MDX expression syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable MDX\n *   expression syntax.\n */\nfunction mdxExpression(options) {\n  const options_ = options || {}\n  const addResult = options_.addResult\n  const acorn = options_.acorn\n  // Hidden: `micromark-extension-mdx-jsx` supports expressions in tags,\n  // and one of them is only “spread” elements.\n  // It also has expressions that are not allowed to be empty (`<x y={}/>`).\n  // Instead of duplicating code there, this are two small hidden feature here\n  // to test that behavior.\n  const spread = options_.spread\n  let allowEmpty = options_.allowEmpty\n  /** @type {AcornOptions} */\n  let acornOptions\n\n  if (allowEmpty === null || allowEmpty === undefined) {\n    allowEmpty = true\n  }\n\n  if (acorn) {\n    if (!acorn.parseExpressionAt) {\n      throw new Error(\n        'Expected a proper `acorn` instance passed in as `options.acorn`'\n      )\n    }\n\n    acornOptions = Object.assign(\n      {ecmaVersion: 2024, sourceType: 'module'},\n      options_.acornOptions\n    )\n  } else if (options_.acornOptions || options_.addResult) {\n    throw new Error('Expected an `acorn` instance passed in as `options.acorn`')\n  }\n\n  return {\n    flow: {\n      [micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace]: {\n        name: 'mdxFlowExpression',\n        tokenize: tokenizeFlowExpression,\n        concrete: true\n      }\n    },\n    text: {\n      [micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace]: {\n        name: 'mdxTextExpression',\n        tokenize: tokenizeTextExpression\n      }\n    }\n  }\n\n  /**\n   * MDX expression (flow).\n   *\n   * ```markdown\n   * > | {Math.PI}\n   *     ^^^^^^^^^\n   * ```\n   *\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeFlowExpression(effects, ok, nok) {\n    const self = this\n\n    return start\n\n    /**\n     * Start of an MDX expression (flow).\n     *\n     * ```markdown\n     * > | {Math.PI}\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      // To do: in `markdown-rs`, constructs need to parse the indent themselves.\n      // This should also be introduced in `micromark-js`.\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace, 'expected `{`')\n      return before(code)\n    }\n\n    /**\n     * After optional whitespace, before expression.\n     *\n     * ```markdown\n     * > | {Math.PI}\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function before(code) {\n      return micromark_factory_mdx_expression__WEBPACK_IMPORTED_MODULE_2__.factoryMdxExpression.call(\n        self,\n        effects,\n        after,\n        'mdxFlowExpression',\n        'mdxFlowExpressionMarker',\n        'mdxFlowExpressionChunk',\n        acorn,\n        acornOptions,\n        addResult,\n        spread,\n        allowEmpty\n      )(code)\n    }\n\n    /**\n     * After expression.\n     *\n     * ```markdown\n     * > | {Math.PI}\n     *              ^\n     * ```\n     *\n     * @type {State}\n     */\n    function after(code) {\n      return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code)\n        ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__.factorySpace)(effects, end, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.types.whitespace)(code)\n        : end(code)\n    }\n\n    /**\n     * After expression, after optional whitespace.\n     *\n     * ```markdown\n     * > | {Math.PI}␠␊\n     *               ^\n     * ```\n     *\n     * @type {State}\n     */\n    function end(code) {\n      // We want to allow tags directly after expressions.\n      //\n      // This case is useful:\n      //\n      // ```mdx\n      // <a>{b}</a>\n      // ```\n      //\n      // This case is not (very?) useful:\n      //\n      // ```mdx\n      // {a}<b/>\n      // ```\n      //\n      // …but it would be tougher than needed to disallow.\n      //\n      // To allow that, here we call the flow construct of\n      // `micromark-extension-mdx-jsx`, and there we call this one.\n      //\n      // It would introduce a cyclical interdependency if we test JSX and\n      // expressions here.\n      // Because the JSX extension already uses parts of this monorepo, we\n      // instead test it there.\n      const lessThanValue = self.parser.constructs.flow[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lessThan]\n      const constructs = Array.isArray(lessThanValue)\n        ? lessThanValue\n        : /* c8 ignore next 3 -- always a list when normalized. */\n        lessThanValue\n        ? [lessThanValue]\n        : []\n      const jsxTag = constructs.find(function (d) {\n        return d.name === 'mdxJsxFlowTag'\n      })\n\n      /* c8 ignore next 3 -- this is tested in `micromark-extension-mdx-jsx` */\n      if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lessThan && jsxTag) {\n        return effects.attempt(jsxTag, end, nok)(code)\n      }\n\n      return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code)\n        ? ok(code)\n        : nok(code)\n    }\n  }\n\n  /**\n   * MDX expression (text).\n   *\n   * ```markdown\n   * > | a {Math.PI} c.\n   *       ^^^^^^^^^\n   * ```\n   *\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeTextExpression(effects, ok) {\n    const self = this\n\n    return start\n\n    /**\n     * Start of an MDX expression (text).\n     *\n     * ```markdown\n     * > | a {Math.PI} c.\n     *       ^\n     * ```\n     *\n     *\n     * @type {State}\n     */\n    function start(code) {\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace, 'expected `{`')\n      return micromark_factory_mdx_expression__WEBPACK_IMPORTED_MODULE_2__.factoryMdxExpression.call(\n        self,\n        effects,\n        ok,\n        'mdxTextExpression',\n        'mdxTextExpressionMarker',\n        'mdxTextExpressionChunk',\n        acorn,\n        acornOptions,\n        addResult,\n        spread,\n        allowEmpty,\n        true\n      )(code)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbWljcm9tYXJrLWV4dGVuc2lvbi1tZHgtZXhwcmVzc2lvbkAzLjAuMC9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1tZHgtZXhwcmVzc2lvbi9kZXYvbGliL3N5bnRheC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQSxhQUFhLGdEQUFnRDtBQUM3RCxhQUFhLHVEQUF1RDtBQUNwRSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLGdEQUFnRDtBQUM3RCxhQUFhLDBDQUEwQztBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBLGNBQWMsaUNBQWlDO0FBQy9DLHlDQUF5QztBQUN6QywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFbUM7QUFDa0M7QUFDakI7QUFDc0I7QUFDeEI7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyx3Q0FBd0M7QUFDL0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLHdEQUFLO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxPQUFPLHdEQUFLO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDJDQUFNLFVBQVUsd0RBQUssNkJBQTZCO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxhQUFhLGtGQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGFBQWEsdUVBQWE7QUFDMUIsVUFBVSxxRUFBWSxlQUFlLHdEQUFLO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsRUFBRTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsd0RBQUs7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxtQkFBbUIsd0RBQUs7QUFDeEI7QUFDQTs7QUFFQSxzQkFBc0Isd0RBQUssUUFBUSw0RUFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLE1BQU0sMkNBQU0sVUFBVSx3REFBSyw2QkFBNkI7QUFDeEQsYUFBYSxrRkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYm1fMjAyNC8uL25vZGVfbW9kdWxlcy8ucG5wbS9taWNyb21hcmstZXh0ZW5zaW9uLW1keC1leHByZXNzaW9uQDMuMC4wL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLW1keC1leHByZXNzaW9uL2Rldi9saWIvc3ludGF4LmpzPzFlNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC1ldmVudHMtdG8tYWNvcm4nKS5BY29ybn0gQWNvcm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLWV2ZW50cy10by1hY29ybicpLkFjb3JuT3B0aW9uc30gQWNvcm5PcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV4dGVuc2lvbn0gRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZUNvbnRleHR9IFRva2VuaXplQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0Fjb3JuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2Fjb3JuXVxuICogICBBY29ybiBwYXJzZXIgdG8gdXNlIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0Fjb3JuT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFthY29ybk9wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gZm9yIGFjb3JuIChkZWZhdWx0OiBge2VjbWFWZXJzaW9uOiAyMDI0LCBsb2NhdGlvbnM6IHRydWUsXG4gKiAgIHNvdXJjZVR5cGU6ICdtb2R1bGUnfWApLlxuICpcbiAqICAgQWxsIGZpZWxkcyBleGNlcHQgYGxvY2F0aW9uc2AgY2FuIGJlIHNldC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFthZGRSZXN1bHQ9ZmFsc2VdXG4gKiAgIFdoZXRoZXIgdG8gYWRkIGBlc3RyZWVgIGZpZWxkcyB0byB0b2tlbnMgd2l0aCByZXN1bHRzIGZyb20gYWNvcm4gKGRlZmF1bHQ6XG4gKiAgIGBmYWxzZWApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3NwcmVhZD1mYWxzZV1cbiAqICAgVW5kb2N1bWVudGVkIG9wdGlvbiB0byBwYXJzZSBvbmx5IGEgc3ByZWFkICh1c2VkIGJ5XG4gKiAgIGBtaWNyb21hcmstZXh0ZW5zaW9uLW1keC1qc3hgIHRvIHBhcnNlIHNwcmVhZCBhdHRyaWJ1dGVzKSAoZGVmYXVsdDpcbiAqICAgYGZhbHNlYCkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbYWxsb3dFbXB0eT10cnVlXVxuICogICBVbmRvY3VtZW50ZWQgb3B0aW9uIHRvIGRpc2FsbG93IGVtcHR5IGF0dHJpYnV0ZXMgKHVzZWQgYnlcbiAqICAgYG1pY3JvbWFyay1leHRlbnNpb24tbWR4LWpzeGAgdG8gcHJvaG9iaXQgZW1wdHkgYXR0cmlidXRlIHZhbHVlcylcbiAqICAgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge2ZhY3RvcnlNZHhFeHByZXNzaW9ufSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1tZHgtZXhwcmVzc2lvbidcbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nLCBtYXJrZG93blNwYWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge2NvZGVzLCB0eXBlc30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sJ1xuXG4vKipcbiAqIENyZWF0ZSBhbiBleHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRvIGVuYWJsZSBNRFggZXhwcmVzc2lvbiBzeW50YXguXG4gKlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtFeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdGhhdCBjYW4gYmUgcGFzc2VkIGluIGBleHRlbnNpb25zYCB0byBlbmFibGUgTURYXG4gKiAgIGV4cHJlc3Npb24gc3ludGF4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWR4RXhwcmVzc2lvbihvcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnNfID0gb3B0aW9ucyB8fCB7fVxuICBjb25zdCBhZGRSZXN1bHQgPSBvcHRpb25zXy5hZGRSZXN1bHRcbiAgY29uc3QgYWNvcm4gPSBvcHRpb25zXy5hY29yblxuICAvLyBIaWRkZW46IGBtaWNyb21hcmstZXh0ZW5zaW9uLW1keC1qc3hgIHN1cHBvcnRzIGV4cHJlc3Npb25zIGluIHRhZ3MsXG4gIC8vIGFuZCBvbmUgb2YgdGhlbSBpcyBvbmx5IOKAnHNwcmVhZOKAnSBlbGVtZW50cy5cbiAgLy8gSXQgYWxzbyBoYXMgZXhwcmVzc2lvbnMgdGhhdCBhcmUgbm90IGFsbG93ZWQgdG8gYmUgZW1wdHkgKGA8eCB5PXt9Lz5gKS5cbiAgLy8gSW5zdGVhZCBvZiBkdXBsaWNhdGluZyBjb2RlIHRoZXJlLCB0aGlzIGFyZSB0d28gc21hbGwgaGlkZGVuIGZlYXR1cmUgaGVyZVxuICAvLyB0byB0ZXN0IHRoYXQgYmVoYXZpb3IuXG4gIGNvbnN0IHNwcmVhZCA9IG9wdGlvbnNfLnNwcmVhZFxuICBsZXQgYWxsb3dFbXB0eSA9IG9wdGlvbnNfLmFsbG93RW1wdHlcbiAgLyoqIEB0eXBlIHtBY29ybk9wdGlvbnN9ICovXG4gIGxldCBhY29ybk9wdGlvbnNcblxuICBpZiAoYWxsb3dFbXB0eSA9PT0gbnVsbCB8fCBhbGxvd0VtcHR5ID09PSB1bmRlZmluZWQpIHtcbiAgICBhbGxvd0VtcHR5ID0gdHJ1ZVxuICB9XG5cbiAgaWYgKGFjb3JuKSB7XG4gICAgaWYgKCFhY29ybi5wYXJzZUV4cHJlc3Npb25BdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgYSBwcm9wZXIgYGFjb3JuYCBpbnN0YW5jZSBwYXNzZWQgaW4gYXMgYG9wdGlvbnMuYWNvcm5gJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGFjb3JuT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7ZWNtYVZlcnNpb246IDIwMjQsIHNvdXJjZVR5cGU6ICdtb2R1bGUnfSxcbiAgICAgIG9wdGlvbnNfLmFjb3JuT3B0aW9uc1xuICAgIClcbiAgfSBlbHNlIGlmIChvcHRpb25zXy5hY29ybk9wdGlvbnMgfHwgb3B0aW9uc18uYWRkUmVzdWx0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBgYWNvcm5gIGluc3RhbmNlIHBhc3NlZCBpbiBhcyBgb3B0aW9ucy5hY29ybmAnKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmbG93OiB7XG4gICAgICBbY29kZXMubGVmdEN1cmx5QnJhY2VdOiB7XG4gICAgICAgIG5hbWU6ICdtZHhGbG93RXhwcmVzc2lvbicsXG4gICAgICAgIHRva2VuaXplOiB0b2tlbml6ZUZsb3dFeHByZXNzaW9uLFxuICAgICAgICBjb25jcmV0ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgW2NvZGVzLmxlZnRDdXJseUJyYWNlXToge1xuICAgICAgICBuYW1lOiAnbWR4VGV4dEV4cHJlc3Npb24nLFxuICAgICAgICB0b2tlbml6ZTogdG9rZW5pemVUZXh0RXhwcmVzc2lvblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNRFggZXhwcmVzc2lvbiAoZmxvdykuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB7TWF0aC5QSX1cbiAgICogICAgIF5eXl5eXl5eXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAgICogQHR5cGUge1Rva2VuaXplcn1cbiAgICovXG4gIGZ1bmN0aW9uIHRva2VuaXplRmxvd0V4cHJlc3Npb24oZWZmZWN0cywgb2ssIG5vaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgICByZXR1cm4gc3RhcnRcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IG9mIGFuIE1EWCBleHByZXNzaW9uIChmbG93KS5cbiAgICAgKlxuICAgICAqIGBgYG1hcmtkb3duXG4gICAgICogPiB8IHtNYXRoLlBJfVxuICAgICAqICAgICBeXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RhdGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgLy8gVG8gZG86IGluIGBtYXJrZG93bi1yc2AsIGNvbnN0cnVjdHMgbmVlZCB0byBwYXJzZSB0aGUgaW5kZW50IHRoZW1zZWx2ZXMuXG4gICAgICAvLyBUaGlzIHNob3VsZCBhbHNvIGJlIGludHJvZHVjZWQgaW4gYG1pY3JvbWFyay1qc2AuXG4gICAgICBhc3NlcnQoY29kZSA9PT0gY29kZXMubGVmdEN1cmx5QnJhY2UsICdleHBlY3RlZCBge2AnKVxuICAgICAgcmV0dXJuIGJlZm9yZShjb2RlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFmdGVyIG9wdGlvbmFsIHdoaXRlc3BhY2UsIGJlZm9yZSBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogYGBgbWFya2Rvd25cbiAgICAgKiA+IHwge01hdGguUEl9XG4gICAgICogICAgIF5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdGF0ZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUoY29kZSkge1xuICAgICAgcmV0dXJuIGZhY3RvcnlNZHhFeHByZXNzaW9uLmNhbGwoXG4gICAgICAgIHNlbGYsXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIGFmdGVyLFxuICAgICAgICAnbWR4Rmxvd0V4cHJlc3Npb24nLFxuICAgICAgICAnbWR4Rmxvd0V4cHJlc3Npb25NYXJrZXInLFxuICAgICAgICAnbWR4Rmxvd0V4cHJlc3Npb25DaHVuaycsXG4gICAgICAgIGFjb3JuLFxuICAgICAgICBhY29ybk9wdGlvbnMsXG4gICAgICAgIGFkZFJlc3VsdCxcbiAgICAgICAgc3ByZWFkLFxuICAgICAgICBhbGxvd0VtcHR5XG4gICAgICApKGNvZGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWZ0ZXIgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIGBgYG1hcmtkb3duXG4gICAgICogPiB8IHtNYXRoLlBJfVxuICAgICAqICAgICAgICAgICAgICBeXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RhdGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgICAgcmV0dXJuIG1hcmtkb3duU3BhY2UoY29kZSlcbiAgICAgICAgPyBmYWN0b3J5U3BhY2UoZWZmZWN0cywgZW5kLCB0eXBlcy53aGl0ZXNwYWNlKShjb2RlKVxuICAgICAgICA6IGVuZChjb2RlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFmdGVyIGV4cHJlc3Npb24sIGFmdGVyIG9wdGlvbmFsIHdoaXRlc3BhY2UuXG4gICAgICpcbiAgICAgKiBgYGBtYXJrZG93blxuICAgICAqID4gfCB7TWF0aC5QSX3ikKDikIpcbiAgICAgKiAgICAgICAgICAgICAgIF5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdGF0ZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmQoY29kZSkge1xuICAgICAgLy8gV2Ugd2FudCB0byBhbGxvdyB0YWdzIGRpcmVjdGx5IGFmdGVyIGV4cHJlc3Npb25zLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgY2FzZSBpcyB1c2VmdWw6XG4gICAgICAvL1xuICAgICAgLy8gYGBgbWR4XG4gICAgICAvLyA8YT57Yn08L2E+XG4gICAgICAvLyBgYGBcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGNhc2UgaXMgbm90ICh2ZXJ5PykgdXNlZnVsOlxuICAgICAgLy9cbiAgICAgIC8vIGBgYG1keFxuICAgICAgLy8ge2F9PGIvPlxuICAgICAgLy8gYGBgXG4gICAgICAvL1xuICAgICAgLy8g4oCmYnV0IGl0IHdvdWxkIGJlIHRvdWdoZXIgdGhhbiBuZWVkZWQgdG8gZGlzYWxsb3cuXG4gICAgICAvL1xuICAgICAgLy8gVG8gYWxsb3cgdGhhdCwgaGVyZSB3ZSBjYWxsIHRoZSBmbG93IGNvbnN0cnVjdCBvZlxuICAgICAgLy8gYG1pY3JvbWFyay1leHRlbnNpb24tbWR4LWpzeGAsIGFuZCB0aGVyZSB3ZSBjYWxsIHRoaXMgb25lLlxuICAgICAgLy9cbiAgICAgIC8vIEl0IHdvdWxkIGludHJvZHVjZSBhIGN5Y2xpY2FsIGludGVyZGVwZW5kZW5jeSBpZiB3ZSB0ZXN0IEpTWCBhbmRcbiAgICAgIC8vIGV4cHJlc3Npb25zIGhlcmUuXG4gICAgICAvLyBCZWNhdXNlIHRoZSBKU1ggZXh0ZW5zaW9uIGFscmVhZHkgdXNlcyBwYXJ0cyBvZiB0aGlzIG1vbm9yZXBvLCB3ZVxuICAgICAgLy8gaW5zdGVhZCB0ZXN0IGl0IHRoZXJlLlxuICAgICAgY29uc3QgbGVzc1RoYW5WYWx1ZSA9IHNlbGYucGFyc2VyLmNvbnN0cnVjdHMuZmxvd1tjb2Rlcy5sZXNzVGhhbl1cbiAgICAgIGNvbnN0IGNvbnN0cnVjdHMgPSBBcnJheS5pc0FycmF5KGxlc3NUaGFuVmFsdWUpXG4gICAgICAgID8gbGVzc1RoYW5WYWx1ZVxuICAgICAgICA6IC8qIGM4IGlnbm9yZSBuZXh0IDMgLS0gYWx3YXlzIGEgbGlzdCB3aGVuIG5vcm1hbGl6ZWQuICovXG4gICAgICAgIGxlc3NUaGFuVmFsdWVcbiAgICAgICAgPyBbbGVzc1RoYW5WYWx1ZV1cbiAgICAgICAgOiBbXVxuICAgICAgY29uc3QganN4VGFnID0gY29uc3RydWN0cy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLm5hbWUgPT09ICdtZHhKc3hGbG93VGFnJ1xuICAgICAgfSlcblxuICAgICAgLyogYzggaWdub3JlIG5leHQgMyAtLSB0aGlzIGlzIHRlc3RlZCBpbiBgbWljcm9tYXJrLWV4dGVuc2lvbi1tZHgtanN4YCAqL1xuICAgICAgaWYgKGNvZGUgPT09IGNvZGVzLmxlc3NUaGFuICYmIGpzeFRhZykge1xuICAgICAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KGpzeFRhZywgZW5kLCBub2spKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlID09PSBjb2Rlcy5lb2YgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpXG4gICAgICAgID8gb2soY29kZSlcbiAgICAgICAgOiBub2soY29kZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTURYIGV4cHJlc3Npb24gKHRleHQpLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgYSB7TWF0aC5QSX0gYy5cbiAgICogICAgICAgXl5eXl5eXl5eXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICAgKiBAdHlwZSB7VG9rZW5pemVyfVxuICAgKi9cbiAgZnVuY3Rpb24gdG9rZW5pemVUZXh0RXhwcmVzc2lvbihlZmZlY3RzLCBvaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgICByZXR1cm4gc3RhcnRcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IG9mIGFuIE1EWCBleHByZXNzaW9uICh0ZXh0KS5cbiAgICAgKlxuICAgICAqIGBgYG1hcmtkb3duXG4gICAgICogPiB8IGEge01hdGguUEl9IGMuXG4gICAgICogICAgICAgXlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RhdGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgYXNzZXJ0KGNvZGUgPT09IGNvZGVzLmxlZnRDdXJseUJyYWNlLCAnZXhwZWN0ZWQgYHtgJylcbiAgICAgIHJldHVybiBmYWN0b3J5TWR4RXhwcmVzc2lvbi5jYWxsKFxuICAgICAgICBzZWxmLFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBvayxcbiAgICAgICAgJ21keFRleHRFeHByZXNzaW9uJyxcbiAgICAgICAgJ21keFRleHRFeHByZXNzaW9uTWFya2VyJyxcbiAgICAgICAgJ21keFRleHRFeHByZXNzaW9uQ2h1bmsnLFxuICAgICAgICBhY29ybixcbiAgICAgICAgYWNvcm5PcHRpb25zLFxuICAgICAgICBhZGRSZXN1bHQsXG4gICAgICAgIHNwcmVhZCxcbiAgICAgICAgYWxsb3dFbXB0eSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKShjb2RlKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/micromark-extension-mdx-expression@3.0.0/node_modules/micromark-extension-mdx-expression/dev/lib/syntax.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/micromark-extension-mdx-expression@3.0.0/node_modules/micromark-extension-mdx-expression/dev/lib/syntax.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/micromark-extension-mdx-expression@3.0.0/node_modules/micromark-extension-mdx-expression/dev/lib/syntax.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mdxExpression: () => (/* binding */ mdxExpression)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(rsc)/./node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_factory_mdx_expression__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-factory-mdx-expression */ \"(rsc)/./node_modules/.pnpm/micromark-factory-mdx-expression@2.0.1/node_modules/micromark-factory-mdx-expression/dev/index.js\");\n/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-factory-space */ \"(rsc)/./node_modules/.pnpm/micromark-factory-space@2.0.0/node_modules/micromark-factory-space/dev/index.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-character */ \"(rsc)/./node_modules/.pnpm/micromark-util-character@2.1.0/node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/./node_modules/.pnpm/micromark-util-symbol@2.0.0/node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/./node_modules/.pnpm/micromark-util-symbol@2.0.0/node_modules/micromark-util-symbol/lib/types.js\");\n/**\n * @typedef {import('micromark-util-events-to-acorn').Acorn} Acorn\n * @typedef {import('micromark-util-events-to-acorn').AcornOptions} AcornOptions\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {Acorn | null | undefined} [acorn]\n *   Acorn parser to use (optional).\n * @property {AcornOptions | null | undefined} [acornOptions]\n *   Configuration for acorn (default: `{ecmaVersion: 2024, locations: true,\n *   sourceType: 'module'}`).\n *\n *   All fields except `locations` can be set.\n * @property {boolean | null | undefined} [addResult=false]\n *   Whether to add `estree` fields to tokens with results from acorn (default:\n *   `false`).\n * @property {boolean | null | undefined} [spread=false]\n *   Undocumented option to parse only a spread (used by\n *   `micromark-extension-mdx-jsx` to parse spread attributes) (default:\n *   `false`).\n * @property {boolean | null | undefined} [allowEmpty=true]\n *   Undocumented option to disallow empty attributes (used by\n *   `micromark-extension-mdx-jsx` to prohobit empty attribute values)\n *   (default: `false`).\n */\n\n\n\n\n\n\n\n/**\n * Create an extension for `micromark` to enable MDX expression syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable MDX\n *   expression syntax.\n */\nfunction mdxExpression(options) {\n  const options_ = options || {}\n  const addResult = options_.addResult\n  const acorn = options_.acorn\n  // Hidden: `micromark-extension-mdx-jsx` supports expressions in tags,\n  // and one of them is only “spread” elements.\n  // It also has expressions that are not allowed to be empty (`<x y={}/>`).\n  // Instead of duplicating code there, this are two small hidden feature here\n  // to test that behavior.\n  const spread = options_.spread\n  let allowEmpty = options_.allowEmpty\n  /** @type {AcornOptions} */\n  let acornOptions\n\n  if (allowEmpty === null || allowEmpty === undefined) {\n    allowEmpty = true\n  }\n\n  if (acorn) {\n    if (!acorn.parseExpressionAt) {\n      throw new Error(\n        'Expected a proper `acorn` instance passed in as `options.acorn`'\n      )\n    }\n\n    acornOptions = Object.assign(\n      {ecmaVersion: 2024, sourceType: 'module'},\n      options_.acornOptions\n    )\n  } else if (options_.acornOptions || options_.addResult) {\n    throw new Error('Expected an `acorn` instance passed in as `options.acorn`')\n  }\n\n  return {\n    flow: {\n      [micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace]: {\n        name: 'mdxFlowExpression',\n        tokenize: tokenizeFlowExpression,\n        concrete: true\n      }\n    },\n    text: {\n      [micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace]: {\n        name: 'mdxTextExpression',\n        tokenize: tokenizeTextExpression\n      }\n    }\n  }\n\n  /**\n   * MDX expression (flow).\n   *\n   * ```markdown\n   * > | {Math.PI}\n   *     ^^^^^^^^^\n   * ```\n   *\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeFlowExpression(effects, ok, nok) {\n    const self = this\n\n    return start\n\n    /**\n     * Start of an MDX expression (flow).\n     *\n     * ```markdown\n     * > | {Math.PI}\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      // To do: in `markdown-rs`, constructs need to parse the indent themselves.\n      // This should also be introduced in `micromark-js`.\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace, 'expected `{`')\n      return before(code)\n    }\n\n    /**\n     * After optional whitespace, before expression.\n     *\n     * ```markdown\n     * > | {Math.PI}\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function before(code) {\n      return micromark_factory_mdx_expression__WEBPACK_IMPORTED_MODULE_2__.factoryMdxExpression.call(\n        self,\n        effects,\n        after,\n        'mdxFlowExpression',\n        'mdxFlowExpressionMarker',\n        'mdxFlowExpressionChunk',\n        acorn,\n        acornOptions,\n        addResult,\n        spread,\n        allowEmpty\n      )(code)\n    }\n\n    /**\n     * After expression.\n     *\n     * ```markdown\n     * > | {Math.PI}\n     *              ^\n     * ```\n     *\n     * @type {State}\n     */\n    function after(code) {\n      return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code)\n        ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__.factorySpace)(effects, end, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.types.whitespace)(code)\n        : end(code)\n    }\n\n    /**\n     * After expression, after optional whitespace.\n     *\n     * ```markdown\n     * > | {Math.PI}␠␊\n     *               ^\n     * ```\n     *\n     * @type {State}\n     */\n    function end(code) {\n      // We want to allow tags directly after expressions.\n      //\n      // This case is useful:\n      //\n      // ```mdx\n      // <a>{b}</a>\n      // ```\n      //\n      // This case is not (very?) useful:\n      //\n      // ```mdx\n      // {a}<b/>\n      // ```\n      //\n      // …but it would be tougher than needed to disallow.\n      //\n      // To allow that, here we call the flow construct of\n      // `micromark-extension-mdx-jsx`, and there we call this one.\n      //\n      // It would introduce a cyclical interdependency if we test JSX and\n      // expressions here.\n      // Because the JSX extension already uses parts of this monorepo, we\n      // instead test it there.\n      const lessThanValue = self.parser.constructs.flow[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lessThan]\n      const constructs = Array.isArray(lessThanValue)\n        ? lessThanValue\n        : /* c8 ignore next 3 -- always a list when normalized. */\n        lessThanValue\n        ? [lessThanValue]\n        : []\n      const jsxTag = constructs.find(function (d) {\n        return d.name === 'mdxJsxFlowTag'\n      })\n\n      /* c8 ignore next 3 -- this is tested in `micromark-extension-mdx-jsx` */\n      if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lessThan && jsxTag) {\n        return effects.attempt(jsxTag, end, nok)(code)\n      }\n\n      return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code)\n        ? ok(code)\n        : nok(code)\n    }\n  }\n\n  /**\n   * MDX expression (text).\n   *\n   * ```markdown\n   * > | a {Math.PI} c.\n   *       ^^^^^^^^^\n   * ```\n   *\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeTextExpression(effects, ok) {\n    const self = this\n\n    return start\n\n    /**\n     * Start of an MDX expression (text).\n     *\n     * ```markdown\n     * > | a {Math.PI} c.\n     *       ^\n     * ```\n     *\n     *\n     * @type {State}\n     */\n    function start(code) {\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace, 'expected `{`')\n      return micromark_factory_mdx_expression__WEBPACK_IMPORTED_MODULE_2__.factoryMdxExpression.call(\n        self,\n        effects,\n        ok,\n        'mdxTextExpression',\n        'mdxTextExpressionMarker',\n        'mdxTextExpressionChunk',\n        acorn,\n        acornOptions,\n        addResult,\n        spread,\n        allowEmpty,\n        true\n      )(code)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vbWljcm9tYXJrLWV4dGVuc2lvbi1tZHgtZXhwcmVzc2lvbkAzLjAuMC9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1tZHgtZXhwcmVzc2lvbi9kZXYvbGliL3N5bnRheC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQSxhQUFhLGdEQUFnRDtBQUM3RCxhQUFhLHVEQUF1RDtBQUNwRSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLGdEQUFnRDtBQUM3RCxhQUFhLDBDQUEwQztBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBLGNBQWMsaUNBQWlDO0FBQy9DLHlDQUF5QztBQUN6QywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFbUM7QUFDa0M7QUFDakI7QUFDc0I7QUFDeEI7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyx3Q0FBd0M7QUFDL0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLHdEQUFLO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxPQUFPLHdEQUFLO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDJDQUFNLFVBQVUsd0RBQUssNkJBQTZCO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxhQUFhLGtGQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGFBQWEsdUVBQWE7QUFDMUIsVUFBVSxxRUFBWSxlQUFlLHdEQUFLO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsRUFBRTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsd0RBQUs7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxtQkFBbUIsd0RBQUs7QUFDeEI7QUFDQTs7QUFFQSxzQkFBc0Isd0RBQUssUUFBUSw0RUFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLE1BQU0sMkNBQU0sVUFBVSx3REFBSyw2QkFBNkI7QUFDeEQsYUFBYSxrRkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYm1fMjAyNC8uL25vZGVfbW9kdWxlcy8ucG5wbS9taWNyb21hcmstZXh0ZW5zaW9uLW1keC1leHByZXNzaW9uQDMuMC4wL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLW1keC1leHByZXNzaW9uL2Rldi9saWIvc3ludGF4LmpzPzZiMjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC1ldmVudHMtdG8tYWNvcm4nKS5BY29ybn0gQWNvcm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLWV2ZW50cy10by1hY29ybicpLkFjb3JuT3B0aW9uc30gQWNvcm5PcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV4dGVuc2lvbn0gRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZUNvbnRleHR9IFRva2VuaXplQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0Fjb3JuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2Fjb3JuXVxuICogICBBY29ybiBwYXJzZXIgdG8gdXNlIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0Fjb3JuT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFthY29ybk9wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gZm9yIGFjb3JuIChkZWZhdWx0OiBge2VjbWFWZXJzaW9uOiAyMDI0LCBsb2NhdGlvbnM6IHRydWUsXG4gKiAgIHNvdXJjZVR5cGU6ICdtb2R1bGUnfWApLlxuICpcbiAqICAgQWxsIGZpZWxkcyBleGNlcHQgYGxvY2F0aW9uc2AgY2FuIGJlIHNldC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFthZGRSZXN1bHQ9ZmFsc2VdXG4gKiAgIFdoZXRoZXIgdG8gYWRkIGBlc3RyZWVgIGZpZWxkcyB0byB0b2tlbnMgd2l0aCByZXN1bHRzIGZyb20gYWNvcm4gKGRlZmF1bHQ6XG4gKiAgIGBmYWxzZWApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3NwcmVhZD1mYWxzZV1cbiAqICAgVW5kb2N1bWVudGVkIG9wdGlvbiB0byBwYXJzZSBvbmx5IGEgc3ByZWFkICh1c2VkIGJ5XG4gKiAgIGBtaWNyb21hcmstZXh0ZW5zaW9uLW1keC1qc3hgIHRvIHBhcnNlIHNwcmVhZCBhdHRyaWJ1dGVzKSAoZGVmYXVsdDpcbiAqICAgYGZhbHNlYCkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbYWxsb3dFbXB0eT10cnVlXVxuICogICBVbmRvY3VtZW50ZWQgb3B0aW9uIHRvIGRpc2FsbG93IGVtcHR5IGF0dHJpYnV0ZXMgKHVzZWQgYnlcbiAqICAgYG1pY3JvbWFyay1leHRlbnNpb24tbWR4LWpzeGAgdG8gcHJvaG9iaXQgZW1wdHkgYXR0cmlidXRlIHZhbHVlcylcbiAqICAgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge2ZhY3RvcnlNZHhFeHByZXNzaW9ufSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1tZHgtZXhwcmVzc2lvbidcbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nLCBtYXJrZG93blNwYWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge2NvZGVzLCB0eXBlc30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sJ1xuXG4vKipcbiAqIENyZWF0ZSBhbiBleHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRvIGVuYWJsZSBNRFggZXhwcmVzc2lvbiBzeW50YXguXG4gKlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtFeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdGhhdCBjYW4gYmUgcGFzc2VkIGluIGBleHRlbnNpb25zYCB0byBlbmFibGUgTURYXG4gKiAgIGV4cHJlc3Npb24gc3ludGF4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWR4RXhwcmVzc2lvbihvcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnNfID0gb3B0aW9ucyB8fCB7fVxuICBjb25zdCBhZGRSZXN1bHQgPSBvcHRpb25zXy5hZGRSZXN1bHRcbiAgY29uc3QgYWNvcm4gPSBvcHRpb25zXy5hY29yblxuICAvLyBIaWRkZW46IGBtaWNyb21hcmstZXh0ZW5zaW9uLW1keC1qc3hgIHN1cHBvcnRzIGV4cHJlc3Npb25zIGluIHRhZ3MsXG4gIC8vIGFuZCBvbmUgb2YgdGhlbSBpcyBvbmx5IOKAnHNwcmVhZOKAnSBlbGVtZW50cy5cbiAgLy8gSXQgYWxzbyBoYXMgZXhwcmVzc2lvbnMgdGhhdCBhcmUgbm90IGFsbG93ZWQgdG8gYmUgZW1wdHkgKGA8eCB5PXt9Lz5gKS5cbiAgLy8gSW5zdGVhZCBvZiBkdXBsaWNhdGluZyBjb2RlIHRoZXJlLCB0aGlzIGFyZSB0d28gc21hbGwgaGlkZGVuIGZlYXR1cmUgaGVyZVxuICAvLyB0byB0ZXN0IHRoYXQgYmVoYXZpb3IuXG4gIGNvbnN0IHNwcmVhZCA9IG9wdGlvbnNfLnNwcmVhZFxuICBsZXQgYWxsb3dFbXB0eSA9IG9wdGlvbnNfLmFsbG93RW1wdHlcbiAgLyoqIEB0eXBlIHtBY29ybk9wdGlvbnN9ICovXG4gIGxldCBhY29ybk9wdGlvbnNcblxuICBpZiAoYWxsb3dFbXB0eSA9PT0gbnVsbCB8fCBhbGxvd0VtcHR5ID09PSB1bmRlZmluZWQpIHtcbiAgICBhbGxvd0VtcHR5ID0gdHJ1ZVxuICB9XG5cbiAgaWYgKGFjb3JuKSB7XG4gICAgaWYgKCFhY29ybi5wYXJzZUV4cHJlc3Npb25BdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgYSBwcm9wZXIgYGFjb3JuYCBpbnN0YW5jZSBwYXNzZWQgaW4gYXMgYG9wdGlvbnMuYWNvcm5gJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGFjb3JuT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7ZWNtYVZlcnNpb246IDIwMjQsIHNvdXJjZVR5cGU6ICdtb2R1bGUnfSxcbiAgICAgIG9wdGlvbnNfLmFjb3JuT3B0aW9uc1xuICAgIClcbiAgfSBlbHNlIGlmIChvcHRpb25zXy5hY29ybk9wdGlvbnMgfHwgb3B0aW9uc18uYWRkUmVzdWx0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBgYWNvcm5gIGluc3RhbmNlIHBhc3NlZCBpbiBhcyBgb3B0aW9ucy5hY29ybmAnKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmbG93OiB7XG4gICAgICBbY29kZXMubGVmdEN1cmx5QnJhY2VdOiB7XG4gICAgICAgIG5hbWU6ICdtZHhGbG93RXhwcmVzc2lvbicsXG4gICAgICAgIHRva2VuaXplOiB0b2tlbml6ZUZsb3dFeHByZXNzaW9uLFxuICAgICAgICBjb25jcmV0ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgW2NvZGVzLmxlZnRDdXJseUJyYWNlXToge1xuICAgICAgICBuYW1lOiAnbWR4VGV4dEV4cHJlc3Npb24nLFxuICAgICAgICB0b2tlbml6ZTogdG9rZW5pemVUZXh0RXhwcmVzc2lvblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNRFggZXhwcmVzc2lvbiAoZmxvdykuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB7TWF0aC5QSX1cbiAgICogICAgIF5eXl5eXl5eXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAgICogQHR5cGUge1Rva2VuaXplcn1cbiAgICovXG4gIGZ1bmN0aW9uIHRva2VuaXplRmxvd0V4cHJlc3Npb24oZWZmZWN0cywgb2ssIG5vaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgICByZXR1cm4gc3RhcnRcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IG9mIGFuIE1EWCBleHByZXNzaW9uIChmbG93KS5cbiAgICAgKlxuICAgICAqIGBgYG1hcmtkb3duXG4gICAgICogPiB8IHtNYXRoLlBJfVxuICAgICAqICAgICBeXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RhdGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgLy8gVG8gZG86IGluIGBtYXJrZG93bi1yc2AsIGNvbnN0cnVjdHMgbmVlZCB0byBwYXJzZSB0aGUgaW5kZW50IHRoZW1zZWx2ZXMuXG4gICAgICAvLyBUaGlzIHNob3VsZCBhbHNvIGJlIGludHJvZHVjZWQgaW4gYG1pY3JvbWFyay1qc2AuXG4gICAgICBhc3NlcnQoY29kZSA9PT0gY29kZXMubGVmdEN1cmx5QnJhY2UsICdleHBlY3RlZCBge2AnKVxuICAgICAgcmV0dXJuIGJlZm9yZShjb2RlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFmdGVyIG9wdGlvbmFsIHdoaXRlc3BhY2UsIGJlZm9yZSBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogYGBgbWFya2Rvd25cbiAgICAgKiA+IHwge01hdGguUEl9XG4gICAgICogICAgIF5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdGF0ZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUoY29kZSkge1xuICAgICAgcmV0dXJuIGZhY3RvcnlNZHhFeHByZXNzaW9uLmNhbGwoXG4gICAgICAgIHNlbGYsXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIGFmdGVyLFxuICAgICAgICAnbWR4Rmxvd0V4cHJlc3Npb24nLFxuICAgICAgICAnbWR4Rmxvd0V4cHJlc3Npb25NYXJrZXInLFxuICAgICAgICAnbWR4Rmxvd0V4cHJlc3Npb25DaHVuaycsXG4gICAgICAgIGFjb3JuLFxuICAgICAgICBhY29ybk9wdGlvbnMsXG4gICAgICAgIGFkZFJlc3VsdCxcbiAgICAgICAgc3ByZWFkLFxuICAgICAgICBhbGxvd0VtcHR5XG4gICAgICApKGNvZGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWZ0ZXIgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIGBgYG1hcmtkb3duXG4gICAgICogPiB8IHtNYXRoLlBJfVxuICAgICAqICAgICAgICAgICAgICBeXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RhdGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgICAgcmV0dXJuIG1hcmtkb3duU3BhY2UoY29kZSlcbiAgICAgICAgPyBmYWN0b3J5U3BhY2UoZWZmZWN0cywgZW5kLCB0eXBlcy53aGl0ZXNwYWNlKShjb2RlKVxuICAgICAgICA6IGVuZChjb2RlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFmdGVyIGV4cHJlc3Npb24sIGFmdGVyIG9wdGlvbmFsIHdoaXRlc3BhY2UuXG4gICAgICpcbiAgICAgKiBgYGBtYXJrZG93blxuICAgICAqID4gfCB7TWF0aC5QSX3ikKDikIpcbiAgICAgKiAgICAgICAgICAgICAgIF5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdGF0ZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmQoY29kZSkge1xuICAgICAgLy8gV2Ugd2FudCB0byBhbGxvdyB0YWdzIGRpcmVjdGx5IGFmdGVyIGV4cHJlc3Npb25zLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgY2FzZSBpcyB1c2VmdWw6XG4gICAgICAvL1xuICAgICAgLy8gYGBgbWR4XG4gICAgICAvLyA8YT57Yn08L2E+XG4gICAgICAvLyBgYGBcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGNhc2UgaXMgbm90ICh2ZXJ5PykgdXNlZnVsOlxuICAgICAgLy9cbiAgICAgIC8vIGBgYG1keFxuICAgICAgLy8ge2F9PGIvPlxuICAgICAgLy8gYGBgXG4gICAgICAvL1xuICAgICAgLy8g4oCmYnV0IGl0IHdvdWxkIGJlIHRvdWdoZXIgdGhhbiBuZWVkZWQgdG8gZGlzYWxsb3cuXG4gICAgICAvL1xuICAgICAgLy8gVG8gYWxsb3cgdGhhdCwgaGVyZSB3ZSBjYWxsIHRoZSBmbG93IGNvbnN0cnVjdCBvZlxuICAgICAgLy8gYG1pY3JvbWFyay1leHRlbnNpb24tbWR4LWpzeGAsIGFuZCB0aGVyZSB3ZSBjYWxsIHRoaXMgb25lLlxuICAgICAgLy9cbiAgICAgIC8vIEl0IHdvdWxkIGludHJvZHVjZSBhIGN5Y2xpY2FsIGludGVyZGVwZW5kZW5jeSBpZiB3ZSB0ZXN0IEpTWCBhbmRcbiAgICAgIC8vIGV4cHJlc3Npb25zIGhlcmUuXG4gICAgICAvLyBCZWNhdXNlIHRoZSBKU1ggZXh0ZW5zaW9uIGFscmVhZHkgdXNlcyBwYXJ0cyBvZiB0aGlzIG1vbm9yZXBvLCB3ZVxuICAgICAgLy8gaW5zdGVhZCB0ZXN0IGl0IHRoZXJlLlxuICAgICAgY29uc3QgbGVzc1RoYW5WYWx1ZSA9IHNlbGYucGFyc2VyLmNvbnN0cnVjdHMuZmxvd1tjb2Rlcy5sZXNzVGhhbl1cbiAgICAgIGNvbnN0IGNvbnN0cnVjdHMgPSBBcnJheS5pc0FycmF5KGxlc3NUaGFuVmFsdWUpXG4gICAgICAgID8gbGVzc1RoYW5WYWx1ZVxuICAgICAgICA6IC8qIGM4IGlnbm9yZSBuZXh0IDMgLS0gYWx3YXlzIGEgbGlzdCB3aGVuIG5vcm1hbGl6ZWQuICovXG4gICAgICAgIGxlc3NUaGFuVmFsdWVcbiAgICAgICAgPyBbbGVzc1RoYW5WYWx1ZV1cbiAgICAgICAgOiBbXVxuICAgICAgY29uc3QganN4VGFnID0gY29uc3RydWN0cy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLm5hbWUgPT09ICdtZHhKc3hGbG93VGFnJ1xuICAgICAgfSlcblxuICAgICAgLyogYzggaWdub3JlIG5leHQgMyAtLSB0aGlzIGlzIHRlc3RlZCBpbiBgbWljcm9tYXJrLWV4dGVuc2lvbi1tZHgtanN4YCAqL1xuICAgICAgaWYgKGNvZGUgPT09IGNvZGVzLmxlc3NUaGFuICYmIGpzeFRhZykge1xuICAgICAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KGpzeFRhZywgZW5kLCBub2spKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlID09PSBjb2Rlcy5lb2YgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpXG4gICAgICAgID8gb2soY29kZSlcbiAgICAgICAgOiBub2soY29kZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTURYIGV4cHJlc3Npb24gKHRleHQpLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgYSB7TWF0aC5QSX0gYy5cbiAgICogICAgICAgXl5eXl5eXl5eXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICAgKiBAdHlwZSB7VG9rZW5pemVyfVxuICAgKi9cbiAgZnVuY3Rpb24gdG9rZW5pemVUZXh0RXhwcmVzc2lvbihlZmZlY3RzLCBvaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgICByZXR1cm4gc3RhcnRcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IG9mIGFuIE1EWCBleHByZXNzaW9uICh0ZXh0KS5cbiAgICAgKlxuICAgICAqIGBgYG1hcmtkb3duXG4gICAgICogPiB8IGEge01hdGguUEl9IGMuXG4gICAgICogICAgICAgXlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RhdGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgYXNzZXJ0KGNvZGUgPT09IGNvZGVzLmxlZnRDdXJseUJyYWNlLCAnZXhwZWN0ZWQgYHtgJylcbiAgICAgIHJldHVybiBmYWN0b3J5TWR4RXhwcmVzc2lvbi5jYWxsKFxuICAgICAgICBzZWxmLFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBvayxcbiAgICAgICAgJ21keFRleHRFeHByZXNzaW9uJyxcbiAgICAgICAgJ21keFRleHRFeHByZXNzaW9uTWFya2VyJyxcbiAgICAgICAgJ21keFRleHRFeHByZXNzaW9uQ2h1bmsnLFxuICAgICAgICBhY29ybixcbiAgICAgICAgYWNvcm5PcHRpb25zLFxuICAgICAgICBhZGRSZXN1bHQsXG4gICAgICAgIHNwcmVhZCxcbiAgICAgICAgYWxsb3dFbXB0eSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKShjb2RlKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/micromark-extension-mdx-expression@3.0.0/node_modules/micromark-extension-mdx-expression/dev/lib/syntax.js\n");

/***/ })

};
;