"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/estree-util-build-jsx@3.0.1";
exports.ids = ["vendor-chunks/estree-util-build-jsx@3.0.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/estree-util-build-jsx@3.0.1/node_modules/estree-util-build-jsx/lib/index.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/estree-util-build-jsx@3.0.1/node_modules/estree-util-build-jsx/lib/index.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildJsx: () => (/* binding */ buildJsx)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! estree-util-is-identifier-name */ \"(ssr)/./node_modules/.pnpm/estree-util-is-identifier-name@3.0.0/node_modules/estree-util-is-identifier-name/lib/index.js\");\n/* harmony import */ var estree_walker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! estree-walker */ \"(ssr)/./node_modules/.pnpm/estree-walker@3.0.3/node_modules/estree-walker/src/index.js\");\n/**\n * @typedef {import('estree-jsx').Expression} Expression\n * @typedef {import('estree-jsx').Identifier} Identifier\n * @typedef {import('estree-jsx').ImportSpecifier} ImportSpecifier\n * @typedef {import('estree-jsx').JSXAttribute} JSXAttribute\n * @typedef {import('estree-jsx').JSXIdentifier} JSXIdentifier\n * @typedef {import('estree-jsx').JSXMemberExpression} JSXMemberExpression\n * @typedef {import('estree-jsx').JSXNamespacedName} JSXNamespacedName\n * @typedef {import('estree-jsx').Literal} Literal\n * @typedef {import('estree-jsx').MemberExpression} MemberExpression\n * @typedef {import('estree-jsx').Node} Node\n * @typedef {import('estree-jsx').ObjectExpression} ObjectExpression\n * @typedef {import('estree-jsx').Property} Property\n * @typedef {import('estree-jsx').SpreadElement} SpreadElement\n *\n * @typedef {'automatic' | 'classic'} Runtime\n *   How to transform JSX.\n *\n * @typedef Options\n *   Configuration.\n *\n *   > ðŸ‘‰ **Note**: you can also configure `runtime`, `importSource`, `pragma`,\n *   > and `pragmaFrag` from within files through comments.\n * @property {Runtime | null | undefined} [runtime='classic']\n *   Choose the runtime (default: `'classic'`).\n *\n *   Comment form: `@jsxRuntime theRuntime`.\n * @property {string | null | undefined} [importSource='react']\n *   Place to import `jsx`, `jsxs`, `jsxDEV`, and `Fragment` from, when the\n *   effective runtime is automatic (default: `'react'`).\n *\n *   Comment form: `@jsxImportSource theSource`.\n *\n *   > ðŸ‘‰ **Note**: `/jsx-runtime` or `/jsx-dev-runtime` is appended to this\n *   > provided source.\n *   > In CJS, that can resolve to a file (as in `theSource/jsx-runtime.js`),\n *   > but for ESM an export map needs to be set up to point to files:\n *   >\n *   > ```js\n *   > // â€¦\n *   > \"exports\": {\n *   >   // â€¦\n *   >   \"./jsx-runtime\": \"./path/to/jsx-runtime.js\",\n *   >   \"./jsx-dev-runtime\": \"./path/to/jsx-runtime.js\"\n *   >   // â€¦\n *   > ```\n * @property {string | null | undefined} [pragma='React.createElement']\n *   Identifier or member expression to call when the effective runtime is\n *   classic (default: `'React.createElement'`).\n *\n *   Comment form: `@jsx identifier`.\n * @property {string | null | undefined} [pragmaFrag='React.Fragment']\n *   Identifier or member expression to use as a symbol for fragments when the\n *   effective runtime is classic (default: `'React.Fragment'`).\n *\n *   Comment form: `@jsxFrag identifier`.\n * @property {boolean | null | undefined} [development=false]\n *   When in the automatic runtime, whether to import\n *   `theSource/jsx-dev-runtime.js`, use `jsxDEV`, and pass location info when\n *   available (default: `false`).\n *\n *   This helps debugging but adds a lot of code that you donâ€™t want in\n *   production.\n * @property {string | null | undefined} [filePath]\n *   File path to the original source file (optional).\n *\n *   Passed in location info to `jsxDEV` when using the automatic runtime with\n *   `development: true`.\n *\n * @typedef Annotations\n *   State where info from comments is gathered.\n * @property {string | undefined} [jsx]\n *   JSX identifier (`pragma`).\n * @property {string | undefined} [jsxFrag]\n *   JSX identifier of fragment (`pragmaFrag`).\n * @property {string | undefined} [jsxImportSource]\n *   Where to import an automatic JSX runtime from.\n * @property {Runtime | undefined} [jsxRuntime]\n *   Runtime.\n *\n * @typedef Imports\n *   State of used identifiers from the automatic runtime.\n * @property {boolean | undefined} [fragment]\n *   Symbol of `Fragment`.\n * @property {boolean | undefined} [jsx]\n *   Symbol of `jsx`.\n * @property {boolean | undefined} [jsxs]\n *   Symbol of `jsxs`.\n * @property {boolean | undefined} [jsxDEV]\n *   Symbol of `jsxDEV`.\n */\n\n\n\n\n\nconst regex = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\\s+(\\S+)/g\n\n/**\n * Turn JSX in `tree` into function calls: `<x />` -> `h('x')`!\n *\n * ###### Algorithm\n *\n * In almost all cases, this utility is the same as the Babel plugin, except that\n * they work on slightly different syntax trees.\n *\n * Some differences:\n *\n * *   no pure annotations things\n * *   `this` is not a component: `<this>` -> `h('this')`, not `h(this)`\n * *   namespaces are supported: `<a:b c:d>` -> `h('a:b', {'c:d': true})`,\n *     which throws by default in Babel or can be turned on with `throwIfNamespace`\n * *   no `useSpread`, `useBuiltIns`, or `filter` options\n *\n * @param {Node} tree\n *   Tree to transform (typically `Program`).\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nfunction buildJsx(tree, options) {\n  const config = options || {}\n  let automatic = config.runtime === 'automatic'\n  /** @type {Annotations} */\n  const annotations = {}\n  /** @type {Imports} */\n  const imports = {}\n\n  ;(0,estree_walker__WEBPACK_IMPORTED_MODULE_0__.walk)(tree, {\n    enter(node) {\n      if (node.type === 'Program') {\n        const comments = node.comments || []\n        let index = -1\n\n        while (++index < comments.length) {\n          regex.lastIndex = 0\n\n          let match = regex.exec(comments[index].value)\n\n          while (match) {\n            // @ts-expect-error: `match[1]` is always a key, `match[2]` when\n            // runtime is checked later.\n            annotations[match[1]] = match[2]\n            match = regex.exec(comments[index].value)\n          }\n        }\n\n        if (annotations.jsxRuntime) {\n          if (annotations.jsxRuntime === 'automatic') {\n            automatic = true\n\n            if (annotations.jsx) {\n              throw new Error('Unexpected `@jsx` pragma w/ automatic runtime')\n            }\n\n            if (annotations.jsxFrag) {\n              throw new Error(\n                'Unexpected `@jsxFrag` pragma w/ automatic runtime'\n              )\n            }\n          } else if (annotations.jsxRuntime === 'classic') {\n            automatic = false\n\n            if (annotations.jsxImportSource) {\n              throw new Error(\n                'Unexpected `@jsxImportSource` w/ classic runtime'\n              )\n            }\n          } else {\n            throw new Error(\n              'Unexpected `jsxRuntime` `' +\n                annotations.jsxRuntime +\n                '`, expected `automatic` or `classic`'\n            )\n          }\n        }\n      }\n    },\n    // eslint-disable-next-line complexity\n    leave(node) {\n      if (node.type === 'Program') {\n        /** @type {Array<ImportSpecifier>} */\n        const specifiers = []\n\n        if (imports.fragment) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'Fragment'},\n            local: {type: 'Identifier', name: '_Fragment'}\n          })\n        }\n\n        if (imports.jsx) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'jsx'},\n            local: {type: 'Identifier', name: '_jsx'}\n          })\n        }\n\n        if (imports.jsxs) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'jsxs'},\n            local: {type: 'Identifier', name: '_jsxs'}\n          })\n        }\n\n        if (imports.jsxDEV) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'jsxDEV'},\n            local: {type: 'Identifier', name: '_jsxDEV'}\n          })\n        }\n\n        if (specifiers.length > 0) {\n          let injectIndex = 0\n\n          while (injectIndex < node.body.length) {\n            const child = node.body[injectIndex]\n\n            if ('directive' in child && child.directive) {\n              injectIndex++\n            } else {\n              break\n            }\n          }\n\n          node.body.splice(injectIndex, 0, {\n            type: 'ImportDeclaration',\n            specifiers,\n            source: {\n              type: 'Literal',\n              value:\n                (annotations.jsxImportSource ||\n                  config.importSource ||\n                  'react') +\n                (config.development ? '/jsx-dev-runtime' : '/jsx-runtime')\n            }\n          })\n        }\n      }\n\n      if (node.type !== 'JSXElement' && node.type !== 'JSXFragment') {\n        return\n      }\n\n      /** @type {Array<Expression>} */\n      const children = []\n      let index = -1\n\n      // Figure out `children`.\n      while (++index < node.children.length) {\n        const child = node.children[index]\n\n        if (child.type === 'JSXExpressionContainer') {\n          // Ignore empty expressions.\n          if (child.expression.type !== 'JSXEmptyExpression') {\n            children.push(child.expression)\n          }\n        } else if (child.type === 'JSXText') {\n          const value = child.value\n            // Replace tabs w/ spaces.\n            .replace(/\\t/g, ' ')\n            // Use line feeds, drop spaces around them.\n            .replace(/ *(\\r?\\n|\\r) */g, '\\n')\n            // Collapse multiple line feeds.\n            .replace(/\\n+/g, '\\n')\n            // Drop final line feeds.\n            .replace(/\\n+$/, '')\n            // Drop first line feeds.\n            .replace(/^\\n+/, '')\n            // Replace line feeds with spaces.\n            .replace(/\\n/g, ' ')\n\n          // Ignore collapsible text.\n          if (value) {\n            /** @type {Node} */\n            const text = {type: 'Literal', value}\n            create(child, text)\n            children.push(text)\n          }\n        } else {\n          (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n            child.type !== 'JSXElement' &&\n              child.type !== 'JSXFragment' &&\n              child.type !== 'JSXSpreadChild'\n          )\n          children.push(child)\n        }\n      }\n\n      /** @type {Identifier | Literal | MemberExpression} */\n      let name\n      /** @type {Array<Property | SpreadElement>} */\n      const fields = []\n      /** @type {Array<Expression>} */\n      let parameters = []\n      /** @type {Expression | undefined} */\n      let key\n\n      // Do the stuff needed for elements.\n      if (node.type === 'JSXElement') {\n        name = toIdentifier(node.openingElement.name)\n\n        // If the name could be an identifier, but start with a lowercase letter,\n        // itâ€™s not a component.\n        if (name.type === 'Identifier' && /^[a-z]/.test(name.name)) {\n          /** @type {Node} */\n          const next = {type: 'Literal', value: name.name}\n          create(name, next)\n          name = next\n        }\n\n        /** @type {boolean | undefined} */\n        let spread\n        const attributes = node.openingElement.attributes\n        let index = -1\n\n        // Place props in the right order, because we might have duplicates\n        // in them and whatâ€™s spread in.\n        while (++index < attributes.length) {\n          const attribute = attributes[index]\n\n          if (attribute.type === 'JSXSpreadAttribute') {\n            if (attribute.argument.type === 'ObjectExpression') {\n              fields.push(...attribute.argument.properties)\n            } else {\n              fields.push({type: 'SpreadElement', argument: attribute.argument})\n            }\n\n            spread = true\n          } else {\n            const prop = toProperty(attribute)\n\n            if (\n              automatic &&\n              prop.key.type === 'Identifier' &&\n              prop.key.name === 'key'\n            ) {\n              if (spread) {\n                throw new Error(\n                  'Expected `key` to come before any spread expressions'\n                )\n              }\n\n              const value = prop.value\n\n              ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n                value.type !== 'AssignmentPattern' &&\n                  value.type !== 'ArrayPattern' &&\n                  value.type !== 'ObjectPattern' &&\n                  value.type !== 'RestElement'\n              )\n\n              key = value\n            } else {\n              fields.push(prop)\n            }\n          }\n        }\n      }\n      // â€¦and fragments.\n      else if (automatic) {\n        imports.fragment = true\n        name = {type: 'Identifier', name: '_Fragment'}\n      } else {\n        name = toMemberExpression(\n          annotations.jsxFrag || config.pragmaFrag || 'React.Fragment'\n        )\n      }\n\n      if (automatic) {\n        if (children.length > 0) {\n          fields.push({\n            type: 'Property',\n            key: {type: 'Identifier', name: 'children'},\n            value:\n              children.length > 1\n                ? {type: 'ArrayExpression', elements: children}\n                : children[0],\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed: false\n          })\n        }\n      } else {\n        parameters = children\n      }\n\n      /** @type {Identifier | Literal | MemberExpression} */\n      let callee\n\n      if (automatic) {\n        parameters.push({type: 'ObjectExpression', properties: fields})\n\n        if (key) {\n          parameters.push(key)\n        } else if (config.development) {\n          parameters.push({type: 'Identifier', name: 'undefined'})\n        }\n\n        const isStaticChildren = children.length > 1\n\n        if (config.development) {\n          imports.jsxDEV = true\n          callee = {\n            type: 'Identifier',\n            name: '_jsxDEV'\n          }\n          parameters.push({type: 'Literal', value: isStaticChildren})\n\n          /** @type {ObjectExpression} */\n          const source = {\n            type: 'ObjectExpression',\n            properties: [\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                kind: 'init',\n                key: {type: 'Identifier', name: 'fileName'},\n                value: {\n                  type: 'Literal',\n                  value: config.filePath || '<source.js>'\n                }\n              }\n            ]\n          }\n\n          if (node.loc) {\n            source.properties.push(\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                kind: 'init',\n                key: {type: 'Identifier', name: 'lineNumber'},\n                value: {type: 'Literal', value: node.loc.start.line}\n              },\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                kind: 'init',\n                key: {type: 'Identifier', name: 'columnNumber'},\n                value: {type: 'Literal', value: node.loc.start.column + 1}\n              }\n            )\n          }\n\n          parameters.push(source, {type: 'ThisExpression'})\n        } else if (isStaticChildren) {\n          imports.jsxs = true\n          callee = {type: 'Identifier', name: '_jsxs'}\n        } else {\n          imports.jsx = true\n          callee = {type: 'Identifier', name: '_jsx'}\n        }\n      }\n      // Classic.\n      else {\n        if (fields.length > 0) {\n          parameters.unshift({type: 'ObjectExpression', properties: fields})\n        } else if (parameters.length > 0) {\n          parameters.unshift({type: 'Literal', value: null})\n        }\n\n        callee = toMemberExpression(\n          annotations.jsx || config.pragma || 'React.createElement'\n        )\n      }\n\n      parameters.unshift(name)\n      /** @type {Node} */\n      const call = {\n        type: 'CallExpression',\n        callee,\n        arguments: parameters,\n        optional: false\n      }\n      create(node, call)\n      this.replace(call)\n    }\n  })\n}\n\n/**\n * Turn a JSX attribute into a JavaScript property.\n *\n * @param {JSXAttribute} node\n *   JSX attribute.\n * @returns {Property}\n *   JS property.\n */\nfunction toProperty(node) {\n  /** @type {Expression} */\n  let value\n\n  if (node.value) {\n    if (node.value.type === 'JSXExpressionContainer') {\n      const valueExpression = node.value.expression\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n        valueExpression.type !== 'JSXEmptyExpression',\n        '`JSXEmptyExpression` is not allowed in props.'\n      )\n      value = valueExpression\n    }\n    // Literal or call expression.\n    else {\n      const nodeValue = node.value\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n        nodeValue.type !== 'JSXElement' && nodeValue.type !== 'JSXFragment',\n        'JSX{Element,Fragment} are already compiled to `CallExpression`'\n      )\n      value = nodeValue\n      delete value.raw\n    }\n  }\n  // Boolean prop.\n  else {\n    value = {type: 'Literal', value: true}\n  }\n\n  /** @type {Property} */\n  const replacement = {\n    type: 'Property',\n    key: toIdentifier(node.name),\n    value,\n    kind: 'init',\n    method: false,\n    shorthand: false,\n    computed: false\n  }\n  create(node, replacement)\n  return replacement\n}\n\n/**\n * Turn a JSX identifier into a normal JS identifier.\n *\n * @param {JSXIdentifier | JSXMemberExpression | JSXNamespacedName} node\n *   JSX identifier.\n * @returns {Identifier | Literal | MemberExpression}\n *   JS identifier.\n */\nfunction toIdentifier(node) {\n  /** @type {Identifier | Literal | MemberExpression} */\n  let replace\n\n  if (node.type === 'JSXMemberExpression') {\n    // `property` is always a `JSXIdentifier`, but it could be something that\n    // isnâ€™t an ES identifier name.\n    const id = toIdentifier(node.property)\n    replace = {\n      type: 'MemberExpression',\n      object: toIdentifier(node.object),\n      property: id,\n      computed: id.type === 'Literal',\n      optional: false\n    }\n  } else if (node.type === 'JSXNamespacedName') {\n    replace = {\n      type: 'Literal',\n      value: node.namespace.name + ':' + node.name.name\n    }\n  }\n  // Must be `JSXIdentifier`.\n  else {\n    replace = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__.name)(node.name)\n      ? {type: 'Identifier', name: node.name}\n      : {type: 'Literal', value: node.name}\n  }\n\n  create(node, replace)\n  return replace\n}\n\n/**\n * Turn a dotted string into a member expression.\n *\n * @param {string} id\n *   Identifiers.\n * @returns {Identifier | Literal | MemberExpression}\n *   Expression.\n */\nfunction toMemberExpression(id) {\n  const identifiers = id.split('.')\n  let index = -1\n  /** @type {Identifier | Literal | MemberExpression | undefined} */\n  let result\n\n  while (++index < identifiers.length) {\n    /** @type {Identifier | Literal} */\n    const prop = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__.name)(identifiers[index])\n      ? {type: 'Identifier', name: identifiers[index]}\n      : {type: 'Literal', value: identifiers[index]}\n    result = result\n      ? {\n          type: 'MemberExpression',\n          object: result,\n          property: prop,\n          computed: Boolean(index && prop.type === 'Literal'),\n          optional: false\n        }\n      : prop\n  }\n\n  (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(result, 'always a result')\n  return result\n}\n\n/**\n * Inherit some fields from `from` into `to`.\n *\n * @param {Node} from\n *   Node to inherit from.\n * @param {Node} to\n *   Node to add to.\n * @returns {undefined}\n *   Nothing.\n */\nfunction create(from, to) {\n  const fields = ['start', 'end', 'loc', 'range', 'comments']\n  let index = -1\n\n  while (++index < fields.length) {\n    const field = fields[index]\n    if (field in from) {\n      // @ts-expect-error: indexable.\n      to[field] = from[field]\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXN0cmVlLXV0aWwtYnVpbGQtanN4QDMuMC4xL25vZGVfbW9kdWxlcy9lc3RyZWUtdXRpbC1idWlsZC1qc3gvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBLGFBQWEsaUNBQWlDO0FBQzlDLGFBQWEsaUNBQWlDO0FBQzlDLGFBQWEsc0NBQXNDO0FBQ25ELGFBQWEsbUNBQW1DO0FBQ2hELGFBQWEsb0NBQW9DO0FBQ2pELGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsd0NBQXdDO0FBQ3JELGFBQWEsOEJBQThCO0FBQzNDLGFBQWEsdUNBQXVDO0FBQ3BELGFBQWEsMkJBQTJCO0FBQ3hDLGFBQWEsdUNBQXVDO0FBQ3BELGFBQWEsK0JBQStCO0FBQzVDLGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7O0FBRW1DO0FBQ29DO0FBQ3JDOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsWUFBWTtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCOztBQUVBLEVBQUUsb0RBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUNBQXFDO0FBQzVELG9CQUFvQjtBQUNwQixXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RCxvQkFBb0I7QUFDcEIsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUM7QUFDeEQsb0JBQW9CO0FBQ3BCLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUNBQW1DO0FBQzFELG9CQUFvQjtBQUNwQixXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsTUFBTTtBQUM3QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFVBQVUsMENBQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHlDQUF5QztBQUMxRDtBQUNBLGlCQUFpQixpQ0FBaUM7QUFDbEQ7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0Isd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMkJBQTJCLG9EQUFvRDtBQUMvRTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLDJDQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFDO0FBQ3ZEO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLGlCQUFpQix5Q0FBeUM7QUFDMUQ7O0FBRUE7QUFDQSx5QkFBeUIsNkNBQTZDOztBQUV0RTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJCQUEyQixzQ0FBc0M7QUFDakU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlDQUF5Qzs7QUFFcEUscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUNBQXVDO0FBQzdELHdCQUF3QjtBQUN4QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlDQUF5QztBQUMvRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyx1QkFBdUI7QUFDMUQsVUFBVTtBQUNWO0FBQ0Esb0JBQW9CO0FBQ3BCLFVBQVU7QUFDVjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZDQUE2QztBQUMzRSxVQUFVO0FBQ1YsOEJBQThCLDZCQUE2QjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkNBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyQ0FBTTtBQUNaO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlEQUF5RDtBQUNwRTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlDQUF5QztBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvRUFBZ0I7QUFDOUIsU0FBUztBQUNULFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFEQUFxRDtBQUNsRTs7QUFFQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDLGlCQUFpQixvRUFBZ0I7QUFDakMsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDBDQUFNO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2JtXzIwMjQvLi9ub2RlX21vZHVsZXMvLnBucG0vZXN0cmVlLXV0aWwtYnVpbGQtanN4QDMuMC4xL25vZGVfbW9kdWxlcy9lc3RyZWUtdXRpbC1idWlsZC1qc3gvbGliL2luZGV4LmpzP2E3ODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuRXhwcmVzc2lvbn0gRXhwcmVzc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLklkZW50aWZpZXJ9IElkZW50aWZpZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5JbXBvcnRTcGVjaWZpZXJ9IEltcG9ydFNwZWNpZmllclxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkpTWEF0dHJpYnV0ZX0gSlNYQXR0cmlidXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuSlNYSWRlbnRpZmllcn0gSlNYSWRlbnRpZmllclxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkpTWE1lbWJlckV4cHJlc3Npb259IEpTWE1lbWJlckV4cHJlc3Npb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5KU1hOYW1lc3BhY2VkTmFtZX0gSlNYTmFtZXNwYWNlZE5hbWVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5MaXRlcmFsfSBMaXRlcmFsXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuTWVtYmVyRXhwcmVzc2lvbn0gTWVtYmVyRXhwcmVzc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLk5vZGV9IE5vZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5PYmplY3RFeHByZXNzaW9ufSBPYmplY3RFeHByZXNzaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuUHJvcGVydHl9IFByb3BlcnR5XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuU3ByZWFkRWxlbWVudH0gU3ByZWFkRWxlbWVudFxuICpcbiAqIEB0eXBlZGVmIHsnYXV0b21hdGljJyB8ICdjbGFzc2ljJ30gUnVudGltZVxuICogICBIb3cgdG8gdHJhbnNmb3JtIEpTWC5cbiAqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IHlvdSBjYW4gYWxzbyBjb25maWd1cmUgYHJ1bnRpbWVgLCBgaW1wb3J0U291cmNlYCwgYHByYWdtYWAsXG4gKiAgID4gYW5kIGBwcmFnbWFGcmFnYCBmcm9tIHdpdGhpbiBmaWxlcyB0aHJvdWdoIGNvbW1lbnRzLlxuICogQHByb3BlcnR5IHtSdW50aW1lIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3J1bnRpbWU9J2NsYXNzaWMnXVxuICogICBDaG9vc2UgdGhlIHJ1bnRpbWUgKGRlZmF1bHQ6IGAnY2xhc3NpYydgKS5cbiAqXG4gKiAgIENvbW1lbnQgZm9ybTogYEBqc3hSdW50aW1lIHRoZVJ1bnRpbWVgLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbaW1wb3J0U291cmNlPSdyZWFjdCddXG4gKiAgIFBsYWNlIHRvIGltcG9ydCBganN4YCwgYGpzeHNgLCBganN4REVWYCwgYW5kIGBGcmFnbWVudGAgZnJvbSwgd2hlbiB0aGVcbiAqICAgZWZmZWN0aXZlIHJ1bnRpbWUgaXMgYXV0b21hdGljIChkZWZhdWx0OiBgJ3JlYWN0J2ApLlxuICpcbiAqICAgQ29tbWVudCBmb3JtOiBgQGpzeEltcG9ydFNvdXJjZSB0aGVTb3VyY2VgLlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiBgL2pzeC1ydW50aW1lYCBvciBgL2pzeC1kZXYtcnVudGltZWAgaXMgYXBwZW5kZWQgdG8gdGhpc1xuICogICA+IHByb3ZpZGVkIHNvdXJjZS5cbiAqICAgPiBJbiBDSlMsIHRoYXQgY2FuIHJlc29sdmUgdG8gYSBmaWxlIChhcyBpbiBgdGhlU291cmNlL2pzeC1ydW50aW1lLmpzYCksXG4gKiAgID4gYnV0IGZvciBFU00gYW4gZXhwb3J0IG1hcCBuZWVkcyB0byBiZSBzZXQgdXAgdG8gcG9pbnQgdG8gZmlsZXM6XG4gKiAgID5cbiAqICAgPiBgYGBqc1xuICogICA+IC8vIOKAplxuICogICA+IFwiZXhwb3J0c1wiOiB7XG4gKiAgID4gICAvLyDigKZcbiAqICAgPiAgIFwiLi9qc3gtcnVudGltZVwiOiBcIi4vcGF0aC90by9qc3gtcnVudGltZS5qc1wiLFxuICogICA+ICAgXCIuL2pzeC1kZXYtcnVudGltZVwiOiBcIi4vcGF0aC90by9qc3gtcnVudGltZS5qc1wiXG4gKiAgID4gICAvLyDigKZcbiAqICAgPiBgYGBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3ByYWdtYT0nUmVhY3QuY3JlYXRlRWxlbWVudCddXG4gKiAgIElkZW50aWZpZXIgb3IgbWVtYmVyIGV4cHJlc3Npb24gdG8gY2FsbCB3aGVuIHRoZSBlZmZlY3RpdmUgcnVudGltZSBpc1xuICogICBjbGFzc2ljIChkZWZhdWx0OiBgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQnYCkuXG4gKlxuICogICBDb21tZW50IGZvcm06IGBAanN4IGlkZW50aWZpZXJgLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJhZ21hRnJhZz0nUmVhY3QuRnJhZ21lbnQnXVxuICogICBJZGVudGlmaWVyIG9yIG1lbWJlciBleHByZXNzaW9uIHRvIHVzZSBhcyBhIHN5bWJvbCBmb3IgZnJhZ21lbnRzIHdoZW4gdGhlXG4gKiAgIGVmZmVjdGl2ZSBydW50aW1lIGlzIGNsYXNzaWMgKGRlZmF1bHQ6IGAnUmVhY3QuRnJhZ21lbnQnYCkuXG4gKlxuICogICBDb21tZW50IGZvcm06IGBAanN4RnJhZyBpZGVudGlmaWVyYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtkZXZlbG9wbWVudD1mYWxzZV1cbiAqICAgV2hlbiBpbiB0aGUgYXV0b21hdGljIHJ1bnRpbWUsIHdoZXRoZXIgdG8gaW1wb3J0XG4gKiAgIGB0aGVTb3VyY2UvanN4LWRldi1ydW50aW1lLmpzYCwgdXNlIGBqc3hERVZgLCBhbmQgcGFzcyBsb2NhdGlvbiBpbmZvIHdoZW5cbiAqICAgYXZhaWxhYmxlIChkZWZhdWx0OiBgZmFsc2VgKS5cbiAqXG4gKiAgIFRoaXMgaGVscHMgZGVidWdnaW5nIGJ1dCBhZGRzIGEgbG90IG9mIGNvZGUgdGhhdCB5b3UgZG9u4oCZdCB3YW50IGluXG4gKiAgIHByb2R1Y3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtmaWxlUGF0aF1cbiAqICAgRmlsZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAob3B0aW9uYWwpLlxuICpcbiAqICAgUGFzc2VkIGluIGxvY2F0aW9uIGluZm8gdG8gYGpzeERFVmAgd2hlbiB1c2luZyB0aGUgYXV0b21hdGljIHJ1bnRpbWUgd2l0aFxuICogICBgZGV2ZWxvcG1lbnQ6IHRydWVgLlxuICpcbiAqIEB0eXBlZGVmIEFubm90YXRpb25zXG4gKiAgIFN0YXRlIHdoZXJlIGluZm8gZnJvbSBjb21tZW50cyBpcyBnYXRoZXJlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbanN4XVxuICogICBKU1ggaWRlbnRpZmllciAoYHByYWdtYWApLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IFtqc3hGcmFnXVxuICogICBKU1ggaWRlbnRpZmllciBvZiBmcmFnbWVudCAoYHByYWdtYUZyYWdgKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbanN4SW1wb3J0U291cmNlXVxuICogICBXaGVyZSB0byBpbXBvcnQgYW4gYXV0b21hdGljIEpTWCBydW50aW1lIGZyb20uXG4gKiBAcHJvcGVydHkge1J1bnRpbWUgfCB1bmRlZmluZWR9IFtqc3hSdW50aW1lXVxuICogICBSdW50aW1lLlxuICpcbiAqIEB0eXBlZGVmIEltcG9ydHNcbiAqICAgU3RhdGUgb2YgdXNlZCBpZGVudGlmaWVycyBmcm9tIHRoZSBhdXRvbWF0aWMgcnVudGltZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gW2ZyYWdtZW50XVxuICogICBTeW1ib2wgb2YgYEZyYWdtZW50YC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gW2pzeF1cbiAqICAgU3ltYm9sIG9mIGBqc3hgLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgdW5kZWZpbmVkfSBbanN4c11cbiAqICAgU3ltYm9sIG9mIGBqc3hzYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gW2pzeERFVl1cbiAqICAgU3ltYm9sIG9mIGBqc3hERVZgLlxuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge25hbWUgYXMgaXNJZGVudGlmaWVyTmFtZX0gZnJvbSAnZXN0cmVlLXV0aWwtaXMtaWRlbnRpZmllci1uYW1lJ1xuaW1wb3J0IHt3YWxrfSBmcm9tICdlc3RyZWUtd2Fsa2VyJ1xuXG5jb25zdCByZWdleCA9IC9AKGpzeHxqc3hGcmFnfGpzeEltcG9ydFNvdXJjZXxqc3hSdW50aW1lKVxccysoXFxTKykvZ1xuXG4vKipcbiAqIFR1cm4gSlNYIGluIGB0cmVlYCBpbnRvIGZ1bmN0aW9uIGNhbGxzOiBgPHggLz5gIC0+IGBoKCd4JylgIVxuICpcbiAqICMjIyMjIyBBbGdvcml0aG1cbiAqXG4gKiBJbiBhbG1vc3QgYWxsIGNhc2VzLCB0aGlzIHV0aWxpdHkgaXMgdGhlIHNhbWUgYXMgdGhlIEJhYmVsIHBsdWdpbiwgZXhjZXB0IHRoYXRcbiAqIHRoZXkgd29yayBvbiBzbGlnaHRseSBkaWZmZXJlbnQgc3ludGF4IHRyZWVzLlxuICpcbiAqIFNvbWUgZGlmZmVyZW5jZXM6XG4gKlxuICogKiAgIG5vIHB1cmUgYW5ub3RhdGlvbnMgdGhpbmdzXG4gKiAqICAgYHRoaXNgIGlzIG5vdCBhIGNvbXBvbmVudDogYDx0aGlzPmAgLT4gYGgoJ3RoaXMnKWAsIG5vdCBgaCh0aGlzKWBcbiAqICogICBuYW1lc3BhY2VzIGFyZSBzdXBwb3J0ZWQ6IGA8YTpiIGM6ZD5gIC0+IGBoKCdhOmInLCB7J2M6ZCc6IHRydWV9KWAsXG4gKiAgICAgd2hpY2ggdGhyb3dzIGJ5IGRlZmF1bHQgaW4gQmFiZWwgb3IgY2FuIGJlIHR1cm5lZCBvbiB3aXRoIGB0aHJvd0lmTmFtZXNwYWNlYFxuICogKiAgIG5vIGB1c2VTcHJlYWRgLCBgdXNlQnVpbHRJbnNgLCBvciBgZmlsdGVyYCBvcHRpb25zXG4gKlxuICogQHBhcmFtIHtOb2RlfSB0cmVlXG4gKiAgIFRyZWUgdG8gdHJhbnNmb3JtICh0eXBpY2FsbHkgYFByb2dyYW1gKS5cbiAqIEBwYXJhbSB7T3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRKc3godHJlZSwgb3B0aW9ucykge1xuICBjb25zdCBjb25maWcgPSBvcHRpb25zIHx8IHt9XG4gIGxldCBhdXRvbWF0aWMgPSBjb25maWcucnVudGltZSA9PT0gJ2F1dG9tYXRpYydcbiAgLyoqIEB0eXBlIHtBbm5vdGF0aW9uc30gKi9cbiAgY29uc3QgYW5ub3RhdGlvbnMgPSB7fVxuICAvKiogQHR5cGUge0ltcG9ydHN9ICovXG4gIGNvbnN0IGltcG9ydHMgPSB7fVxuXG4gIHdhbGsodHJlZSwge1xuICAgIGVudGVyKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdQcm9ncmFtJykge1xuICAgICAgICBjb25zdCBjb21tZW50cyA9IG5vZGUuY29tbWVudHMgfHwgW11cbiAgICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCA9IDBcblxuICAgICAgICAgIGxldCBtYXRjaCA9IHJlZ2V4LmV4ZWMoY29tbWVudHNbaW5kZXhdLnZhbHVlKVxuXG4gICAgICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgbWF0Y2hbMV1gIGlzIGFsd2F5cyBhIGtleSwgYG1hdGNoWzJdYCB3aGVuXG4gICAgICAgICAgICAvLyBydW50aW1lIGlzIGNoZWNrZWQgbGF0ZXIuXG4gICAgICAgICAgICBhbm5vdGF0aW9uc1ttYXRjaFsxXV0gPSBtYXRjaFsyXVxuICAgICAgICAgICAgbWF0Y2ggPSByZWdleC5leGVjKGNvbW1lbnRzW2luZGV4XS52YWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5ub3RhdGlvbnMuanN4UnVudGltZSkge1xuICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5qc3hSdW50aW1lID09PSAnYXV0b21hdGljJykge1xuICAgICAgICAgICAgYXV0b21hdGljID0gdHJ1ZVxuXG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuanN4KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBgQGpzeGAgcHJhZ21hIHcvIGF1dG9tYXRpYyBydW50aW1lJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zLmpzeEZyYWcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIGBAanN4RnJhZ2AgcHJhZ21hIHcvIGF1dG9tYXRpYyBydW50aW1lJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhbm5vdGF0aW9ucy5qc3hSdW50aW1lID09PSAnY2xhc3NpYycpIHtcbiAgICAgICAgICAgIGF1dG9tYXRpYyA9IGZhbHNlXG5cbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5qc3hJbXBvcnRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIGBAanN4SW1wb3J0U291cmNlYCB3LyBjbGFzc2ljIHJ1bnRpbWUnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnVW5leHBlY3RlZCBganN4UnVudGltZWAgYCcgK1xuICAgICAgICAgICAgICAgIGFubm90YXRpb25zLmpzeFJ1bnRpbWUgK1xuICAgICAgICAgICAgICAgICdgLCBleHBlY3RlZCBgYXV0b21hdGljYCBvciBgY2xhc3NpY2AnXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIGxlYXZlKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdQcm9ncmFtJykge1xuICAgICAgICAvKiogQHR5cGUge0FycmF5PEltcG9ydFNwZWNpZmllcj59ICovXG4gICAgICAgIGNvbnN0IHNwZWNpZmllcnMgPSBbXVxuXG4gICAgICAgIGlmIChpbXBvcnRzLmZyYWdtZW50KSB7XG4gICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICAgICAgaW1wb3J0ZWQ6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdGcmFnbWVudCd9LFxuICAgICAgICAgICAgbG9jYWw6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdfRnJhZ21lbnQnfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW1wb3J0cy5qc3gpIHtcbiAgICAgICAgICBzcGVjaWZpZXJzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ0ltcG9ydFNwZWNpZmllcicsXG4gICAgICAgICAgICBpbXBvcnRlZDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2pzeCd9LFxuICAgICAgICAgICAgbG9jYWw6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdfanN4J31cbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGltcG9ydHMuanN4cykge1xuICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnSW1wb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgICAgIGltcG9ydGVkOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnanN4cyd9LFxuICAgICAgICAgICAgbG9jYWw6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdfanN4cyd9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbXBvcnRzLmpzeERFVikge1xuICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnSW1wb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgICAgIGltcG9ydGVkOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnanN4REVWJ30sXG4gICAgICAgICAgICBsb2NhbDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19qc3hERVYnfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3BlY2lmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IGluamVjdEluZGV4ID0gMFxuXG4gICAgICAgICAgd2hpbGUgKGluamVjdEluZGV4IDwgbm9kZS5ib2R5Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmJvZHlbaW5qZWN0SW5kZXhdXG5cbiAgICAgICAgICAgIGlmICgnZGlyZWN0aXZlJyBpbiBjaGlsZCAmJiBjaGlsZC5kaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgaW5qZWN0SW5kZXgrK1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2RlLmJvZHkuc3BsaWNlKGluamVjdEluZGV4LCAwLCB7XG4gICAgICAgICAgICB0eXBlOiAnSW1wb3J0RGVjbGFyYXRpb24nLFxuICAgICAgICAgICAgc3BlY2lmaWVycyxcbiAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICB0eXBlOiAnTGl0ZXJhbCcsXG4gICAgICAgICAgICAgIHZhbHVlOlxuICAgICAgICAgICAgICAgIChhbm5vdGF0aW9ucy5qc3hJbXBvcnRTb3VyY2UgfHxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5pbXBvcnRTb3VyY2UgfHxcbiAgICAgICAgICAgICAgICAgICdyZWFjdCcpICtcbiAgICAgICAgICAgICAgICAoY29uZmlnLmRldmVsb3BtZW50ID8gJy9qc3gtZGV2LXJ1bnRpbWUnIDogJy9qc3gtcnVudGltZScpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50eXBlICE9PSAnSlNYRWxlbWVudCcgJiYgbm9kZS50eXBlICE9PSAnSlNYRnJhZ21lbnQnKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge0FycmF5PEV4cHJlc3Npb24+fSAqL1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXVxuICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgLy8gRmlndXJlIG91dCBgY2hpbGRyZW5gLlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baW5kZXhdXG5cbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdKU1hFeHByZXNzaW9uQ29udGFpbmVyJykge1xuICAgICAgICAgIC8vIElnbm9yZSBlbXB0eSBleHByZXNzaW9ucy5cbiAgICAgICAgICBpZiAoY2hpbGQuZXhwcmVzc2lvbi50eXBlICE9PSAnSlNYRW1wdHlFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZC5leHByZXNzaW9uKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZC50eXBlID09PSAnSlNYVGV4dCcpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNoaWxkLnZhbHVlXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRhYnMgdy8gc3BhY2VzLlxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnICcpXG4gICAgICAgICAgICAvLyBVc2UgbGluZSBmZWVkcywgZHJvcCBzcGFjZXMgYXJvdW5kIHRoZW0uXG4gICAgICAgICAgICAucmVwbGFjZSgvICooXFxyP1xcbnxcXHIpICovZywgJ1xcbicpXG4gICAgICAgICAgICAvLyBDb2xsYXBzZSBtdWx0aXBsZSBsaW5lIGZlZWRzLlxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbisvZywgJ1xcbicpXG4gICAgICAgICAgICAvLyBEcm9wIGZpbmFsIGxpbmUgZmVlZHMuXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuKyQvLCAnJylcbiAgICAgICAgICAgIC8vIERyb3AgZmlyc3QgbGluZSBmZWVkcy5cbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxuKy8sICcnKVxuICAgICAgICAgICAgLy8gUmVwbGFjZSBsaW5lIGZlZWRzIHdpdGggc3BhY2VzLlxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnICcpXG5cbiAgICAgICAgICAvLyBJZ25vcmUgY29sbGFwc2libGUgdGV4dC5cbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZX1cbiAgICAgICAgICAgIGNyZWF0ZShjaGlsZCwgdGV4dClcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGV4dClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgICAgY2hpbGQudHlwZSAhPT0gJ0pTWEVsZW1lbnQnICYmXG4gICAgICAgICAgICAgIGNoaWxkLnR5cGUgIT09ICdKU1hGcmFnbWVudCcgJiZcbiAgICAgICAgICAgICAgY2hpbGQudHlwZSAhPT0gJ0pTWFNwcmVhZENoaWxkJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9ufSAqL1xuICAgICAgbGV0IG5hbWVcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8UHJvcGVydHkgfCBTcHJlYWRFbGVtZW50Pn0gKi9cbiAgICAgIGNvbnN0IGZpZWxkcyA9IFtdXG4gICAgICAvKiogQHR5cGUge0FycmF5PEV4cHJlc3Npb24+fSAqL1xuICAgICAgbGV0IHBhcmFtZXRlcnMgPSBbXVxuICAgICAgLyoqIEB0eXBlIHtFeHByZXNzaW9uIHwgdW5kZWZpbmVkfSAqL1xuICAgICAgbGV0IGtleVxuXG4gICAgICAvLyBEbyB0aGUgc3R1ZmYgbmVlZGVkIGZvciBlbGVtZW50cy5cbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdKU1hFbGVtZW50Jykge1xuICAgICAgICBuYW1lID0gdG9JZGVudGlmaWVyKG5vZGUub3BlbmluZ0VsZW1lbnQubmFtZSlcblxuICAgICAgICAvLyBJZiB0aGUgbmFtZSBjb3VsZCBiZSBhbiBpZGVudGlmaWVyLCBidXQgc3RhcnQgd2l0aCBhIGxvd2VyY2FzZSBsZXR0ZXIsXG4gICAgICAgIC8vIGl04oCZcyBub3QgYSBjb21wb25lbnQuXG4gICAgICAgIGlmIChuYW1lLnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJiAvXlthLXpdLy50ZXN0KG5hbWUubmFtZSkpIHtcbiAgICAgICAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgICAgICAgY29uc3QgbmV4dCA9IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBuYW1lLm5hbWV9XG4gICAgICAgICAgY3JlYXRlKG5hbWUsIG5leHQpXG4gICAgICAgICAgbmFtZSA9IG5leHRcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgICAgICAgbGV0IHNwcmVhZFxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5vcGVuaW5nRWxlbWVudC5hdHRyaWJ1dGVzXG4gICAgICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICAgICAgLy8gUGxhY2UgcHJvcHMgaW4gdGhlIHJpZ2h0IG9yZGVyLCBiZWNhdXNlIHdlIG1pZ2h0IGhhdmUgZHVwbGljYXRlc1xuICAgICAgICAvLyBpbiB0aGVtIGFuZCB3aGF04oCZcyBzcHJlYWQgaW4uXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2luZGV4XVxuXG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlID09PSAnSlNYU3ByZWFkQXR0cmlidXRlJykge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5hcmd1bWVudC50eXBlID09PSAnT2JqZWN0RXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgZmllbGRzLnB1c2goLi4uYXR0cmlidXRlLmFyZ3VtZW50LnByb3BlcnRpZXMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaWVsZHMucHVzaCh7dHlwZTogJ1NwcmVhZEVsZW1lbnQnLCBhcmd1bWVudDogYXR0cmlidXRlLmFyZ3VtZW50fSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3ByZWFkID0gdHJ1ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wID0gdG9Qcm9wZXJ0eShhdHRyaWJ1dGUpXG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgYXV0b21hdGljICYmXG4gICAgICAgICAgICAgIHByb3Aua2V5LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJlxuICAgICAgICAgICAgICBwcm9wLmtleS5uYW1lID09PSAna2V5J1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmIChzcHJlYWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgYGtleWAgdG8gY29tZSBiZWZvcmUgYW55IHNwcmVhZCBleHByZXNzaW9ucydcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3AudmFsdWVcblxuICAgICAgICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSAhPT0gJ0Fzc2lnbm1lbnRQYXR0ZXJuJyAmJlxuICAgICAgICAgICAgICAgICAgdmFsdWUudHlwZSAhPT0gJ0FycmF5UGF0dGVybicgJiZcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgIT09ICdPYmplY3RQYXR0ZXJuJyAmJlxuICAgICAgICAgICAgICAgICAgdmFsdWUudHlwZSAhPT0gJ1Jlc3RFbGVtZW50J1xuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAga2V5ID0gdmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpZWxkcy5wdXNoKHByb3ApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyDigKZhbmQgZnJhZ21lbnRzLlxuICAgICAgZWxzZSBpZiAoYXV0b21hdGljKSB7XG4gICAgICAgIGltcG9ydHMuZnJhZ21lbnQgPSB0cnVlXG4gICAgICAgIG5hbWUgPSB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnX0ZyYWdtZW50J31cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSB0b01lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgYW5ub3RhdGlvbnMuanN4RnJhZyB8fCBjb25maWcucHJhZ21hRnJhZyB8fCAnUmVhY3QuRnJhZ21lbnQnXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKGF1dG9tYXRpYykge1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdQcm9wZXJ0eScsXG4gICAgICAgICAgICBrZXk6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdjaGlsZHJlbid9LFxuICAgICAgICAgICAgdmFsdWU6XG4gICAgICAgICAgICAgIGNoaWxkcmVuLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICA/IHt0eXBlOiAnQXJyYXlFeHByZXNzaW9uJywgZWxlbWVudHM6IGNoaWxkcmVufVxuICAgICAgICAgICAgICAgIDogY2hpbGRyZW5bMF0sXG4gICAgICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBjaGlsZHJlblxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge0lkZW50aWZpZXIgfCBMaXRlcmFsIHwgTWVtYmVyRXhwcmVzc2lvbn0gKi9cbiAgICAgIGxldCBjYWxsZWVcblxuICAgICAgaWYgKGF1dG9tYXRpYykge1xuICAgICAgICBwYXJhbWV0ZXJzLnB1c2goe3R5cGU6ICdPYmplY3RFeHByZXNzaW9uJywgcHJvcGVydGllczogZmllbGRzfSlcblxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKGtleSlcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2goe3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ3VuZGVmaW5lZCd9KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNTdGF0aWNDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aCA+IDFcblxuICAgICAgICBpZiAoY29uZmlnLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgaW1wb3J0cy5qc3hERVYgPSB0cnVlXG4gICAgICAgICAgY2FsbGVlID0ge1xuICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgbmFtZTogJ19qc3hERVYnXG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmFtZXRlcnMucHVzaCh7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogaXNTdGF0aWNDaGlsZHJlbn0pXG5cbiAgICAgICAgICAvKiogQHR5cGUge09iamVjdEV4cHJlc3Npb259ICovXG4gICAgICAgICAgY29uc3Qgc291cmNlID0ge1xuICAgICAgICAgICAgdHlwZTogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1Byb3BlcnR5JyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3J0aGFuZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgICAgICAgICBrZXk6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdmaWxlTmFtZSd9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnTGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogY29uZmlnLmZpbGVQYXRoIHx8ICc8c291cmNlLmpzPidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobm9kZS5sb2MpIHtcbiAgICAgICAgICAgIHNvdXJjZS5wcm9wZXJ0aWVzLnB1c2goXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUHJvcGVydHknLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAga2luZDogJ2luaXQnLFxuICAgICAgICAgICAgICAgIGtleToge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2xpbmVOdW1iZXInfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IG5vZGUubG9jLnN0YXJ0LmxpbmV9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUHJvcGVydHknLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAga2luZDogJ2luaXQnLFxuICAgICAgICAgICAgICAgIGtleToge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2NvbHVtbk51bWJlcid9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogbm9kZS5sb2Muc3RhcnQuY29sdW1uICsgMX1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChzb3VyY2UsIHt0eXBlOiAnVGhpc0V4cHJlc3Npb24nfSlcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaW1wb3J0cy5qc3hzID0gdHJ1ZVxuICAgICAgICAgIGNhbGxlZSA9IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdfanN4cyd9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1wb3J0cy5qc3ggPSB0cnVlXG4gICAgICAgICAgY2FsbGVlID0ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19qc3gnfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDbGFzc2ljLlxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChmaWVsZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmFtZXRlcnMudW5zaGlmdCh7dHlwZTogJ09iamVjdEV4cHJlc3Npb24nLCBwcm9wZXJ0aWVzOiBmaWVsZHN9KVxuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmFtZXRlcnMudW5zaGlmdCh7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogbnVsbH0pXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsZWUgPSB0b01lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgYW5ub3RhdGlvbnMuanN4IHx8IGNvbmZpZy5wcmFnbWEgfHwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQnXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KG5hbWUpXG4gICAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgICBjb25zdCBjYWxsID0ge1xuICAgICAgICB0eXBlOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgICBjYWxsZWUsXG4gICAgICAgIGFyZ3VtZW50czogcGFyYW1ldGVycyxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlXG4gICAgICB9XG4gICAgICBjcmVhdGUobm9kZSwgY2FsbClcbiAgICAgIHRoaXMucmVwbGFjZShjYWxsKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBUdXJuIGEgSlNYIGF0dHJpYnV0ZSBpbnRvIGEgSmF2YVNjcmlwdCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge0pTWEF0dHJpYnV0ZX0gbm9kZVxuICogICBKU1ggYXR0cmlidXRlLlxuICogQHJldHVybnMge1Byb3BlcnR5fVxuICogICBKUyBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eShub2RlKSB7XG4gIC8qKiBAdHlwZSB7RXhwcmVzc2lvbn0gKi9cbiAgbGV0IHZhbHVlXG5cbiAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICBpZiAobm9kZS52YWx1ZS50eXBlID09PSAnSlNYRXhwcmVzc2lvbkNvbnRhaW5lcicpIHtcbiAgICAgIGNvbnN0IHZhbHVlRXhwcmVzc2lvbiA9IG5vZGUudmFsdWUuZXhwcmVzc2lvblxuICAgICAgYXNzZXJ0KFxuICAgICAgICB2YWx1ZUV4cHJlc3Npb24udHlwZSAhPT0gJ0pTWEVtcHR5RXhwcmVzc2lvbicsXG4gICAgICAgICdgSlNYRW1wdHlFeHByZXNzaW9uYCBpcyBub3QgYWxsb3dlZCBpbiBwcm9wcy4nXG4gICAgICApXG4gICAgICB2YWx1ZSA9IHZhbHVlRXhwcmVzc2lvblxuICAgIH1cbiAgICAvLyBMaXRlcmFsIG9yIGNhbGwgZXhwcmVzc2lvbi5cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG5vZGVWYWx1ZSA9IG5vZGUudmFsdWVcbiAgICAgIGFzc2VydChcbiAgICAgICAgbm9kZVZhbHVlLnR5cGUgIT09ICdKU1hFbGVtZW50JyAmJiBub2RlVmFsdWUudHlwZSAhPT0gJ0pTWEZyYWdtZW50JyxcbiAgICAgICAgJ0pTWHtFbGVtZW50LEZyYWdtZW50fSBhcmUgYWxyZWFkeSBjb21waWxlZCB0byBgQ2FsbEV4cHJlc3Npb25gJ1xuICAgICAgKVxuICAgICAgdmFsdWUgPSBub2RlVmFsdWVcbiAgICAgIGRlbGV0ZSB2YWx1ZS5yYXdcbiAgICB9XG4gIH1cbiAgLy8gQm9vbGVhbiBwcm9wLlxuICBlbHNlIHtcbiAgICB2YWx1ZSA9IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiB0cnVlfVxuICB9XG5cbiAgLyoqIEB0eXBlIHtQcm9wZXJ0eX0gKi9cbiAgY29uc3QgcmVwbGFjZW1lbnQgPSB7XG4gICAgdHlwZTogJ1Byb3BlcnR5JyxcbiAgICBrZXk6IHRvSWRlbnRpZmllcihub2RlLm5hbWUpLFxuICAgIHZhbHVlLFxuICAgIGtpbmQ6ICdpbml0JyxcbiAgICBtZXRob2Q6IGZhbHNlLFxuICAgIHNob3J0aGFuZDogZmFsc2UsXG4gICAgY29tcHV0ZWQ6IGZhbHNlXG4gIH1cbiAgY3JlYXRlKG5vZGUsIHJlcGxhY2VtZW50KVxuICByZXR1cm4gcmVwbGFjZW1lbnRcbn1cblxuLyoqXG4gKiBUdXJuIGEgSlNYIGlkZW50aWZpZXIgaW50byBhIG5vcm1hbCBKUyBpZGVudGlmaWVyLlxuICpcbiAqIEBwYXJhbSB7SlNYSWRlbnRpZmllciB8IEpTWE1lbWJlckV4cHJlc3Npb24gfCBKU1hOYW1lc3BhY2VkTmFtZX0gbm9kZVxuICogICBKU1ggaWRlbnRpZmllci5cbiAqIEByZXR1cm5zIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259XG4gKiAgIEpTIGlkZW50aWZpZXIuXG4gKi9cbmZ1bmN0aW9uIHRvSWRlbnRpZmllcihub2RlKSB7XG4gIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9ufSAqL1xuICBsZXQgcmVwbGFjZVxuXG4gIGlmIChub2RlLnR5cGUgPT09ICdKU1hNZW1iZXJFeHByZXNzaW9uJykge1xuICAgIC8vIGBwcm9wZXJ0eWAgaXMgYWx3YXlzIGEgYEpTWElkZW50aWZpZXJgLCBidXQgaXQgY291bGQgYmUgc29tZXRoaW5nIHRoYXRcbiAgICAvLyBpc27igJl0IGFuIEVTIGlkZW50aWZpZXIgbmFtZS5cbiAgICBjb25zdCBpZCA9IHRvSWRlbnRpZmllcihub2RlLnByb3BlcnR5KVxuICAgIHJlcGxhY2UgPSB7XG4gICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICBvYmplY3Q6IHRvSWRlbnRpZmllcihub2RlLm9iamVjdCksXG4gICAgICBwcm9wZXJ0eTogaWQsXG4gICAgICBjb21wdXRlZDogaWQudHlwZSA9PT0gJ0xpdGVyYWwnLFxuICAgICAgb3B0aW9uYWw6IGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0pTWE5hbWVzcGFjZWROYW1lJykge1xuICAgIHJlcGxhY2UgPSB7XG4gICAgICB0eXBlOiAnTGl0ZXJhbCcsXG4gICAgICB2YWx1ZTogbm9kZS5uYW1lc3BhY2UubmFtZSArICc6JyArIG5vZGUubmFtZS5uYW1lXG4gICAgfVxuICB9XG4gIC8vIE11c3QgYmUgYEpTWElkZW50aWZpZXJgLlxuICBlbHNlIHtcbiAgICByZXBsYWNlID0gaXNJZGVudGlmaWVyTmFtZShub2RlLm5hbWUpXG4gICAgICA/IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6IG5vZGUubmFtZX1cbiAgICAgIDoge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IG5vZGUubmFtZX1cbiAgfVxuXG4gIGNyZWF0ZShub2RlLCByZXBsYWNlKVxuICByZXR1cm4gcmVwbGFjZVxufVxuXG4vKipcbiAqIFR1cm4gYSBkb3R0ZWQgc3RyaW5nIGludG8gYSBtZW1iZXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqICAgSWRlbnRpZmllcnMuXG4gKiBAcmV0dXJucyB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9ufVxuICogICBFeHByZXNzaW9uLlxuICovXG5mdW5jdGlvbiB0b01lbWJlckV4cHJlc3Npb24oaWQpIHtcbiAgY29uc3QgaWRlbnRpZmllcnMgPSBpZC5zcGxpdCgnLicpXG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9uIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgcmVzdWx0XG5cbiAgd2hpbGUgKCsraW5kZXggPCBpZGVudGlmaWVycy5sZW5ndGgpIHtcbiAgICAvKiogQHR5cGUge0lkZW50aWZpZXIgfCBMaXRlcmFsfSAqL1xuICAgIGNvbnN0IHByb3AgPSBpc0lkZW50aWZpZXJOYW1lKGlkZW50aWZpZXJzW2luZGV4XSlcbiAgICAgID8ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogaWRlbnRpZmllcnNbaW5kZXhdfVxuICAgICAgOiB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogaWRlbnRpZmllcnNbaW5kZXhdfVxuICAgIHJlc3VsdCA9IHJlc3VsdFxuICAgICAgPyB7XG4gICAgICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICAgIG9iamVjdDogcmVzdWx0LFxuICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgIGNvbXB1dGVkOiBCb29sZWFuKGluZGV4ICYmIHByb3AudHlwZSA9PT0gJ0xpdGVyYWwnKSxcbiAgICAgICAgICBvcHRpb25hbDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgOiBwcm9wXG4gIH1cblxuICBhc3NlcnQocmVzdWx0LCAnYWx3YXlzIGEgcmVzdWx0JylcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEluaGVyaXQgc29tZSBmaWVsZHMgZnJvbSBgZnJvbWAgaW50byBgdG9gLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gZnJvbVxuICogICBOb2RlIHRvIGluaGVyaXQgZnJvbS5cbiAqIEBwYXJhbSB7Tm9kZX0gdG9cbiAqICAgTm9kZSB0byBhZGQgdG8uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGUoZnJvbSwgdG8pIHtcbiAgY29uc3QgZmllbGRzID0gWydzdGFydCcsICdlbmQnLCAnbG9jJywgJ3JhbmdlJywgJ2NvbW1lbnRzJ11cbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGZpZWxkcy5sZW5ndGgpIHtcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tpbmRleF1cbiAgICBpZiAoZmllbGQgaW4gZnJvbSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW5kZXhhYmxlLlxuICAgICAgdG9bZmllbGRdID0gZnJvbVtmaWVsZF1cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/estree-util-build-jsx@3.0.1/node_modules/estree-util-build-jsx/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/estree-util-build-jsx@3.0.1/node_modules/estree-util-build-jsx/lib/index.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/estree-util-build-jsx@3.0.1/node_modules/estree-util-build-jsx/lib/index.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildJsx: () => (/* binding */ buildJsx)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(rsc)/./node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! estree-util-is-identifier-name */ \"(rsc)/./node_modules/.pnpm/estree-util-is-identifier-name@3.0.0/node_modules/estree-util-is-identifier-name/lib/index.js\");\n/* harmony import */ var estree_walker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! estree-walker */ \"(rsc)/./node_modules/.pnpm/estree-walker@3.0.3/node_modules/estree-walker/src/index.js\");\n/**\n * @typedef {import('estree-jsx').Expression} Expression\n * @typedef {import('estree-jsx').Identifier} Identifier\n * @typedef {import('estree-jsx').ImportSpecifier} ImportSpecifier\n * @typedef {import('estree-jsx').JSXAttribute} JSXAttribute\n * @typedef {import('estree-jsx').JSXIdentifier} JSXIdentifier\n * @typedef {import('estree-jsx').JSXMemberExpression} JSXMemberExpression\n * @typedef {import('estree-jsx').JSXNamespacedName} JSXNamespacedName\n * @typedef {import('estree-jsx').Literal} Literal\n * @typedef {import('estree-jsx').MemberExpression} MemberExpression\n * @typedef {import('estree-jsx').Node} Node\n * @typedef {import('estree-jsx').ObjectExpression} ObjectExpression\n * @typedef {import('estree-jsx').Property} Property\n * @typedef {import('estree-jsx').SpreadElement} SpreadElement\n *\n * @typedef {'automatic' | 'classic'} Runtime\n *   How to transform JSX.\n *\n * @typedef Options\n *   Configuration.\n *\n *   > ðŸ‘‰ **Note**: you can also configure `runtime`, `importSource`, `pragma`,\n *   > and `pragmaFrag` from within files through comments.\n * @property {Runtime | null | undefined} [runtime='classic']\n *   Choose the runtime (default: `'classic'`).\n *\n *   Comment form: `@jsxRuntime theRuntime`.\n * @property {string | null | undefined} [importSource='react']\n *   Place to import `jsx`, `jsxs`, `jsxDEV`, and `Fragment` from, when the\n *   effective runtime is automatic (default: `'react'`).\n *\n *   Comment form: `@jsxImportSource theSource`.\n *\n *   > ðŸ‘‰ **Note**: `/jsx-runtime` or `/jsx-dev-runtime` is appended to this\n *   > provided source.\n *   > In CJS, that can resolve to a file (as in `theSource/jsx-runtime.js`),\n *   > but for ESM an export map needs to be set up to point to files:\n *   >\n *   > ```js\n *   > // â€¦\n *   > \"exports\": {\n *   >   // â€¦\n *   >   \"./jsx-runtime\": \"./path/to/jsx-runtime.js\",\n *   >   \"./jsx-dev-runtime\": \"./path/to/jsx-runtime.js\"\n *   >   // â€¦\n *   > ```\n * @property {string | null | undefined} [pragma='React.createElement']\n *   Identifier or member expression to call when the effective runtime is\n *   classic (default: `'React.createElement'`).\n *\n *   Comment form: `@jsx identifier`.\n * @property {string | null | undefined} [pragmaFrag='React.Fragment']\n *   Identifier or member expression to use as a symbol for fragments when the\n *   effective runtime is classic (default: `'React.Fragment'`).\n *\n *   Comment form: `@jsxFrag identifier`.\n * @property {boolean | null | undefined} [development=false]\n *   When in the automatic runtime, whether to import\n *   `theSource/jsx-dev-runtime.js`, use `jsxDEV`, and pass location info when\n *   available (default: `false`).\n *\n *   This helps debugging but adds a lot of code that you donâ€™t want in\n *   production.\n * @property {string | null | undefined} [filePath]\n *   File path to the original source file (optional).\n *\n *   Passed in location info to `jsxDEV` when using the automatic runtime with\n *   `development: true`.\n *\n * @typedef Annotations\n *   State where info from comments is gathered.\n * @property {string | undefined} [jsx]\n *   JSX identifier (`pragma`).\n * @property {string | undefined} [jsxFrag]\n *   JSX identifier of fragment (`pragmaFrag`).\n * @property {string | undefined} [jsxImportSource]\n *   Where to import an automatic JSX runtime from.\n * @property {Runtime | undefined} [jsxRuntime]\n *   Runtime.\n *\n * @typedef Imports\n *   State of used identifiers from the automatic runtime.\n * @property {boolean | undefined} [fragment]\n *   Symbol of `Fragment`.\n * @property {boolean | undefined} [jsx]\n *   Symbol of `jsx`.\n * @property {boolean | undefined} [jsxs]\n *   Symbol of `jsxs`.\n * @property {boolean | undefined} [jsxDEV]\n *   Symbol of `jsxDEV`.\n */\n\n\n\n\n\nconst regex = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\\s+(\\S+)/g\n\n/**\n * Turn JSX in `tree` into function calls: `<x />` -> `h('x')`!\n *\n * ###### Algorithm\n *\n * In almost all cases, this utility is the same as the Babel plugin, except that\n * they work on slightly different syntax trees.\n *\n * Some differences:\n *\n * *   no pure annotations things\n * *   `this` is not a component: `<this>` -> `h('this')`, not `h(this)`\n * *   namespaces are supported: `<a:b c:d>` -> `h('a:b', {'c:d': true})`,\n *     which throws by default in Babel or can be turned on with `throwIfNamespace`\n * *   no `useSpread`, `useBuiltIns`, or `filter` options\n *\n * @param {Node} tree\n *   Tree to transform (typically `Program`).\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nfunction buildJsx(tree, options) {\n  const config = options || {}\n  let automatic = config.runtime === 'automatic'\n  /** @type {Annotations} */\n  const annotations = {}\n  /** @type {Imports} */\n  const imports = {}\n\n  ;(0,estree_walker__WEBPACK_IMPORTED_MODULE_0__.walk)(tree, {\n    enter(node) {\n      if (node.type === 'Program') {\n        const comments = node.comments || []\n        let index = -1\n\n        while (++index < comments.length) {\n          regex.lastIndex = 0\n\n          let match = regex.exec(comments[index].value)\n\n          while (match) {\n            // @ts-expect-error: `match[1]` is always a key, `match[2]` when\n            // runtime is checked later.\n            annotations[match[1]] = match[2]\n            match = regex.exec(comments[index].value)\n          }\n        }\n\n        if (annotations.jsxRuntime) {\n          if (annotations.jsxRuntime === 'automatic') {\n            automatic = true\n\n            if (annotations.jsx) {\n              throw new Error('Unexpected `@jsx` pragma w/ automatic runtime')\n            }\n\n            if (annotations.jsxFrag) {\n              throw new Error(\n                'Unexpected `@jsxFrag` pragma w/ automatic runtime'\n              )\n            }\n          } else if (annotations.jsxRuntime === 'classic') {\n            automatic = false\n\n            if (annotations.jsxImportSource) {\n              throw new Error(\n                'Unexpected `@jsxImportSource` w/ classic runtime'\n              )\n            }\n          } else {\n            throw new Error(\n              'Unexpected `jsxRuntime` `' +\n                annotations.jsxRuntime +\n                '`, expected `automatic` or `classic`'\n            )\n          }\n        }\n      }\n    },\n    // eslint-disable-next-line complexity\n    leave(node) {\n      if (node.type === 'Program') {\n        /** @type {Array<ImportSpecifier>} */\n        const specifiers = []\n\n        if (imports.fragment) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'Fragment'},\n            local: {type: 'Identifier', name: '_Fragment'}\n          })\n        }\n\n        if (imports.jsx) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'jsx'},\n            local: {type: 'Identifier', name: '_jsx'}\n          })\n        }\n\n        if (imports.jsxs) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'jsxs'},\n            local: {type: 'Identifier', name: '_jsxs'}\n          })\n        }\n\n        if (imports.jsxDEV) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'jsxDEV'},\n            local: {type: 'Identifier', name: '_jsxDEV'}\n          })\n        }\n\n        if (specifiers.length > 0) {\n          let injectIndex = 0\n\n          while (injectIndex < node.body.length) {\n            const child = node.body[injectIndex]\n\n            if ('directive' in child && child.directive) {\n              injectIndex++\n            } else {\n              break\n            }\n          }\n\n          node.body.splice(injectIndex, 0, {\n            type: 'ImportDeclaration',\n            specifiers,\n            source: {\n              type: 'Literal',\n              value:\n                (annotations.jsxImportSource ||\n                  config.importSource ||\n                  'react') +\n                (config.development ? '/jsx-dev-runtime' : '/jsx-runtime')\n            }\n          })\n        }\n      }\n\n      if (node.type !== 'JSXElement' && node.type !== 'JSXFragment') {\n        return\n      }\n\n      /** @type {Array<Expression>} */\n      const children = []\n      let index = -1\n\n      // Figure out `children`.\n      while (++index < node.children.length) {\n        const child = node.children[index]\n\n        if (child.type === 'JSXExpressionContainer') {\n          // Ignore empty expressions.\n          if (child.expression.type !== 'JSXEmptyExpression') {\n            children.push(child.expression)\n          }\n        } else if (child.type === 'JSXText') {\n          const value = child.value\n            // Replace tabs w/ spaces.\n            .replace(/\\t/g, ' ')\n            // Use line feeds, drop spaces around them.\n            .replace(/ *(\\r?\\n|\\r) */g, '\\n')\n            // Collapse multiple line feeds.\n            .replace(/\\n+/g, '\\n')\n            // Drop final line feeds.\n            .replace(/\\n+$/, '')\n            // Drop first line feeds.\n            .replace(/^\\n+/, '')\n            // Replace line feeds with spaces.\n            .replace(/\\n/g, ' ')\n\n          // Ignore collapsible text.\n          if (value) {\n            /** @type {Node} */\n            const text = {type: 'Literal', value}\n            create(child, text)\n            children.push(text)\n          }\n        } else {\n          (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n            child.type !== 'JSXElement' &&\n              child.type !== 'JSXFragment' &&\n              child.type !== 'JSXSpreadChild'\n          )\n          children.push(child)\n        }\n      }\n\n      /** @type {Identifier | Literal | MemberExpression} */\n      let name\n      /** @type {Array<Property | SpreadElement>} */\n      const fields = []\n      /** @type {Array<Expression>} */\n      let parameters = []\n      /** @type {Expression | undefined} */\n      let key\n\n      // Do the stuff needed for elements.\n      if (node.type === 'JSXElement') {\n        name = toIdentifier(node.openingElement.name)\n\n        // If the name could be an identifier, but start with a lowercase letter,\n        // itâ€™s not a component.\n        if (name.type === 'Identifier' && /^[a-z]/.test(name.name)) {\n          /** @type {Node} */\n          const next = {type: 'Literal', value: name.name}\n          create(name, next)\n          name = next\n        }\n\n        /** @type {boolean | undefined} */\n        let spread\n        const attributes = node.openingElement.attributes\n        let index = -1\n\n        // Place props in the right order, because we might have duplicates\n        // in them and whatâ€™s spread in.\n        while (++index < attributes.length) {\n          const attribute = attributes[index]\n\n          if (attribute.type === 'JSXSpreadAttribute') {\n            if (attribute.argument.type === 'ObjectExpression') {\n              fields.push(...attribute.argument.properties)\n            } else {\n              fields.push({type: 'SpreadElement', argument: attribute.argument})\n            }\n\n            spread = true\n          } else {\n            const prop = toProperty(attribute)\n\n            if (\n              automatic &&\n              prop.key.type === 'Identifier' &&\n              prop.key.name === 'key'\n            ) {\n              if (spread) {\n                throw new Error(\n                  'Expected `key` to come before any spread expressions'\n                )\n              }\n\n              const value = prop.value\n\n              ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n                value.type !== 'AssignmentPattern' &&\n                  value.type !== 'ArrayPattern' &&\n                  value.type !== 'ObjectPattern' &&\n                  value.type !== 'RestElement'\n              )\n\n              key = value\n            } else {\n              fields.push(prop)\n            }\n          }\n        }\n      }\n      // â€¦and fragments.\n      else if (automatic) {\n        imports.fragment = true\n        name = {type: 'Identifier', name: '_Fragment'}\n      } else {\n        name = toMemberExpression(\n          annotations.jsxFrag || config.pragmaFrag || 'React.Fragment'\n        )\n      }\n\n      if (automatic) {\n        if (children.length > 0) {\n          fields.push({\n            type: 'Property',\n            key: {type: 'Identifier', name: 'children'},\n            value:\n              children.length > 1\n                ? {type: 'ArrayExpression', elements: children}\n                : children[0],\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed: false\n          })\n        }\n      } else {\n        parameters = children\n      }\n\n      /** @type {Identifier | Literal | MemberExpression} */\n      let callee\n\n      if (automatic) {\n        parameters.push({type: 'ObjectExpression', properties: fields})\n\n        if (key) {\n          parameters.push(key)\n        } else if (config.development) {\n          parameters.push({type: 'Identifier', name: 'undefined'})\n        }\n\n        const isStaticChildren = children.length > 1\n\n        if (config.development) {\n          imports.jsxDEV = true\n          callee = {\n            type: 'Identifier',\n            name: '_jsxDEV'\n          }\n          parameters.push({type: 'Literal', value: isStaticChildren})\n\n          /** @type {ObjectExpression} */\n          const source = {\n            type: 'ObjectExpression',\n            properties: [\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                kind: 'init',\n                key: {type: 'Identifier', name: 'fileName'},\n                value: {\n                  type: 'Literal',\n                  value: config.filePath || '<source.js>'\n                }\n              }\n            ]\n          }\n\n          if (node.loc) {\n            source.properties.push(\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                kind: 'init',\n                key: {type: 'Identifier', name: 'lineNumber'},\n                value: {type: 'Literal', value: node.loc.start.line}\n              },\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                kind: 'init',\n                key: {type: 'Identifier', name: 'columnNumber'},\n                value: {type: 'Literal', value: node.loc.start.column + 1}\n              }\n            )\n          }\n\n          parameters.push(source, {type: 'ThisExpression'})\n        } else if (isStaticChildren) {\n          imports.jsxs = true\n          callee = {type: 'Identifier', name: '_jsxs'}\n        } else {\n          imports.jsx = true\n          callee = {type: 'Identifier', name: '_jsx'}\n        }\n      }\n      // Classic.\n      else {\n        if (fields.length > 0) {\n          parameters.unshift({type: 'ObjectExpression', properties: fields})\n        } else if (parameters.length > 0) {\n          parameters.unshift({type: 'Literal', value: null})\n        }\n\n        callee = toMemberExpression(\n          annotations.jsx || config.pragma || 'React.createElement'\n        )\n      }\n\n      parameters.unshift(name)\n      /** @type {Node} */\n      const call = {\n        type: 'CallExpression',\n        callee,\n        arguments: parameters,\n        optional: false\n      }\n      create(node, call)\n      this.replace(call)\n    }\n  })\n}\n\n/**\n * Turn a JSX attribute into a JavaScript property.\n *\n * @param {JSXAttribute} node\n *   JSX attribute.\n * @returns {Property}\n *   JS property.\n */\nfunction toProperty(node) {\n  /** @type {Expression} */\n  let value\n\n  if (node.value) {\n    if (node.value.type === 'JSXExpressionContainer') {\n      const valueExpression = node.value.expression\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n        valueExpression.type !== 'JSXEmptyExpression',\n        '`JSXEmptyExpression` is not allowed in props.'\n      )\n      value = valueExpression\n    }\n    // Literal or call expression.\n    else {\n      const nodeValue = node.value\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n        nodeValue.type !== 'JSXElement' && nodeValue.type !== 'JSXFragment',\n        'JSX{Element,Fragment} are already compiled to `CallExpression`'\n      )\n      value = nodeValue\n      delete value.raw\n    }\n  }\n  // Boolean prop.\n  else {\n    value = {type: 'Literal', value: true}\n  }\n\n  /** @type {Property} */\n  const replacement = {\n    type: 'Property',\n    key: toIdentifier(node.name),\n    value,\n    kind: 'init',\n    method: false,\n    shorthand: false,\n    computed: false\n  }\n  create(node, replacement)\n  return replacement\n}\n\n/**\n * Turn a JSX identifier into a normal JS identifier.\n *\n * @param {JSXIdentifier | JSXMemberExpression | JSXNamespacedName} node\n *   JSX identifier.\n * @returns {Identifier | Literal | MemberExpression}\n *   JS identifier.\n */\nfunction toIdentifier(node) {\n  /** @type {Identifier | Literal | MemberExpression} */\n  let replace\n\n  if (node.type === 'JSXMemberExpression') {\n    // `property` is always a `JSXIdentifier`, but it could be something that\n    // isnâ€™t an ES identifier name.\n    const id = toIdentifier(node.property)\n    replace = {\n      type: 'MemberExpression',\n      object: toIdentifier(node.object),\n      property: id,\n      computed: id.type === 'Literal',\n      optional: false\n    }\n  } else if (node.type === 'JSXNamespacedName') {\n    replace = {\n      type: 'Literal',\n      value: node.namespace.name + ':' + node.name.name\n    }\n  }\n  // Must be `JSXIdentifier`.\n  else {\n    replace = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__.name)(node.name)\n      ? {type: 'Identifier', name: node.name}\n      : {type: 'Literal', value: node.name}\n  }\n\n  create(node, replace)\n  return replace\n}\n\n/**\n * Turn a dotted string into a member expression.\n *\n * @param {string} id\n *   Identifiers.\n * @returns {Identifier | Literal | MemberExpression}\n *   Expression.\n */\nfunction toMemberExpression(id) {\n  const identifiers = id.split('.')\n  let index = -1\n  /** @type {Identifier | Literal | MemberExpression | undefined} */\n  let result\n\n  while (++index < identifiers.length) {\n    /** @type {Identifier | Literal} */\n    const prop = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__.name)(identifiers[index])\n      ? {type: 'Identifier', name: identifiers[index]}\n      : {type: 'Literal', value: identifiers[index]}\n    result = result\n      ? {\n          type: 'MemberExpression',\n          object: result,\n          property: prop,\n          computed: Boolean(index && prop.type === 'Literal'),\n          optional: false\n        }\n      : prop\n  }\n\n  (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(result, 'always a result')\n  return result\n}\n\n/**\n * Inherit some fields from `from` into `to`.\n *\n * @param {Node} from\n *   Node to inherit from.\n * @param {Node} to\n *   Node to add to.\n * @returns {undefined}\n *   Nothing.\n */\nfunction create(from, to) {\n  const fields = ['start', 'end', 'loc', 'range', 'comments']\n  let index = -1\n\n  while (++index < fields.length) {\n    const field = fields[index]\n    if (field in from) {\n      // @ts-expect-error: indexable.\n      to[field] = from[field]\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vZXN0cmVlLXV0aWwtYnVpbGQtanN4QDMuMC4xL25vZGVfbW9kdWxlcy9lc3RyZWUtdXRpbC1idWlsZC1qc3gvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBLGFBQWEsaUNBQWlDO0FBQzlDLGFBQWEsaUNBQWlDO0FBQzlDLGFBQWEsc0NBQXNDO0FBQ25ELGFBQWEsbUNBQW1DO0FBQ2hELGFBQWEsb0NBQW9DO0FBQ2pELGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsd0NBQXdDO0FBQ3JELGFBQWEsOEJBQThCO0FBQzNDLGFBQWEsdUNBQXVDO0FBQ3BELGFBQWEsMkJBQTJCO0FBQ3hDLGFBQWEsdUNBQXVDO0FBQ3BELGFBQWEsK0JBQStCO0FBQzVDLGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0EsY0FBYyxx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YnVpbGQtanN4QDMuMC4xL25vZGVfbW9kdWxlcy9lc3RyZWUtdXRpbC1idWlsZC1qc3gvbGliL2luZGV4LmpzPzY5OTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuRXhwcmVzc2lvbn0gRXhwcmVzc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLklkZW50aWZpZXJ9IElkZW50aWZpZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5JbXBvcnRTcGVjaWZpZXJ9IEltcG9ydFNwZWNpZmllclxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkpTWEF0dHJpYnV0ZX0gSlNYQXR0cmlidXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuSlNYSWRlbnRpZmllcn0gSlNYSWRlbnRpZmllclxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkpTWE1lbWJlckV4cHJlc3Npb259IEpTWE1lbWJlckV4cHJlc3Npb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5KU1hOYW1lc3BhY2VkTmFtZX0gSlNYTmFtZXNwYWNlZE5hbWVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5MaXRlcmFsfSBMaXRlcmFsXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuTWVtYmVyRXhwcmVzc2lvbn0gTWVtYmVyRXhwcmVzc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLk5vZGV9IE5vZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5PYmplY3RFeHByZXNzaW9ufSBPYmplY3RFeHByZXNzaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuUHJvcGVydHl9IFByb3BlcnR5XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuU3ByZWFkRWxlbWVudH0gU3ByZWFkRWxlbWVudFxuICpcbiAqIEB0eXBlZGVmIHsnYXV0b21hdGljJyB8ICdjbGFzc2ljJ30gUnVudGltZVxuICogICBIb3cgdG8gdHJhbnNmb3JtIEpTWC5cbiAqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IHlvdSBjYW4gYWxzbyBjb25maWd1cmUgYHJ1bnRpbWVgLCBgaW1wb3J0U291cmNlYCwgYHByYWdtYWAsXG4gKiAgID4gYW5kIGBwcmFnbWFGcmFnYCBmcm9tIHdpdGhpbiBmaWxlcyB0aHJvdWdoIGNvbW1lbnRzLlxuICogQHByb3BlcnR5IHtSdW50aW1lIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3J1bnRpbWU9J2NsYXNzaWMnXVxuICogICBDaG9vc2UgdGhlIHJ1bnRpbWUgKGRlZmF1bHQ6IGAnY2xhc3NpYydgKS5cbiAqXG4gKiAgIENvbW1lbnQgZm9ybTogYEBqc3hSdW50aW1lIHRoZVJ1bnRpbWVgLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbaW1wb3J0U291cmNlPSdyZWFjdCddXG4gKiAgIFBsYWNlIHRvIGltcG9ydCBganN4YCwgYGpzeHNgLCBganN4REVWYCwgYW5kIGBGcmFnbWVudGAgZnJvbSwgd2hlbiB0aGVcbiAqICAgZWZmZWN0aXZlIHJ1bnRpbWUgaXMgYXV0b21hdGljIChkZWZhdWx0OiBgJ3JlYWN0J2ApLlxuICpcbiAqICAgQ29tbWVudCBmb3JtOiBgQGpzeEltcG9ydFNvdXJjZSB0aGVTb3VyY2VgLlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiBgL2pzeC1ydW50aW1lYCBvciBgL2pzeC1kZXYtcnVudGltZWAgaXMgYXBwZW5kZWQgdG8gdGhpc1xuICogICA+IHByb3ZpZGVkIHNvdXJjZS5cbiAqICAgPiBJbiBDSlMsIHRoYXQgY2FuIHJlc29sdmUgdG8gYSBmaWxlIChhcyBpbiBgdGhlU291cmNlL2pzeC1ydW50aW1lLmpzYCksXG4gKiAgID4gYnV0IGZvciBFU00gYW4gZXhwb3J0IG1hcCBuZWVkcyB0byBiZSBzZXQgdXAgdG8gcG9pbnQgdG8gZmlsZXM6XG4gKiAgID5cbiAqICAgPiBgYGBqc1xuICogICA+IC8vIOKAplxuICogICA+IFwiZXhwb3J0c1wiOiB7XG4gKiAgID4gICAvLyDigKZcbiAqICAgPiAgIFwiLi9qc3gtcnVudGltZVwiOiBcIi4vcGF0aC90by9qc3gtcnVudGltZS5qc1wiLFxuICogICA+ICAgXCIuL2pzeC1kZXYtcnVudGltZVwiOiBcIi4vcGF0aC90by9qc3gtcnVudGltZS5qc1wiXG4gKiAgID4gICAvLyDigKZcbiAqICAgPiBgYGBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3ByYWdtYT0nUmVhY3QuY3JlYXRlRWxlbWVudCddXG4gKiAgIElkZW50aWZpZXIgb3IgbWVtYmVyIGV4cHJlc3Npb24gdG8gY2FsbCB3aGVuIHRoZSBlZmZlY3RpdmUgcnVudGltZSBpc1xuICogICBjbGFzc2ljIChkZWZhdWx0OiBgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQnYCkuXG4gKlxuICogICBDb21tZW50IGZvcm06IGBAanN4IGlkZW50aWZpZXJgLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJhZ21hRnJhZz0nUmVhY3QuRnJhZ21lbnQnXVxuICogICBJZGVudGlmaWVyIG9yIG1lbWJlciBleHByZXNzaW9uIHRvIHVzZSBhcyBhIHN5bWJvbCBmb3IgZnJhZ21lbnRzIHdoZW4gdGhlXG4gKiAgIGVmZmVjdGl2ZSBydW50aW1lIGlzIGNsYXNzaWMgKGRlZmF1bHQ6IGAnUmVhY3QuRnJhZ21lbnQnYCkuXG4gKlxuICogICBDb21tZW50IGZvcm06IGBAanN4RnJhZyBpZGVudGlmaWVyYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtkZXZlbG9wbWVudD1mYWxzZV1cbiAqICAgV2hlbiBpbiB0aGUgYXV0b21hdGljIHJ1bnRpbWUsIHdoZXRoZXIgdG8gaW1wb3J0XG4gKiAgIGB0aGVTb3VyY2UvanN4LWRldi1ydW50aW1lLmpzYCwgdXNlIGBqc3hERVZgLCBhbmQgcGFzcyBsb2NhdGlvbiBpbmZvIHdoZW5cbiAqICAgYXZhaWxhYmxlIChkZWZhdWx0OiBgZmFsc2VgKS5cbiAqXG4gKiAgIFRoaXMgaGVscHMgZGVidWdnaW5nIGJ1dCBhZGRzIGEgbG90IG9mIGNvZGUgdGhhdCB5b3UgZG9u4oCZdCB3YW50IGluXG4gKiAgIHByb2R1Y3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtmaWxlUGF0aF1cbiAqICAgRmlsZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAob3B0aW9uYWwpLlxuICpcbiAqICAgUGFzc2VkIGluIGxvY2F0aW9uIGluZm8gdG8gYGpzeERFVmAgd2hlbiB1c2luZyB0aGUgYXV0b21hdGljIHJ1bnRpbWUgd2l0aFxuICogICBgZGV2ZWxvcG1lbnQ6IHRydWVgLlxuICpcbiAqIEB0eXBlZGVmIEFubm90YXRpb25zXG4gKiAgIFN0YXRlIHdoZXJlIGluZm8gZnJvbSBjb21tZW50cyBpcyBnYXRoZXJlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbanN4XVxuICogICBKU1ggaWRlbnRpZmllciAoYHByYWdtYWApLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IFtqc3hGcmFnXVxuICogICBKU1ggaWRlbnRpZmllciBvZiBmcmFnbWVudCAoYHByYWdtYUZyYWdgKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbanN4SW1wb3J0U291cmNlXVxuICogICBXaGVyZSB0byBpbXBvcnQgYW4gYXV0b21hdGljIEpTWCBydW50aW1lIGZyb20uXG4gKiBAcHJvcGVydHkge1J1bnRpbWUgfCB1bmRlZmluZWR9IFtqc3hSdW50aW1lXVxuICogICBSdW50aW1lLlxuICpcbiAqIEB0eXBlZGVmIEltcG9ydHNcbiAqICAgU3RhdGUgb2YgdXNlZCBpZGVudGlmaWVycyBmcm9tIHRoZSBhdXRvbWF0aWMgcnVudGltZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gW2ZyYWdtZW50XVxuICogICBTeW1ib2wgb2YgYEZyYWdtZW50YC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gW2pzeF1cbiAqICAgU3ltYm9sIG9mIGBqc3hgLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgdW5kZWZpbmVkfSBbanN4c11cbiAqICAgU3ltYm9sIG9mIGBqc3hzYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gW2pzeERFVl1cbiAqICAgU3ltYm9sIG9mIGBqc3hERVZgLlxuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge25hbWUgYXMgaXNJZGVudGlmaWVyTmFtZX0gZnJvbSAnZXN0cmVlLXV0aWwtaXMtaWRlbnRpZmllci1uYW1lJ1xuaW1wb3J0IHt3YWxrfSBmcm9tICdlc3RyZWUtd2Fsa2VyJ1xuXG5jb25zdCByZWdleCA9IC9AKGpzeHxqc3hGcmFnfGpzeEltcG9ydFNvdXJjZXxqc3hSdW50aW1lKVxccysoXFxTKykvZ1xuXG4vKipcbiAqIFR1cm4gSlNYIGluIGB0cmVlYCBpbnRvIGZ1bmN0aW9uIGNhbGxzOiBgPHggLz5gIC0+IGBoKCd4JylgIVxuICpcbiAqICMjIyMjIyBBbGdvcml0aG1cbiAqXG4gKiBJbiBhbG1vc3QgYWxsIGNhc2VzLCB0aGlzIHV0aWxpdHkgaXMgdGhlIHNhbWUgYXMgdGhlIEJhYmVsIHBsdWdpbiwgZXhjZXB0IHRoYXRcbiAqIHRoZXkgd29yayBvbiBzbGlnaHRseSBkaWZmZXJlbnQgc3ludGF4IHRyZWVzLlxuICpcbiAqIFNvbWUgZGlmZmVyZW5jZXM6XG4gKlxuICogKiAgIG5vIHB1cmUgYW5ub3RhdGlvbnMgdGhpbmdzXG4gKiAqICAgYHRoaXNgIGlzIG5vdCBhIGNvbXBvbmVudDogYDx0aGlzPmAgLT4gYGgoJ3RoaXMnKWAsIG5vdCBgaCh0aGlzKWBcbiAqICogICBuYW1lc3BhY2VzIGFyZSBzdXBwb3J0ZWQ6IGA8YTpiIGM6ZD5gIC0+IGBoKCdhOmInLCB7J2M6ZCc6IHRydWV9KWAsXG4gKiAgICAgd2hpY2ggdGhyb3dzIGJ5IGRlZmF1bHQgaW4gQmFiZWwgb3IgY2FuIGJlIHR1cm5lZCBvbiB3aXRoIGB0aHJvd0lmTmFtZXNwYWNlYFxuICogKiAgIG5vIGB1c2VTcHJlYWRgLCBgdXNlQnVpbHRJbnNgLCBvciBgZmlsdGVyYCBvcHRpb25zXG4gKlxuICogQHBhcmFtIHtOb2RlfSB0cmVlXG4gKiAgIFRyZWUgdG8gdHJhbnNmb3JtICh0eXBpY2FsbHkgYFByb2dyYW1gKS5cbiAqIEBwYXJhbSB7T3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRKc3godHJlZSwgb3B0aW9ucykge1xuICBjb25zdCBjb25maWcgPSBvcHRpb25zIHx8IHt9XG4gIGxldCBhdXRvbWF0aWMgPSBjb25maWcucnVudGltZSA9PT0gJ2F1dG9tYXRpYydcbiAgLyoqIEB0eXBlIHtBbm5vdGF0aW9uc30gKi9cbiAgY29uc3QgYW5ub3RhdGlvbnMgPSB7fVxuICAvKiogQHR5cGUge0ltcG9ydHN9ICovXG4gIGNvbnN0IGltcG9ydHMgPSB7fVxuXG4gIHdhbGsodHJlZSwge1xuICAgIGVudGVyKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdQcm9ncmFtJykge1xuICAgICAgICBjb25zdCBjb21tZW50cyA9IG5vZGUuY29tbWVudHMgfHwgW11cbiAgICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCA9IDBcblxuICAgICAgICAgIGxldCBtYXRjaCA9IHJlZ2V4LmV4ZWMoY29tbWVudHNbaW5kZXhdLnZhbHVlKVxuXG4gICAgICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgbWF0Y2hbMV1gIGlzIGFsd2F5cyBhIGtleSwgYG1hdGNoWzJdYCB3aGVuXG4gICAgICAgICAgICAvLyBydW50aW1lIGlzIGNoZWNrZWQgbGF0ZXIuXG4gICAgICAgICAgICBhbm5vdGF0aW9uc1ttYXRjaFsxXV0gPSBtYXRjaFsyXVxuICAgICAgICAgICAgbWF0Y2ggPSByZWdleC5leGVjKGNvbW1lbnRzW2luZGV4XS52YWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5ub3RhdGlvbnMuanN4UnVudGltZSkge1xuICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5qc3hSdW50aW1lID09PSAnYXV0b21hdGljJykge1xuICAgICAgICAgICAgYXV0b21hdGljID0gdHJ1ZVxuXG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuanN4KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBgQGpzeGAgcHJhZ21hIHcvIGF1dG9tYXRpYyBydW50aW1lJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zLmpzeEZyYWcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIGBAanN4RnJhZ2AgcHJhZ21hIHcvIGF1dG9tYXRpYyBydW50aW1lJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhbm5vdGF0aW9ucy5qc3hSdW50aW1lID09PSAnY2xhc3NpYycpIHtcbiAgICAgICAgICAgIGF1dG9tYXRpYyA9IGZhbHNlXG5cbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5qc3hJbXBvcnRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIGBAanN4SW1wb3J0U291cmNlYCB3LyBjbGFzc2ljIHJ1bnRpbWUnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnVW5leHBlY3RlZCBganN4UnVudGltZWAgYCcgK1xuICAgICAgICAgICAgICAgIGFubm90YXRpb25zLmpzeFJ1bnRpbWUgK1xuICAgICAgICAgICAgICAgICdgLCBleHBlY3RlZCBgYXV0b21hdGljYCBvciBgY2xhc3NpY2AnXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIGxlYXZlKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdQcm9ncmFtJykge1xuICAgICAgICAvKiogQHR5cGUge0FycmF5PEltcG9ydFNwZWNpZmllcj59ICovXG4gICAgICAgIGNvbnN0IHNwZWNpZmllcnMgPSBbXVxuXG4gICAgICAgIGlmIChpbXBvcnRzLmZyYWdtZW50KSB7XG4gICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICAgICAgaW1wb3J0ZWQ6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdGcmFnbWVudCd9LFxuICAgICAgICAgICAgbG9jYWw6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdfRnJhZ21lbnQnfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW1wb3J0cy5qc3gpIHtcbiAgICAgICAgICBzcGVjaWZpZXJzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ0ltcG9ydFNwZWNpZmllcicsXG4gICAgICAgICAgICBpbXBvcnRlZDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2pzeCd9LFxuICAgICAgICAgICAgbG9jYWw6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdfanN4J31cbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGltcG9ydHMuanN4cykge1xuICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnSW1wb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgICAgIGltcG9ydGVkOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnanN4cyd9LFxuICAgICAgICAgICAgbG9jYWw6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdfanN4cyd9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbXBvcnRzLmpzeERFVikge1xuICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnSW1wb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgICAgIGltcG9ydGVkOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnanN4REVWJ30sXG4gICAgICAgICAgICBsb2NhbDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19qc3hERVYnfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3BlY2lmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IGluamVjdEluZGV4ID0gMFxuXG4gICAgICAgICAgd2hpbGUgKGluamVjdEluZGV4IDwgbm9kZS5ib2R5Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmJvZHlbaW5qZWN0SW5kZXhdXG5cbiAgICAgICAgICAgIGlmICgnZGlyZWN0aXZlJyBpbiBjaGlsZCAmJiBjaGlsZC5kaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgaW5qZWN0SW5kZXgrK1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2RlLmJvZHkuc3BsaWNlKGluamVjdEluZGV4LCAwLCB7XG4gICAgICAgICAgICB0eXBlOiAnSW1wb3J0RGVjbGFyYXRpb24nLFxuICAgICAgICAgICAgc3BlY2lmaWVycyxcbiAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICB0eXBlOiAnTGl0ZXJhbCcsXG4gICAgICAgICAgICAgIHZhbHVlOlxuICAgICAgICAgICAgICAgIChhbm5vdGF0aW9ucy5qc3hJbXBvcnRTb3VyY2UgfHxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5pbXBvcnRTb3VyY2UgfHxcbiAgICAgICAgICAgICAgICAgICdyZWFjdCcpICtcbiAgICAgICAgICAgICAgICAoY29uZmlnLmRldmVsb3BtZW50ID8gJy9qc3gtZGV2LXJ1bnRpbWUnIDogJy9qc3gtcnVudGltZScpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50eXBlICE9PSAnSlNYRWxlbWVudCcgJiYgbm9kZS50eXBlICE9PSAnSlNYRnJhZ21lbnQnKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge0FycmF5PEV4cHJlc3Npb24+fSAqL1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXVxuICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgLy8gRmlndXJlIG91dCBgY2hpbGRyZW5gLlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baW5kZXhdXG5cbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdKU1hFeHByZXNzaW9uQ29udGFpbmVyJykge1xuICAgICAgICAgIC8vIElnbm9yZSBlbXB0eSBleHByZXNzaW9ucy5cbiAgICAgICAgICBpZiAoY2hpbGQuZXhwcmVzc2lvbi50eXBlICE9PSAnSlNYRW1wdHlFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZC5leHByZXNzaW9uKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZC50eXBlID09PSAnSlNYVGV4dCcpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNoaWxkLnZhbHVlXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRhYnMgdy8gc3BhY2VzLlxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnICcpXG4gICAgICAgICAgICAvLyBVc2UgbGluZSBmZWVkcywgZHJvcCBzcGFjZXMgYXJvdW5kIHRoZW0uXG4gICAgICAgICAgICAucmVwbGFjZSgvICooXFxyP1xcbnxcXHIpICovZywgJ1xcbicpXG4gICAgICAgICAgICAvLyBDb2xsYXBzZSBtdWx0aXBsZSBsaW5lIGZlZWRzLlxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbisvZywgJ1xcbicpXG4gICAgICAgICAgICAvLyBEcm9wIGZpbmFsIGxpbmUgZmVlZHMuXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuKyQvLCAnJylcbiAgICAgICAgICAgIC8vIERyb3AgZmlyc3QgbGluZSBmZWVkcy5cbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxuKy8sICcnKVxuICAgICAgICAgICAgLy8gUmVwbGFjZSBsaW5lIGZlZWRzIHdpdGggc3BhY2VzLlxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnICcpXG5cbiAgICAgICAgICAvLyBJZ25vcmUgY29sbGFwc2libGUgdGV4dC5cbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZX1cbiAgICAgICAgICAgIGNyZWF0ZShjaGlsZCwgdGV4dClcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGV4dClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgICAgY2hpbGQudHlwZSAhPT0gJ0pTWEVsZW1lbnQnICYmXG4gICAgICAgICAgICAgIGNoaWxkLnR5cGUgIT09ICdKU1hGcmFnbWVudCcgJiZcbiAgICAgICAgICAgICAgY2hpbGQudHlwZSAhPT0gJ0pTWFNwcmVhZENoaWxkJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9ufSAqL1xuICAgICAgbGV0IG5hbWVcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8UHJvcGVydHkgfCBTcHJlYWRFbGVtZW50Pn0gKi9cbiAgICAgIGNvbnN0IGZpZWxkcyA9IFtdXG4gICAgICAvKiogQHR5cGUge0FycmF5PEV4cHJlc3Npb24+fSAqL1xuICAgICAgbGV0IHBhcmFtZXRlcnMgPSBbXVxuICAgICAgLyoqIEB0eXBlIHtFeHByZXNzaW9uIHwgdW5kZWZpbmVkfSAqL1xuICAgICAgbGV0IGtleVxuXG4gICAgICAvLyBEbyB0aGUgc3R1ZmYgbmVlZGVkIGZvciBlbGVtZW50cy5cbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdKU1hFbGVtZW50Jykge1xuICAgICAgICBuYW1lID0gdG9JZGVudGlmaWVyKG5vZGUub3BlbmluZ0VsZW1lbnQubmFtZSlcblxuICAgICAgICAvLyBJZiB0aGUgbmFtZSBjb3VsZCBiZSBhbiBpZGVudGlmaWVyLCBidXQgc3RhcnQgd2l0aCBhIGxvd2VyY2FzZSBsZXR0ZXIsXG4gICAgICAgIC8vIGl04oCZcyBub3QgYSBjb21wb25lbnQuXG4gICAgICAgIGlmIChuYW1lLnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJiAvXlthLXpdLy50ZXN0KG5hbWUubmFtZSkpIHtcbiAgICAgICAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgICAgICAgY29uc3QgbmV4dCA9IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBuYW1lLm5hbWV9XG4gICAgICAgICAgY3JlYXRlKG5hbWUsIG5leHQpXG4gICAgICAgICAgbmFtZSA9IG5leHRcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgICAgICAgbGV0IHNwcmVhZFxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5vcGVuaW5nRWxlbWVudC5hdHRyaWJ1dGVzXG4gICAgICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICAgICAgLy8gUGxhY2UgcHJvcHMgaW4gdGhlIHJpZ2h0IG9yZGVyLCBiZWNhdXNlIHdlIG1pZ2h0IGhhdmUgZHVwbGljYXRlc1xuICAgICAgICAvLyBpbiB0aGVtIGFuZCB3aGF04oCZcyBzcHJlYWQgaW4uXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2luZGV4XVxuXG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlID09PSAnSlNYU3ByZWFkQXR0cmlidXRlJykge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5hcmd1bWVudC50eXBlID09PSAnT2JqZWN0RXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgZmllbGRzLnB1c2goLi4uYXR0cmlidXRlLmFyZ3VtZW50LnByb3BlcnRpZXMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaWVsZHMucHVzaCh7dHlwZTogJ1NwcmVhZEVsZW1lbnQnLCBhcmd1bWVudDogYXR0cmlidXRlLmFyZ3VtZW50fSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3ByZWFkID0gdHJ1ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wID0gdG9Qcm9wZXJ0eShhdHRyaWJ1dGUpXG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgYXV0b21hdGljICYmXG4gICAgICAgICAgICAgIHByb3Aua2V5LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJlxuICAgICAgICAgICAgICBwcm9wLmtleS5uYW1lID09PSAna2V5J1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmIChzcHJlYWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgYGtleWAgdG8gY29tZSBiZWZvcmUgYW55IHNwcmVhZCBleHByZXNzaW9ucydcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3AudmFsdWVcblxuICAgICAgICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSAhPT0gJ0Fzc2lnbm1lbnRQYXR0ZXJuJyAmJlxuICAgICAgICAgICAgICAgICAgdmFsdWUudHlwZSAhPT0gJ0FycmF5UGF0dGVybicgJiZcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgIT09ICdPYmplY3RQYXR0ZXJuJyAmJlxuICAgICAgICAgICAgICAgICAgdmFsdWUudHlwZSAhPT0gJ1Jlc3RFbGVtZW50J1xuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAga2V5ID0gdmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpZWxkcy5wdXNoKHByb3ApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyDigKZhbmQgZnJhZ21lbnRzLlxuICAgICAgZWxzZSBpZiAoYXV0b21hdGljKSB7XG4gICAgICAgIGltcG9ydHMuZnJhZ21lbnQgPSB0cnVlXG4gICAgICAgIG5hbWUgPSB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnX0ZyYWdtZW50J31cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSB0b01lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgYW5ub3RhdGlvbnMuanN4RnJhZyB8fCBjb25maWcucHJhZ21hRnJhZyB8fCAnUmVhY3QuRnJhZ21lbnQnXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKGF1dG9tYXRpYykge1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdQcm9wZXJ0eScsXG4gICAgICAgICAgICBrZXk6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdjaGlsZHJlbid9LFxuICAgICAgICAgICAgdmFsdWU6XG4gICAgICAgICAgICAgIGNoaWxkcmVuLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICA/IHt0eXBlOiAnQXJyYXlFeHByZXNzaW9uJywgZWxlbWVudHM6IGNoaWxkcmVufVxuICAgICAgICAgICAgICAgIDogY2hpbGRyZW5bMF0sXG4gICAgICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBjaGlsZHJlblxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge0lkZW50aWZpZXIgfCBMaXRlcmFsIHwgTWVtYmVyRXhwcmVzc2lvbn0gKi9cbiAgICAgIGxldCBjYWxsZWVcblxuICAgICAgaWYgKGF1dG9tYXRpYykge1xuICAgICAgICBwYXJhbWV0ZXJzLnB1c2goe3R5cGU6ICdPYmplY3RFeHByZXNzaW9uJywgcHJvcGVydGllczogZmllbGRzfSlcblxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKGtleSlcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2goe3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ3VuZGVmaW5lZCd9KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNTdGF0aWNDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aCA+IDFcblxuICAgICAgICBpZiAoY29uZmlnLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgaW1wb3J0cy5qc3hERVYgPSB0cnVlXG4gICAgICAgICAgY2FsbGVlID0ge1xuICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgbmFtZTogJ19qc3hERVYnXG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmFtZXRlcnMucHVzaCh7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogaXNTdGF0aWNDaGlsZHJlbn0pXG5cbiAgICAgICAgICAvKiogQHR5cGUge09iamVjdEV4cHJlc3Npb259ICovXG4gICAgICAgICAgY29uc3Qgc291cmNlID0ge1xuICAgICAgICAgICAgdHlwZTogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1Byb3BlcnR5JyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3J0aGFuZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgICAgICAgICBrZXk6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdmaWxlTmFtZSd9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnTGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogY29uZmlnLmZpbGVQYXRoIHx8ICc8c291cmNlLmpzPidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobm9kZS5sb2MpIHtcbiAgICAgICAgICAgIHNvdXJjZS5wcm9wZXJ0aWVzLnB1c2goXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUHJvcGVydHknLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAga2luZDogJ2luaXQnLFxuICAgICAgICAgICAgICAgIGtleToge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2xpbmVOdW1iZXInfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IG5vZGUubG9jLnN0YXJ0LmxpbmV9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUHJvcGVydHknLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAga2luZDogJ2luaXQnLFxuICAgICAgICAgICAgICAgIGtleToge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2NvbHVtbk51bWJlcid9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogbm9kZS5sb2Muc3RhcnQuY29sdW1uICsgMX1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChzb3VyY2UsIHt0eXBlOiAnVGhpc0V4cHJlc3Npb24nfSlcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaW1wb3J0cy5qc3hzID0gdHJ1ZVxuICAgICAgICAgIGNhbGxlZSA9IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdfanN4cyd9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1wb3J0cy5qc3ggPSB0cnVlXG4gICAgICAgICAgY2FsbGVlID0ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19qc3gnfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDbGFzc2ljLlxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChmaWVsZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmFtZXRlcnMudW5zaGlmdCh7dHlwZTogJ09iamVjdEV4cHJlc3Npb24nLCBwcm9wZXJ0aWVzOiBmaWVsZHN9KVxuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmFtZXRlcnMudW5zaGlmdCh7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogbnVsbH0pXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsZWUgPSB0b01lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgYW5ub3RhdGlvbnMuanN4IHx8IGNvbmZpZy5wcmFnbWEgfHwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQnXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KG5hbWUpXG4gICAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgICBjb25zdCBjYWxsID0ge1xuICAgICAgICB0eXBlOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgICBjYWxsZWUsXG4gICAgICAgIGFyZ3VtZW50czogcGFyYW1ldGVycyxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlXG4gICAgICB9XG4gICAgICBjcmVhdGUobm9kZSwgY2FsbClcbiAgICAgIHRoaXMucmVwbGFjZShjYWxsKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBUdXJuIGEgSlNYIGF0dHJpYnV0ZSBpbnRvIGEgSmF2YVNjcmlwdCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge0pTWEF0dHJpYnV0ZX0gbm9kZVxuICogICBKU1ggYXR0cmlidXRlLlxuICogQHJldHVybnMge1Byb3BlcnR5fVxuICogICBKUyBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eShub2RlKSB7XG4gIC8qKiBAdHlwZSB7RXhwcmVzc2lvbn0gKi9cbiAgbGV0IHZhbHVlXG5cbiAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICBpZiAobm9kZS52YWx1ZS50eXBlID09PSAnSlNYRXhwcmVzc2lvbkNvbnRhaW5lcicpIHtcbiAgICAgIGNvbnN0IHZhbHVlRXhwcmVzc2lvbiA9IG5vZGUudmFsdWUuZXhwcmVzc2lvblxuICAgICAgYXNzZXJ0KFxuICAgICAgICB2YWx1ZUV4cHJlc3Npb24udHlwZSAhPT0gJ0pTWEVtcHR5RXhwcmVzc2lvbicsXG4gICAgICAgICdgSlNYRW1wdHlFeHByZXNzaW9uYCBpcyBub3QgYWxsb3dlZCBpbiBwcm9wcy4nXG4gICAgICApXG4gICAgICB2YWx1ZSA9IHZhbHVlRXhwcmVzc2lvblxuICAgIH1cbiAgICAvLyBMaXRlcmFsIG9yIGNhbGwgZXhwcmVzc2lvbi5cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG5vZGVWYWx1ZSA9IG5vZGUudmFsdWVcbiAgICAgIGFzc2VydChcbiAgICAgICAgbm9kZVZhbHVlLnR5cGUgIT09ICdKU1hFbGVtZW50JyAmJiBub2RlVmFsdWUudHlwZSAhPT0gJ0pTWEZyYWdtZW50JyxcbiAgICAgICAgJ0pTWHtFbGVtZW50LEZyYWdtZW50fSBhcmUgYWxyZWFkeSBjb21waWxlZCB0byBgQ2FsbEV4cHJlc3Npb25gJ1xuICAgICAgKVxuICAgICAgdmFsdWUgPSBub2RlVmFsdWVcbiAgICAgIGRlbGV0ZSB2YWx1ZS5yYXdcbiAgICB9XG4gIH1cbiAgLy8gQm9vbGVhbiBwcm9wLlxuICBlbHNlIHtcbiAgICB2YWx1ZSA9IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiB0cnVlfVxuICB9XG5cbiAgLyoqIEB0eXBlIHtQcm9wZXJ0eX0gKi9cbiAgY29uc3QgcmVwbGFjZW1lbnQgPSB7XG4gICAgdHlwZTogJ1Byb3BlcnR5JyxcbiAgICBrZXk6IHRvSWRlbnRpZmllcihub2RlLm5hbWUpLFxuICAgIHZhbHVlLFxuICAgIGtpbmQ6ICdpbml0JyxcbiAgICBtZXRob2Q6IGZhbHNlLFxuICAgIHNob3J0aGFuZDogZmFsc2UsXG4gICAgY29tcHV0ZWQ6IGZhbHNlXG4gIH1cbiAgY3JlYXRlKG5vZGUsIHJlcGxhY2VtZW50KVxuICByZXR1cm4gcmVwbGFjZW1lbnRcbn1cblxuLyoqXG4gKiBUdXJuIGEgSlNYIGlkZW50aWZpZXIgaW50byBhIG5vcm1hbCBKUyBpZGVudGlmaWVyLlxuICpcbiAqIEBwYXJhbSB7SlNYSWRlbnRpZmllciB8IEpTWE1lbWJlckV4cHJlc3Npb24gfCBKU1hOYW1lc3BhY2VkTmFtZX0gbm9kZVxuICogICBKU1ggaWRlbnRpZmllci5cbiAqIEByZXR1cm5zIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259XG4gKiAgIEpTIGlkZW50aWZpZXIuXG4gKi9cbmZ1bmN0aW9uIHRvSWRlbnRpZmllcihub2RlKSB7XG4gIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9ufSAqL1xuICBsZXQgcmVwbGFjZVxuXG4gIGlmIChub2RlLnR5cGUgPT09ICdKU1hNZW1iZXJFeHByZXNzaW9uJykge1xuICAgIC8vIGBwcm9wZXJ0eWAgaXMgYWx3YXlzIGEgYEpTWElkZW50aWZpZXJgLCBidXQgaXQgY291bGQgYmUgc29tZXRoaW5nIHRoYXRcbiAgICAvLyBpc27igJl0IGFuIEVTIGlkZW50aWZpZXIgbmFtZS5cbiAgICBjb25zdCBpZCA9IHRvSWRlbnRpZmllcihub2RlLnByb3BlcnR5KVxuICAgIHJlcGxhY2UgPSB7XG4gICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICBvYmplY3Q6IHRvSWRlbnRpZmllcihub2RlLm9iamVjdCksXG4gICAgICBwcm9wZXJ0eTogaWQsXG4gICAgICBjb21wdXRlZDogaWQudHlwZSA9PT0gJ0xpdGVyYWwnLFxuICAgICAgb3B0aW9uYWw6IGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0pTWE5hbWVzcGFjZWROYW1lJykge1xuICAgIHJlcGxhY2UgPSB7XG4gICAgICB0eXBlOiAnTGl0ZXJhbCcsXG4gICAgICB2YWx1ZTogbm9kZS5uYW1lc3BhY2UubmFtZSArICc6JyArIG5vZGUubmFtZS5uYW1lXG4gICAgfVxuICB9XG4gIC8vIE11c3QgYmUgYEpTWElkZW50aWZpZXJgLlxuICBlbHNlIHtcbiAgICByZXBsYWNlID0gaXNJZGVudGlmaWVyTmFtZShub2RlLm5hbWUpXG4gICAgICA/IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6IG5vZGUubmFtZX1cbiAgICAgIDoge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IG5vZGUubmFtZX1cbiAgfVxuXG4gIGNyZWF0ZShub2RlLCByZXBsYWNlKVxuICByZXR1cm4gcmVwbGFjZVxufVxuXG4vKipcbiAqIFR1cm4gYSBkb3R0ZWQgc3RyaW5nIGludG8gYSBtZW1iZXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqICAgSWRlbnRpZmllcnMuXG4gKiBAcmV0dXJucyB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9ufVxuICogICBFeHByZXNzaW9uLlxuICovXG5mdW5jdGlvbiB0b01lbWJlckV4cHJlc3Npb24oaWQpIHtcbiAgY29uc3QgaWRlbnRpZmllcnMgPSBpZC5zcGxpdCgnLicpXG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9uIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgcmVzdWx0XG5cbiAgd2hpbGUgKCsraW5kZXggPCBpZGVudGlmaWVycy5sZW5ndGgpIHtcbiAgICAvKiogQHR5cGUge0lkZW50aWZpZXIgfCBMaXRlcmFsfSAqL1xuICAgIGNvbnN0IHByb3AgPSBpc0lkZW50aWZpZXJOYW1lKGlkZW50aWZpZXJzW2luZGV4XSlcbiAgICAgID8ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogaWRlbnRpZmllcnNbaW5kZXhdfVxuICAgICAgOiB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogaWRlbnRpZmllcnNbaW5kZXhdfVxuICAgIHJlc3VsdCA9IHJlc3VsdFxuICAgICAgPyB7XG4gICAgICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICAgIG9iamVjdDogcmVzdWx0LFxuICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgIGNvbXB1dGVkOiBCb29sZWFuKGluZGV4ICYmIHByb3AudHlwZSA9PT0gJ0xpdGVyYWwnKSxcbiAgICAgICAgICBvcHRpb25hbDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgOiBwcm9wXG4gIH1cblxuICBhc3NlcnQocmVzdWx0LCAnYWx3YXlzIGEgcmVzdWx0JylcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEluaGVyaXQgc29tZSBmaWVsZHMgZnJvbSBgZnJvbWAgaW50byBgdG9gLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gZnJvbVxuICogICBOb2RlIHRvIGluaGVyaXQgZnJvbS5cbiAqIEBwYXJhbSB7Tm9kZX0gdG9cbiAqICAgTm9kZSB0byBhZGQgdG8uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGUoZnJvbSwgdG8pIHtcbiAgY29uc3QgZmllbGRzID0gWydzdGFydCcsICdlbmQnLCAnbG9jJywgJ3JhbmdlJywgJ2NvbW1lbnRzJ11cbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGZpZWxkcy5sZW5ndGgpIHtcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tpbmRleF1cbiAgICBpZiAoZmllbGQgaW4gZnJvbSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW5kZXhhYmxlLlxuICAgICAgdG9bZmllbGRdID0gZnJvbVtmaWVsZF1cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/estree-util-build-jsx@3.0.1/node_modules/estree-util-build-jsx/lib/index.js\n");

/***/ })

};
;